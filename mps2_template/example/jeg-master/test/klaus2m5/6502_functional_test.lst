AS65 Assembler for R6502 [1.42].  Copyright 1994-2007, Frank A. Kingswood                                                Page    1
---------------------------------------------------- 6502_functional_test.a65 ----------------------------------------------------

5803 lines read, no errors in pass 1.
                        ;
                        ; 6 5 0 2   F U N C T I O N A L   T E S T
                        ;
                        ; Copyright (C) 2012-2013  Klaus Dormann
                        ;
                        ; This program is free software: you can redistribute it and/or modify
                        ; it under the terms of the GNU General Public License as published by
                        ; the Free Software Foundation, either version 3 of the License, or
                        ; (at your option) any later version.
                        ;
                        ; This program is distributed in the hope that it will be useful,
                        ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                        ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                        ; GNU General Public License for more details.
                        ;
                        ; You should have received a copy of the GNU General Public License
                        ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
                        
                        
                        ; This program is designed to test all opcodes of a 6502 emulator using all
                        ; addressing modes with focus on propper setting of the processor status
                        ; register bits.
                        ; 
                        ; version 16-aug-2013
                        ; edited to provide a pre-configured bin file loadable at $0000 for full 64k
                        ; contact info at http://2m5.de or email K@2m5.de
                        ;
                        ; assembled with AS65 from http://www.kingswood-consulting.co.uk/assemblers/
                        ; command line switches: -l -m -s2 -w -h0
                        ;                         |  |  |   |  no page headers in listing
                        ;                         |  |  |   wide listing (133 char/col)
                        ;                         |  |  write intel hex file instead of binary
                        ;                         |  expand macros in listing
                        ;                         generate pass2 listing
                        ;
                        ; No IO - should be run from a monitor with access to registers.
                        ; To run load intel hex image with a load command, than alter PC to 400 hex
                        ; (code_segment) and enter a go command.
                        ; Loop on program counter determines error or successful completion of test.
                        ; Check listing for relevant traps (jump/branch *).
                        ; Please note that in early tests some instructions will have to be used before
                        ; they are actually tested!
                        ;
                        ; RESET, NMI or IRQ should not occur and will be trapped if vectors are enabled.
                        ; Tests documented behavior of the original NMOS 6502 only! No unofficial
                        ; opcodes. Additional opcodes of newer versions of the CPU (65C02, 65816) will
                        ; not be tested. Decimal ops will only be tested with valid BCD operands and
                        ; N V Z flags will be ignored.
                        ;
                        ; Debugging hints:
                        ;     Most of the code is written sequentially. if you hit a trap, check the
                        ;   immediately preceeding code for the instruction to be tested. Results are
                        ;   tested first, flags are checked second by pushing them onto the stack and
                        ;   pulling them to the accumulator after the result was checked. The "real"
                        ;   flags are no longer valid for the tested instruction at this time!
                        ;     If the tested instruction was indexed, the relevant index (X or Y) must
                        ;   also be checked. Opposed to the flags, X and Y registers are still valid.
                        ;
                        ; versions:
                        ;   28-jul-2012  1st version distributed for testing
                        ;   29-jul-2012  fixed references to location 0, now #0
                        ;                added license - GPLv3
                        ;   30-jul-2012  added configuration options
                        ;   01-aug-2012  added trap macro to allow user to change error handling
                        ;   01-dec-2012  fixed trap in branch field must be a branch
                        ;   02-mar-2013  fixed PLA flags not tested
                        ;   19-jul-2013  allowed ROM vectors to be loaded when load_data_direct = 0
                        ;                added test sequence check to detect if tests jump their fence
                        ;   23-jul-2013  added RAM integrity check option
                        ;   16-aug-2013  added error report to standard output option
                        
                        
                        ; C O N F I G U R A T I O N
                        
                        ;ROM_vectors writable (0=no, 1=yes)
                        ;if ROM vectors can not be used interrupts will not be trapped
                        ;as a consequence BRK can not be tested but will be emulated to test RTI
0001 =                  ROM_vectors = 1
                        
                        ;load_data_direct (0=move from code segment, 1=load directly)
                        ;loading directly is preferred but may not be supported by your platform
                        ;0 produces only consecutive object code, 1 is not suitable for a binary image
0001 =                  load_data_direct = 1
                        
                        ;I_flag behavior (0=force enabled, 1=force disabled, 2=prohibit change, 3=allow
                        ;change) 2 requires extra code and is not recommended. SEI & CLI can only be
                        ;tested if you allow changing the interrupt status (I_flag = 3)
0003 =                  I_flag = 3
                        
                        ;configure memory - try to stay away from memory used by the system
                        ;zero_page memory start address, $50 (80) consecutive Bytes required
                        ;                                add 2 if I_flag = 2
000a =                  zero_page = $a  
                        
                        ;data_segment memory start address, $5B (91) consecutive Bytes required
0200 =                  data_segment = $200  
                            if (data_segment & $ff) != 0
                                ERROR ERROR ERROR low byte of data_segment MUST be $00 !!
                            endif  
                        
                        ;code_segment memory start address, 13kB of consecutive space required
                        ;                                   add 2.5 kB if I_flag = 2
                        ;parts of the code are self modifying and must reside in RAM
0400 =                  code_segment = $400  
                        
                        ;report errors through I/O channel (0=use standard self trap loops, 1=include
                        ;report.i65 as I/O channel, add 3.5 kB)
0000 =                  report = 0
                        
                        ;RAM integrity test option. Checks for undesired RAM writes.
                        ;set lowest non RAM or RAM mirror address page (-1=disable, 0=64k, $40=16k)
                        ;leave disabled if a monitor, OS or background interrupt is allowed to alter RAM
ffff =                  ram_top = -1
                        
                                noopt       ;do not take shortcuts
                        
                        ;macros for error & success traps to allow user modification
                        ;example:
                        ;trap    macro
                        ;        jsr my_error_handler
                        ;        endm
                        ;trap_eq macro
                        ;        bne skip\?
                        ;        trap           ;failed equal (zero)
                        ;skip\?
                        ;        endm
                        ;
                        ; my_error_handler should pop the calling address from the stack and report it.
                        ; putting larger portions of code (more than 3 bytes) inside the trap macro
                        ; may lead to branch range problems for some tests.
                            if report = 0
                        trap    macro
                                jmp *           ;failed anyway
                                endm
                        trap_eq macro
                                beq *           ;failed equal (zero)
                                endm
                        trap_ne macro
                                bne *           ;failed not equal (non zero)
                                endm
                        trap_cs macro
                                bcs *           ;failed carry set
                                endm
                        trap_cc macro
                                bcc *           ;failed carry clear
                                endm
                        trap_mi macro
                                bmi *           ;failed minus (bit 7 set)
                                endm
                        trap_pl macro
                                bpl *           ;failed plus (bit 7 clear)
                                endm
                        trap_vs macro
                                bvs *           ;failed overflow set
                                endm
                        trap_vc macro
                                bvc *           ;failed overflow clear
                                endm
                        ; please observe that during the test the stack gets invalidated
                        ; therefore a RTS inside the success macro is not possible
                        success macro
                                jmp *           ;test passed, no errors
                                endm
                            endif
                            if report = 1
                        trap    macro
                                jsr report_error
                                endm
                        trap_eq macro
                                bne skip\?
                                trap           ;failed equal (zero)
                        skip\?
                                endm
                        trap_ne macro
                                beq skip\?
                                trap            ;failed not equal (non zero)
                        skip\?
                                endm
                        trap_cs macro
                                bcc skip\?
                                trap            ;failed carry set
                        skip\?
                                endm
                        trap_cc macro
                                bcs skip\?
                                trap            ;failed carry clear
                        skip\?
                                endm
                        trap_mi macro
                                bpl skip\?
                                trap            ;failed minus (bit 7 set)
                        skip\?
                                endm
                        trap_pl macro
                                bmi skip\?
                                trap            ;failed plus (bit 7 clear)
                        skip\?
                                endm
                        trap_vs macro
                                bvc skip\?
                                trap            ;failed overflow set
                        skip\?
                                endm
                        trap_vc macro
                                bvs skip\?
                                trap            ;failed overflow clear
                        skip\?
                                endm
                        ; please observe that during the test the stack gets invalidated
                        ; therefore a RTS inside the success macro is not possible
                        success macro
                                jsr report_success
                                endm
                            endif
                        
                        
0001 =                  carry   equ %00000001   ;flag bits in status
0002 =                  zero    equ %00000010
0004 =                  intdis  equ %00000100
0008 =                  decmode equ %00001000
0010 =                  break   equ %00010000
0020 =                  reserv  equ %00100000
0040 =                  overfl  equ %01000000
0080 =                  minus   equ %10000000
                        
0001 =                  fc      equ carry
0002 =                  fz      equ zero
0003 =                  fzc     equ carry+zero
0040 =                  fv      equ overfl
0042 =                  fvz     equ overfl+zero
0080 =                  fn      equ minus
0081 =                  fnc     equ minus+carry
0082 =                  fnz     equ minus+zero
0083 =                  fnzc    equ minus+zero+carry
00c0 =                  fnv     equ minus+overfl
                        
0030 =                  fao     equ break+reserv    ;bits always on after PHP, BRK
0034 =                  fai     equ fao+intdis      ;+ forced interrupt disable
00ff =                  m8      equ $ff             ;8 bit mask
00fb =                  m8i     equ $ff&~intdis     ;8 bit mask - interrupt disable
                        
                        ;macros to allow masking of status bits.
                        ;masking of interrupt enable/disable on load and compare
                        ;masking of always on bits after PHP or BRK (unused & break) on compare
                                if I_flag = 0
                        load_flag   macro
                                    lda #\1&m8i         ;force enable interrupts (mask I)
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fao)&m8i   ;I_flag is always enabled + always on bits
                                    endm
                        eor_flag    macro
                                    eor #(\1&m8i|fao)   ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 1
                        load_flag   macro
                                    lda #\1|intdis      ;force disable interrupts
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fai)&m8    ;I_flag is always disabled + always on bits
                                    endm
                        eor_flag    macro
                                    eor #(\1|fai)       ;invert expected flags + always on bits + I
                                    endm
                                endif
                                if I_flag = 2
                        load_flag   macro
                                    lda #\1
                                    ora flag_I_on       ;restore I-flag
                                    and flag_I_off
                                    endm
                        cmp_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    cmp #(\1|fao)&m8i   ;expected flags + always on bits, mask I
                                    endm
                        eor_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    eor #(\1&m8i|fao)   ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 3
                        load_flag   macro
                                    lda #\1             ;allow test to change I-flag (no mask)
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fao)&m8    ;expected flags + always on bits
                                    endm
                        eor_flag    macro
                                    eor #\1|fao         ;invert expected flags + always on bits
                                    endm
                                endif
                        
                        ;macros to set (register|memory|zeropage) & status
                        set_stat    macro       ;setting flags in the processor status register
                                    load_flag \1
                                    pha         ;use stack to load status
                                    plp
                                    endm
                        
                        set_a       macro       ;precharging accu & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda #\1     ;precharge accu
                                    plp
                                    endm
                        
                        set_x       macro       ;precharging index & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    ldx #\1     ;precharge index x
                                    plp
                                    endm
                        
                        set_y       macro       ;precharging index & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    ldy #\1     ;precharge index y
                                    plp
                                    endm
                        
                        set_ax      macro       ;precharging indexed accu & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;precharge accu
                                    plp
                                    endm
                        
                        set_ay      macro       ;precharging indexed accu & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,y    ;precharge accu
                                    plp
                                    endm
                        
                        set_z       macro       ;precharging indexed zp & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to zeropage
                                    sta zpt
                                    plp
                                    endm
                        
                        set_zx      macro       ;precharging zp,x & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to indexed zeropage
                                    sta zpt,x
                                    plp
                                    endm
                        
                        set_abs     macro       ;precharging indexed memory & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to memory
                                    sta abst
                                    plp
                                    endm
                        
                        set_absx    macro       ;precharging abs,x & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to indexed memory
                                    sta abst,x
                                    plp
                                    endm
                        
                        ;macros to test (register|memory|zeropage) & status & (mask)
                        tst_stat    macro       ;testing flags in the processor status register
                                    php         ;save status
                                    pla         ;use stack to retrieve status
                                    pha
                                    cmp_flag \1
                                    trap_ne
                                    plp         ;restore status
                                    endm
                                    
                        tst_a       macro       ;testing result in accu & flags
                                    php         ;save flags
                                    cmp #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_x       macro       ;testing result in x index & flags
                                    php         ;save flags
                                    cpx #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_y       macro       ;testing result in y index & flags
                                    php         ;save flags
                                    cpy #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_ax      macro       ;indexed testing result in accu & flags
                                    php         ;save flags
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne     ;
                                    endm
                        
                        tst_ay      macro       ;indexed testing result in accu & flags
                                    php         ;save flags
                                    cmp \1,y    ;test result
                                    trap_ne     ;
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,y    ;test flags
                                    trap_ne
                                    endm
                                
                        tst_z       macro       ;indexed testing result in zp & flags
                                    php         ;save flags
                                    lda zpt
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_zx      macro       ;testing result in zp,x & flags
                                    php         ;save flags
                                    lda zpt,x
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_abs     macro       ;indexed testing result in memory & flags
                                    php         ;save flags
                                    lda abst
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_absx    macro       ;testing result in abs,x & flags
                                    php         ;save flags
                                    lda abst,x
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                                    
                        ; RAM integrity test
                        ;   verifies that none of the previous tests has altered RAM outside of the
                        ;   designated write areas.
                        ;   uses zpt word as indirect pointer, zpt+2 word as checksum
                                if ram_top > -1
                        check_ram   macro 
                                    cld
                                    lda #0
                                    sta zpt         ;set low byte of indirect pointer
                                    sta zpt+3       ;checksum high byte
                                    sta range_adr   ;reset self modifying code
                                    sta tandi1
                                    sta tandi2
                                    sta teori1
                                    sta teori2
                                    sta torai1
                                    sta torai2
                                    sta chkdadi  
                                    sta chkdsbi
                                    sta chkadi
                                    sta chksbi
                                    clc
                                    ldx #zp_bss-zero_page ;zeropage - write test area
                        ccs3\?      adc zero_page,x
                                    bcc ccs2\?
                                    inc zpt+3       ;carry to high byte
                                    clc
                        ccs2\?      inx
                                    bne ccs3\?
                                    ldx #hi(data_segment) ;set high byte of indirect pointer
                                    stx zpt+1
                                    ldy #lo(data_bss) ;data after write test area
                        ccs5\?      adc (zpt),y
                                    bcc ccs4\?
                                    inc zpt+3       ;carry to high byte
                                    clc
                        ccs4\?      iny
                                    bne ccs5\?
                                    inx             ;advance RAM high address
                                    stx zpt+1
                                    cpx #ram_top
                                    bne ccs5\?
                                    sta zpt+2       ;checksum low is
                                    cmp ram_chksm   ;checksum low expected
                                    trap_ne         ;checksum mismatch
                                    lda zpt+3       ;checksum high is
                                    cmp ram_chksm+1 ;checksum high expected
                                    trap_ne         ;checksum mismatch
                                    endm            
                                else
                        check_ram   macro
                                    ;RAM check disabled - RAM size not set
                                    endm
                                endif
                        
                        next_test   macro           ;make sure, tests don't jump the fence
                                    lda test_case   ;previous test
                                    cmp #test_num
                                    trap_ne         ;test is out of sequence
                        test_num = test_num + 1
                                    lda #test_num   ;*** next tests' number
                                    sta test_case
                                    ;check_ram       ;uncomment to find altered RAM after each test
                                    endm
                        
                            if load_data_direct = 1
                                data
                            else
                                bss                 ;uninitialized segment, copy of data at end of code!
                            endif
                        ;        org zero_page
0000 =                          org 0               ;edited to provide binaries loading from 0
0000 : 00000000000000..         ds  zero_page
                        ;break test interrupt save
000a : 00               irq_a   ds  1               ;a register
000b : 00               irq_x   ds  1               ;x register
                            if I_flag = 2
                        ;masking for I bit in status
                        flag_I_on   ds  1           ;or mask to load flags   
                        flag_I_off  ds  1           ;and mask to load flags
                            endif
000c :                  zpt                         ;5 bytes store/modify test area
                        ;add/subtract operand generation and result/flag prediction
000c : 00               adfc    ds  1               ;carry flag before op
000d : 00               ad1     ds  1               ;operand 1 - accumulator
000e : 00               ad2     ds  1               ;operand 2 - memory / immediate
000f : 00               adrl    ds  1               ;expected result bits 0-7
0010 : 00               adrh    ds  1               ;expected result bit 8 (carry)
0011 : 00               adrf    ds  1               ;expected flags NV0000ZC (only binary mode)
0012 : 00               sb2     ds  1               ;operand 2 complemented for subtract
0013 :                  zp_bss
0013 : c3824100         zp1     db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
0017 : 7f               zp7f    db  $7f             ;test pattern for compare  
                        ;logical zeropage operands
0018 : 001f7180         zpOR    db  0,$1f,$71,$80   ;test pattern for OR
001c : 0fff7f80         zpAN    db  $0f,$ff,$7f,$80 ;test pattern for AND
0020 : ff0f8f8f         zpEO    db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;indirect addressing pointers
0024 : 0802             ind1    dw  abs1            ;indirect pointer to pattern in absolute memory
0026 : 0902                     dw  abs1+1
0028 : 0a02                     dw  abs1+2
002a : 0b02                     dw  abs1+3
002c : 0c02                     dw  abs7f
002e : 1001             inw1    dw  abs1-$f8        ;indirect pointer for wrap-test pattern
0030 : 0302             indt    dw  abst            ;indirect pointer to store area in absolute memory
0032 : 0402                     dw  abst+1
0034 : 0502                     dw  abst+2
0036 : 0602                     dw  abst+3
0038 : 0b01             inwt    dw  abst-$f8        ;indirect pointer for wrap-test store
003a : 3f02             indAN   dw  absAN           ;indirect pointer to AND pattern in absolute memory
003c : 4002                     dw  absAN+1
003e : 4102                     dw  absAN+2
0040 : 4202                     dw  absAN+3
0042 : 4302             indEO   dw  absEO           ;indirect pointer to EOR pattern in absolute memory
0044 : 4402                     dw  absEO+1
0046 : 4502                     dw  absEO+2
0048 : 4602                     dw  absEO+3
004a : 3b02             indOR   dw  absOR           ;indirect pointer to OR pattern in absolute memory
004c : 3c02                     dw  absOR+1
004e : 3d02                     dw  absOR+2
0050 : 3e02                     dw  absOR+3
                        ;add/subtract indirect pointers
0052 : 0302             adi2    dw  ada2            ;indirect pointer to operand 2 in absolute memory
0054 : 0402             sbi2    dw  sba2            ;indirect pointer to complemented operand 2 (SBC)
0056 : 0401             adiy2   dw  ada2-$ff        ;with offset for indirect indexed
0058 : 0501             sbiy2   dw  sba2-$ff
005a :                  zp_bss_end
                           
0200 =                          org data_segment
0200 : 00               test_case   ds  1           ;current test number
0201 : 0000             ram_chksm   ds  2           ;checksum for RAM integrity test
                        ;add/subtract operand copy - abs tests write area
0203 :                  abst                        ;5 bytes store/modify test area
0203 : 00               ada2    ds  1               ;operand 2
0204 : 00               sba2    ds  1               ;operand 2 complemented for subtract
0205 : 000000                   ds  3               ;fill remaining bytes
0208 :                  data_bss
0208 : c3824100         abs1    db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
020c : 7f               abs7f   db  $7f             ;test pattern for compare
                        ;loads
020d : 80800002         fLDx    db  fn,fn,0,fz      ;expected flags for load
                        ;shifts
0211 :                  rASL                        ;expected result ASL & ROL -carry  
0211 : 86048200         rROL    db  $86,$04,$82,0   ; "
0215 : 87058301         rROLc   db  $87,$05,$83,1   ;expected result ROL +carry
0219 :                  rLSR                        ;expected result LSR & ROR -carry
0219 : 61412000         rROR    db  $61,$41,$20,0   ; "
021d : e1c1a080         rRORc   db  $e1,$c1,$a0,$80 ;expected result ROR +carry
0221 :                  fASL                        ;expected flags for shifts
0221 : 81018002         fROL    db  fnc,fc,fn,fz    ;no carry in
0225 : 81018000         fROLc   db  fnc,fc,fn,0     ;carry in
0229 :                  fLSR
0229 : 01000102         fROR    db  fc,0,fc,fz      ;no carry in
022d : 81808180         fRORc   db  fnc,fn,fnc,fn   ;carry in
                        ;increments (decrements)
0231 : 7f80ff0001       rINC    db  $7f,$80,$ff,0,1 ;expected result for INC/DEC
0236 : 0080800200       fINC    db  0,fn,fn,fz,0    ;expected flags for INC/DEC
                        ;logical memory operand
023b : 001f7180         absOR   db  0,$1f,$71,$80   ;test pattern for OR
023f : 0fff7f80         absAN   db  $0f,$ff,$7f,$80 ;test pattern for AND
0243 : ff0f8f8f         absEO   db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;logical accu operand
0247 : 00f11f00         absORa  db  0,$f1,$1f,0     ;test pattern for OR
024b : f0ffffff         absANa  db  $f0,$ff,$ff,$ff ;test pattern for AND
024f : fff0f00f         absEOa  db  $ff,$f0,$f0,$0f ;test pattern for EOR
                        ;logical results
0253 : 00ff7f80         absrlo  db  0,$ff,$7f,$80
0257 : 02800080         absflo  db  fz,fn,0,fn
025b :                  data_bss_end
                        
                        
                                code
0400 =                          org code_segment
0400 : d8               start   cld
0401 : a2ff                     ldx #$ff
0403 : 9a                       txs
0404 : a900                     lda #0          ;*** test 0 = initialize
0406 : 8d0002                   sta test_case
0000 =                  test_num = 0
                        
                        ;stop interrupts before initializing BSS
                            if I_flag = 1
                                sei
                            endif
                            
                        ;initialize I/O for report channel
                            if report = 1
                                jsr report_init
                            endif
                            
                        ;initialize BSS segment
                            if load_data_direct != 1
                                ldx #zp_end-zp_init-1
                        ld_zp   lda zp_init,x
                                sta zp_bss,x
                                dex
                                bpl ld_zp
                                ldx #data_end-data_init-1
                        ld_data lda data_init,x
                                sta data_bss,x
                                dex
                                bpl ld_data
                              if ROM_vectors = 1
                                ldx #5
                        ld_vect lda vec_init,x
                                sta vec_bss,x
                                dex
                                bpl ld_vect
                              endif
                            endif
                        
                        ;retain status of interrupt flag
                            if I_flag = 2
                                php
                                pla
                                and #4          ;isolate flag
                                sta flag_I_on   ;or mask
                                eor #lo(~4)     ;reverse
                                sta flag_I_off  ;and mask
                            endif
                                
                        ;generate checksum for RAM integrity test
                            if ram_top > -1
                                lda #0 
                                sta zpt         ;set low byte of indirect pointer
                                sta ram_chksm+1 ;checksum high byte
                                sta range_adr   ;reset self modifying code
                                sta tandi1
                                sta tandi2
                                sta teori1
                                sta teori2
                                sta torai1
                                sta torai2
                                sta chkdadi  
                                sta chkdsbi
                                sta chkadi
                                sta chksbi
                                clc
                                ldx #zp_bss-zero_page ;zeropage - write test area
                        gcs3    adc zero_page,x
                                bcc gcs2
                                inc ram_chksm+1 ;carry to high byte
                                clc
                        gcs2    inx
                                bne gcs3
                                ldx #hi(data_segment) ;set high byte of indirect pointer
                                stx zpt+1
                                ldy #lo(data_bss) ;data after write test area
                        gcs5    adc (zpt),y
                                bcc gcs4
                                inc ram_chksm+1 ;carry to high byte
                                clc
                        gcs4    iny
                                bne gcs5
                                inx             ;advance RAM high address
                                stx zpt+1
                                cpx #ram_top
                                bne gcs5
                                sta ram_chksm   ;checksum complete
                            endif
                                next_test            
0409 : ad0002          >            lda test_case   ;previous test
040c : c900            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
040e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0001 =                 >test_num = test_num + 1
0410 : a901            >            lda #test_num   ;*** next tests' number
0412 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ;testing relative addressing with BEQ
0415 : a0fe                     ldy #$fe        ;testing maximum range, not -1/-2 (invalid/self adr)
0417 :                  range_loop
0417 : 88                       dey             ;next relative address
0418 : 98                       tya
0419 : aa                       tax             ;precharge count to end of loop
041a : 1003                     bpl range_fw    ;calculate relative address
041c : 18                       clc             ;avoid branch self or to relative address of branch
041d : 6902                     adc #2
041f :                  range_fw
041f : 497f                     eor #$7f        ;complement except sign
0421 : 8da804                   sta range_adr   ;load into test target
0424 : a900                     lda #0          ;should set zero flag in status register
0426 : 4ca704                   jmp range_op
                                
                                ;relative address target field with branch under test in the middle                       
0429 : ca                       dex             ;-128 - max backward
042a : ca                       dex
042b : ca                       dex
042c : ca                       dex
042d : ca                       dex
042e : ca                       dex
042f : ca                       dex
0430 : ca                       dex
0431 : ca                       dex             ;-120
0432 : ca                       dex
0433 : ca                       dex
0434 : ca                       dex
0435 : ca                       dex
0436 : ca                       dex
0437 : ca                       dex
0438 : ca                       dex
0439 : ca                       dex
043a : ca                       dex
043b : ca                       dex             ;-110
043c : ca                       dex
043d : ca                       dex
043e : ca                       dex
043f : ca                       dex
0440 : ca                       dex
0441 : ca                       dex
0442 : ca                       dex
0443 : ca                       dex
0444 : ca                       dex
0445 : ca                       dex             ;-100
0446 : ca                       dex
0447 : ca                       dex
0448 : ca                       dex
0449 : ca                       dex
044a : ca                       dex
044b : ca                       dex
044c : ca                       dex
044d : ca                       dex
044e : ca                       dex
044f : ca                       dex             ;-90
0450 : ca                       dex
0451 : ca                       dex
0452 : ca                       dex
0453 : ca                       dex
0454 : ca                       dex
0455 : ca                       dex
0456 : ca                       dex
0457 : ca                       dex
0458 : ca                       dex
0459 : ca                       dex             ;-80
045a : ca                       dex
045b : ca                       dex
045c : ca                       dex
045d : ca                       dex
045e : ca                       dex
045f : ca                       dex
0460 : ca                       dex
0461 : ca                       dex
0462 : ca                       dex
0463 : ca                       dex             ;-70
0464 : ca                       dex
0465 : ca                       dex
0466 : ca                       dex
0467 : ca                       dex
0468 : ca                       dex
0469 : ca                       dex
046a : ca                       dex
046b : ca                       dex
046c : ca                       dex
046d : ca                       dex             ;-60
046e : ca                       dex
046f : ca                       dex
0470 : ca                       dex
0471 : ca                       dex
0472 : ca                       dex
0473 : ca                       dex
0474 : ca                       dex
0475 : ca                       dex
0476 : ca                       dex
0477 : ca                       dex             ;-50
0478 : ca                       dex
0479 : ca                       dex
047a : ca                       dex
047b : ca                       dex
047c : ca                       dex
047d : ca                       dex
047e : ca                       dex
047f : ca                       dex
0480 : ca                       dex
0481 : ca                       dex             ;-40
0482 : ca                       dex
0483 : ca                       dex
0484 : ca                       dex
0485 : ca                       dex
0486 : ca                       dex
0487 : ca                       dex
0488 : ca                       dex
0489 : ca                       dex
048a : ca                       dex
048b : ca                       dex             ;-30
048c : ca                       dex
048d : ca                       dex
048e : ca                       dex
048f : ca                       dex
0490 : ca                       dex
0491 : ca                       dex
0492 : ca                       dex
0493 : ca                       dex
0494 : ca                       dex
0495 : ca                       dex             ;-20
0496 : ca                       dex
0497 : ca                       dex
0498 : ca                       dex
0499 : ca                       dex
049a : ca                       dex
049b : ca                       dex
049c : ca                       dex
049d : ca                       dex
049e : ca                       dex
049f : ca                       dex             ;-10
04a0 : ca                       dex
04a1 : ca                       dex
04a2 : ca                       dex
04a3 : ca                       dex
04a4 : ca                       dex
04a5 : ca                       dex
04a6 : ca                       dex             ;-3
04a7 :                  range_op                ;test target with zero flag=0, z=1 if previous dex
04a8 =                  range_adr   = *+1       ;modifiable relative address
04a7 : f03e                     beq *+64        ;if called without modification
04a9 : ca                       dex             ;+0
04aa : ca                       dex
04ab : ca                       dex
04ac : ca                       dex
04ad : ca                       dex
04ae : ca                       dex
04af : ca                       dex
04b0 : ca                       dex
04b1 : ca                       dex
04b2 : ca                       dex
04b3 : ca                       dex             ;+10
04b4 : ca                       dex
04b5 : ca                       dex
04b6 : ca                       dex
04b7 : ca                       dex
04b8 : ca                       dex
04b9 : ca                       dex
04ba : ca                       dex
04bb : ca                       dex
04bc : ca                       dex
04bd : ca                       dex             ;+20
04be : ca                       dex
04bf : ca                       dex
04c0 : ca                       dex
04c1 : ca                       dex
04c2 : ca                       dex
04c3 : ca                       dex
04c4 : ca                       dex
04c5 : ca                       dex
04c6 : ca                       dex
04c7 : ca                       dex             ;+30
04c8 : ca                       dex
04c9 : ca                       dex
04ca : ca                       dex
04cb : ca                       dex
04cc : ca                       dex
04cd : ca                       dex
04ce : ca                       dex
04cf : ca                       dex
04d0 : ca                       dex
04d1 : ca                       dex             ;+40
04d2 : ca                       dex
04d3 : ca                       dex
04d4 : ca                       dex
04d5 : ca                       dex
04d6 : ca                       dex
04d7 : ca                       dex
04d8 : ca                       dex
04d9 : ca                       dex
04da : ca                       dex
04db : ca                       dex             ;+50
04dc : ca                       dex
04dd : ca                       dex
04de : ca                       dex
04df : ca                       dex
04e0 : ca                       dex
04e1 : ca                       dex
04e2 : ca                       dex
04e3 : ca                       dex
04e4 : ca                       dex
04e5 : ca                       dex             ;+60
04e6 : ca                       dex
04e7 : ca                       dex
04e8 : ca                       dex
04e9 : ca                       dex
04ea : ca                       dex
04eb : ca                       dex
04ec : ca                       dex
04ed : ca                       dex
04ee : ca                       dex
04ef : ca                       dex             ;+70
04f0 : ca                       dex
04f1 : ca                       dex
04f2 : ca                       dex
04f3 : ca                       dex
04f4 : ca                       dex
04f5 : ca                       dex
04f6 : ca                       dex
04f7 : ca                       dex
04f8 : ca                       dex
04f9 : ca                       dex             ;+80
04fa : ca                       dex
04fb : ca                       dex
04fc : ca                       dex
04fd : ca                       dex
04fe : ca                       dex
04ff : ca                       dex
0500 : ca                       dex
0501 : ca                       dex
0502 : ca                       dex
0503 : ca                       dex             ;+90
0504 : ca                       dex
0505 : ca                       dex
0506 : ca                       dex
0507 : ca                       dex
0508 : ca                       dex
0509 : ca                       dex
050a : ca                       dex
050b : ca                       dex
050c : ca                       dex
050d : ca                       dex             ;+100
050e : ca                       dex
050f : ca                       dex
0510 : ca                       dex
0511 : ca                       dex
0512 : ca                       dex
0513 : ca                       dex
0514 : ca                       dex
0515 : ca                       dex
0516 : ca                       dex
0517 : ca                       dex             ;+110
0518 : ca                       dex
0519 : ca                       dex
051a : ca                       dex
051b : ca                       dex
051c : ca                       dex
051d : ca                       dex
051e : ca                       dex
051f : ca                       dex
0520 : ca                       dex
0521 : ca                       dex             ;+120
0522 : ca                       dex
0523 : ca                       dex
0524 : ca                       dex
0525 : ca                       dex
0526 : ca                       dex
0527 : ca                       dex
0528 : f003                     beq range_ok    ;+127 - max forward
                                trap            ; bad range
052a : 4c2a05          >        jmp *           ;failed anyway
                        
052d :                  range_ok
052d : c000                     cpy #0
052f : f003                     beq range_end   
0531 : 4c1704                   jmp range_loop
0534 :                  range_end               ;range test successful
                                next_test
0534 : ad0002          >            lda test_case   ;previous test
0537 : c901            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0539 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0002 =                 >test_num = test_num + 1
053b : a902            >            lda #test_num   ;*** next tests' number
053d : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ;partial test BNE & CMP, CPX, CPY immediate
0540 : c001                     cpy #1          ;testing BNE true
0542 : d003                     bne test_bne
                                trap 
0544 : 4c4405          >        jmp *           ;failed anyway
                        
0547 :                  test_bne
0547 : a900                     lda #0 
0549 : c900                     cmp #0          ;test compare immediate 
                                trap_ne
054b : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                trap_cc
054d : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_mi
054f : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
0551 : c901                     cmp #1
                                trap_eq 
0553 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_cs
0555 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_pl
0557 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
0559 : aa                       tax 
055a : e000                     cpx #0          ;test compare x immediate
                                trap_ne
055c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                trap_cc
055e : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_mi
0560 : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
0562 : e001                     cpx #1
                                trap_eq 
0564 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_cs
0566 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_pl
0568 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
056a : a8                       tay 
056b : c000                     cpy #0          ;test compare y immediate
                                trap_ne
056d : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                trap_cc
056f : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_mi
0571 : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
0573 : c001                     cpy #1
                                trap_eq 
0575 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_cs
0577 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_pl
0579 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                next_test
057b : ad0002          >            lda test_case   ;previous test
057e : c902            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0580 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0003 =                 >test_num = test_num + 1
0582 : a903            >            lda #test_num   ;*** next tests' number
0584 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        ;testing stack operations PHA PHP PLA PLP
                                    
0587 : a2ff                     ldx #$ff        ;initialize stack
0589 : 9a                       txs
058a : a955                     lda #$55
058c : 48                       pha
058d : a9aa                     lda #$aa
058f : 48                       pha
0590 : cdfe01                   cmp $1fe        ;on stack ?
                                trap_ne
0593 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0595 : ba                       tsx
0596 : 8a                       txa             ;overwrite accu
0597 : c9fd                     cmp #$fd        ;sp decremented?
                                trap_ne
0599 : d0fe            >        bne *           ;failed not equal (non zero)
                        
059b : 68                       pla
059c : c9aa                     cmp #$aa        ;successful retreived from stack?
                                trap_ne
059e : d0fe            >        bne *           ;failed not equal (non zero)
                        
05a0 : 68                       pla
05a1 : c955                     cmp #$55
                                trap_ne
05a3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
05a5 : cdff01                   cmp $1ff        ;remains on stack?
                                trap_ne
05a8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
05aa : ba                       tsx
05ab : e0ff                     cpx #$ff        ;sp incremented?
                                trap_ne
05ad : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
05af : ad0002          >            lda test_case   ;previous test
05b2 : c903            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
05b4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0004 =                 >test_num = test_num + 1
05b6 : a904            >            lda #test_num   ;*** next tests' number
05b8 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ;testing branch decisions BPL BMI BVC BVS BCC BCS BNE BEQ
                                set_stat $ff    ;all on
                       >            load_flag $ff    
05bb : a9ff            >            lda #$ff                 ;allow test to change I-flag (no mask)
                       >
05bd : 48              >            pha         ;use stack to load status
05be : 28              >            plp
                        
05bf : 101a                     bpl nbr1        ;branches should not be taken
05c1 : 501b                     bvc nbr2
05c3 : 901c                     bcc nbr3
05c5 : d01d                     bne nbr4
05c7 : 3003                     bmi br1         ;branches should be taken
                                trap 
05c9 : 4cc905          >        jmp *           ;failed anyway
                        
05cc : 7003             br1     bvs br2
                                trap 
05ce : 4cce05          >        jmp *           ;failed anyway
                        
05d1 : b003             br2     bcs br3
                                trap 
05d3 : 4cd305          >        jmp *           ;failed anyway
                        
05d6 : f00f             br3     beq br4
                                trap 
05d8 : 4cd805          >        jmp *           ;failed anyway
                        
05db :                  nbr1
                                trap            ;previous bpl taken 
05db : 4cdb05          >        jmp *           ;failed anyway
                        
05de :                  nbr2
                                trap            ;previous bvc taken
05de : 4cde05          >        jmp *           ;failed anyway
                        
05e1 :                  nbr3
                                trap            ;previous bcc taken
05e1 : 4ce105          >        jmp *           ;failed anyway
                        
05e4 :                  nbr4
                                trap            ;previous bne taken
05e4 : 4ce405          >        jmp *           ;failed anyway
                        
05e7 : 08               br4     php
05e8 : ba                       tsx
05e9 : e0fe                     cpx #$fe        ;sp after php?
                                trap_ne
05eb : d0fe            >        bne *           ;failed not equal (non zero)
                        
05ed : 68                       pla
                                cmp_flag $ff    ;returned all flags on?
05ee : c9ff            >            cmp #($ff    |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
05f0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
05f2 : ba                       tsx
05f3 : e0ff                     cpx #$ff        ;sp after php?
                                trap_ne
05f5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0      ;all off
                       >            load_flag 0      
05f7 : a900            >            lda #0                   ;allow test to change I-flag (no mask)
                       >
05f9 : 48              >            pha         ;use stack to load status
05fa : 28              >            plp
                        
05fb : 301a                     bmi nbr11       ;branches should not be taken
05fd : 701b                     bvs nbr12
05ff : b01c                     bcs nbr13
0601 : f01d                     beq nbr14
0603 : 1003                     bpl br11        ;branches should be taken
                                trap 
0605 : 4c0506          >        jmp *           ;failed anyway
                        
0608 : 5003             br11    bvc br12
                                trap 
060a : 4c0a06          >        jmp *           ;failed anyway
                        
060d : 9003             br12    bcc br13
                                trap 
060f : 4c0f06          >        jmp *           ;failed anyway
                        
0612 : d00f             br13    bne br14
                                trap 
0614 : 4c1406          >        jmp *           ;failed anyway
                        
0617 :                  nbr11
                                trap            ;previous bmi taken 
0617 : 4c1706          >        jmp *           ;failed anyway
                        
061a :                  nbr12
                                trap            ;previous bvs taken 
061a : 4c1a06          >        jmp *           ;failed anyway
                        
061d :                  nbr13
                                trap            ;previous bcs taken 
061d : 4c1d06          >        jmp *           ;failed anyway
                        
0620 :                  nbr14
                                trap            ;previous beq taken 
0620 : 4c2006          >        jmp *           ;failed anyway
                        
0623 : 08               br14    php
0624 : 68                       pla
                                cmp_flag 0      ;flags off except break (pushed by sw) + reserved?
0625 : c930            >            cmp #(0      |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0627 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                ;crosscheck flags
                                set_stat zero
                       >            load_flag zero
0629 : a902            >            lda #zero             ;allow test to change I-flag (no mask)
                       >
062b : 48              >            pha         ;use stack to load status
062c : 28              >            plp
                        
062d : d002                     bne brzs1
062f : f003                     beq brzs2
0631 :                  brzs1
                                trap            ;branch zero/non zero
0631 : 4c3106          >        jmp *           ;failed anyway
                        
0634 : b002             brzs2   bcs brzs3
0636 : 9003                     bcc brzs4
0638 :                  brzs3
                                trap            ;branch carry/no carry
0638 : 4c3806          >        jmp *           ;failed anyway
                        
063b : 3002             brzs4   bmi brzs5
063d : 1003                     bpl brzs6
063f :                  brzs5
                                trap            ;branch minus/plus
063f : 4c3f06          >        jmp *           ;failed anyway
                        
0642 : 7002             brzs6   bvs brzs7
0644 : 5003                     bvc brzs8
0646 :                  brzs7
                                trap            ;branch overflow/no overflow
0646 : 4c4606          >        jmp *           ;failed anyway
                        
0649 :                  brzs8
                                set_stat carry
                       >            load_flag carry
0649 : a901            >            lda #carry             ;allow test to change I-flag (no mask)
                       >
064b : 48              >            pha         ;use stack to load status
064c : 28              >            plp
                        
064d : f002                     beq brcs1
064f : d003                     bne brcs2
0651 :                  brcs1
                                trap            ;branch zero/non zero
0651 : 4c5106          >        jmp *           ;failed anyway
                        
0654 : 9002             brcs2   bcc brcs3
0656 : b003                     bcs brcs4
0658 :                  brcs3
                                trap            ;branch carry/no carry
0658 : 4c5806          >        jmp *           ;failed anyway
                        
065b : 3002             brcs4   bmi brcs5
065d : 1003                     bpl brcs6
065f :                  brcs5
                                trap            ;branch minus/plus
065f : 4c5f06          >        jmp *           ;failed anyway
                        
0662 : 7002             brcs6   bvs brcs7
0664 : 5003                     bvc brcs8
0666 :                  brcs7
                                trap            ;branch overflow/no overflow
0666 : 4c6606          >        jmp *           ;failed anyway
                        
                        
0669 :                  brcs8
                                set_stat minus
                       >            load_flag minus
0669 : a980            >            lda #minus             ;allow test to change I-flag (no mask)
                       >
066b : 48              >            pha         ;use stack to load status
066c : 28              >            plp
                        
066d : f002                     beq brmi1
066f : d003                     bne brmi2
0671 :                  brmi1
                                trap            ;branch zero/non zero
0671 : 4c7106          >        jmp *           ;failed anyway
                        
0674 : b002             brmi2   bcs brmi3
0676 : 9003                     bcc brmi4
0678 :                  brmi3
                                trap            ;branch carry/no carry
0678 : 4c7806          >        jmp *           ;failed anyway
                        
067b : 1002             brmi4   bpl brmi5
067d : 3003                     bmi brmi6
067f :                  brmi5
                                trap            ;branch minus/plus
067f : 4c7f06          >        jmp *           ;failed anyway
                        
0682 : 7002             brmi6   bvs brmi7
0684 : 5003                     bvc brmi8
0686 :                  brmi7
                                trap            ;branch overflow/no overflow
0686 : 4c8606          >        jmp *           ;failed anyway
                        
0689 :                  brmi8
                                set_stat overfl
                       >            load_flag overfl
0689 : a940            >            lda #overfl             ;allow test to change I-flag (no mask)
                       >
068b : 48              >            pha         ;use stack to load status
068c : 28              >            plp
                        
068d : f002                     beq brvs1
068f : d003                     bne brvs2
0691 :                  brvs1
                                trap            ;branch zero/non zero
0691 : 4c9106          >        jmp *           ;failed anyway
                        
0694 : b002             brvs2   bcs brvs3
0696 : 9003                     bcc brvs4
0698 :                  brvs3
                                trap            ;branch carry/no carry
0698 : 4c9806          >        jmp *           ;failed anyway
                        
069b : 3002             brvs4   bmi brvs5
069d : 1003                     bpl brvs6
069f :                  brvs5
                                trap            ;branch minus/plus
069f : 4c9f06          >        jmp *           ;failed anyway
                        
06a2 : 5002             brvs6   bvc brvs7
06a4 : 7003                     bvs brvs8
06a6 :                  brvs7
                                trap            ;branch overflow/no overflow
06a6 : 4ca606          >        jmp *           ;failed anyway
                        
06a9 :                  brvs8
                                set_stat $ff-zero
                       >            load_flag $ff-zero
06a9 : a9fd            >            lda #$ff-zero             ;allow test to change I-flag (no mask)
                       >
06ab : 48              >            pha         ;use stack to load status
06ac : 28              >            plp
                        
06ad : f002                     beq brzc1
06af : d003                     bne brzc2
06b1 :                  brzc1
                                trap            ;branch zero/non zero
06b1 : 4cb106          >        jmp *           ;failed anyway
                        
06b4 : 9002             brzc2   bcc brzc3
06b6 : b003                     bcs brzc4
06b8 :                  brzc3
                                trap            ;branch carry/no carry
06b8 : 4cb806          >        jmp *           ;failed anyway
                        
06bb : 1002             brzc4   bpl brzc5
06bd : 3003                     bmi brzc6
06bf :                  brzc5
                                trap            ;branch minus/plus
06bf : 4cbf06          >        jmp *           ;failed anyway
                        
06c2 : 5002             brzc6   bvc brzc7
06c4 : 7003                     bvs brzc8
06c6 :                  brzc7
                                trap            ;branch overflow/no overflow
06c6 : 4cc606          >        jmp *           ;failed anyway
                        
06c9 :                  brzc8
                                set_stat $ff-carry
                       >            load_flag $ff-carry
06c9 : a9fe            >            lda #$ff-carry             ;allow test to change I-flag (no mask)
                       >
06cb : 48              >            pha         ;use stack to load status
06cc : 28              >            plp
                        
06cd : d002                     bne brcc1
06cf : f003                     beq brcc2
06d1 :                  brcc1
                                trap            ;branch zero/non zero
06d1 : 4cd106          >        jmp *           ;failed anyway
                        
06d4 : b002             brcc2   bcs brcc3
06d6 : 9003                     bcc brcc4
06d8 :                  brcc3
                                trap            ;branch carry/no carry
06d8 : 4cd806          >        jmp *           ;failed anyway
                        
06db : 1002             brcc4   bpl brcc5
06dd : 3003                     bmi brcc6
06df :                  brcc5
                                trap            ;branch minus/plus
06df : 4cdf06          >        jmp *           ;failed anyway
                        
06e2 : 5002             brcc6   bvc brcc7
06e4 : 7003                     bvs brcc8
06e6 :                  brcc7
                                trap            ;branch overflow/no overflow
06e6 : 4ce606          >        jmp *           ;failed anyway
                        
06e9 :                  brcc8
                                set_stat $ff-minus
                       >            load_flag $ff-minus
06e9 : a97f            >            lda #$ff-minus             ;allow test to change I-flag (no mask)
                       >
06eb : 48              >            pha         ;use stack to load status
06ec : 28              >            plp
                        
06ed : d002                     bne brpl1
06ef : f003                     beq brpl2
06f1 :                  brpl1
                                trap            ;branch zero/non zero
06f1 : 4cf106          >        jmp *           ;failed anyway
                        
06f4 : 9002             brpl2   bcc brpl3
06f6 : b003                     bcs brpl4
06f8 :                  brpl3
                                trap            ;branch carry/no carry
06f8 : 4cf806          >        jmp *           ;failed anyway
                        
06fb : 3002             brpl4   bmi brpl5
06fd : 1003                     bpl brpl6
06ff :                  brpl5
                                trap            ;branch minus/plus
06ff : 4cff06          >        jmp *           ;failed anyway
                        
0702 : 5002             brpl6   bvc brpl7
0704 : 7003                     bvs brpl8
0706 :                  brpl7
                                trap            ;branch overflow/no overflow
0706 : 4c0607          >        jmp *           ;failed anyway
                        
0709 :                  brpl8
                                set_stat $ff-overfl
                       >            load_flag $ff-overfl
0709 : a9bf            >            lda #$ff-overfl             ;allow test to change I-flag (no mask)
                       >
070b : 48              >            pha         ;use stack to load status
070c : 28              >            plp
                        
070d : d002                     bne brvc1
070f : f003                     beq brvc2
0711 :                  brvc1
                                trap            ;branch zero/non zero
0711 : 4c1107          >        jmp *           ;failed anyway
                        
0714 : 9002             brvc2   bcc brvc3
0716 : b003                     bcs brvc4
0718 :                  brvc3
                                trap            ;branch carry/no carry
0718 : 4c1807          >        jmp *           ;failed anyway
                        
071b : 1002             brvc4   bpl brvc5
071d : 3003                     bmi brvc6
071f :                  brvc5
                                trap            ;branch minus/plus
071f : 4c1f07          >        jmp *           ;failed anyway
                        
0722 : 7002             brvc6   bvs brvc7
0724 : 5003                     bvc brvc8
0726 :                  brvc7
                                trap            ;branch overflow/no overflow
0726 : 4c2607          >        jmp *           ;failed anyway
                        
0729 :                  brvc8
                                next_test
0729 : ad0002          >            lda test_case   ;previous test
072c : c904            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
072e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0005 =                 >test_num = test_num + 1
0730 : a905            >            lda #test_num   ;*** next tests' number
0732 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; test PHA does not alter flags or accumulator but PLA does
0735 : a255                     ldx #$55        ;x & y protected
0737 : a0aa                     ldy #$aa
                                set_a 1,$ff     ;push
                       >            load_flag $ff     
0739 : a9ff            >            lda #$ff                  ;allow test to change I-flag (no mask)
                       >
073b : 48              >            pha         ;use stack to load status
073c : a901            >            lda #1     ;precharge accu
073e : 28              >            plp
                        
073f : 48                       pha
                                tst_a 1,$ff
0740 : 08              >            php         ;save flags
0741 : c901            >            cmp #1     ;test result
                       >            trap_ne
0743 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0745 : 68              >            pla         ;load status
0746 : 48              >            pha
                       >            cmp_flag $ff
0747 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0749 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
074b : 28              >            plp         ;restore status
                        
                                set_a 0,0
                       >            load_flag 0
074c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
074e : 48              >            pha         ;use stack to load status
074f : a900            >            lda #0     ;precharge accu
0751 : 28              >            plp
                        
0752 : 48                       pha
                                tst_a 0,0
0753 : 08              >            php         ;save flags
0754 : c900            >            cmp #0     ;test result
                       >            trap_ne
0756 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0758 : 68              >            pla         ;load status
0759 : 48              >            pha
                       >            cmp_flag 0
075a : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
075c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
075e : 28              >            plp         ;restore status
                        
                                set_a $ff,$ff
                       >            load_flag $ff
075f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0761 : 48              >            pha         ;use stack to load status
0762 : a9ff            >            lda #$ff     ;precharge accu
0764 : 28              >            plp
                        
0765 : 48                       pha
                                tst_a $ff,$ff
0766 : 08              >            php         ;save flags
0767 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0769 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
076b : 68              >            pla         ;load status
076c : 48              >            pha
                       >            cmp_flag $ff
076d : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
076f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0771 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
0772 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0774 : 48              >            pha         ;use stack to load status
0775 : a901            >            lda #1     ;precharge accu
0777 : 28              >            plp
                        
0778 : 48                       pha
                                tst_a 1,0
0779 : 08              >            php         ;save flags
077a : c901            >            cmp #1     ;test result
                       >            trap_ne
077c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
077e : 68              >            pla         ;load status
077f : 48              >            pha
                       >            cmp_flag 0
0780 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0782 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0784 : 28              >            plp         ;restore status
                        
                                set_a 0,$ff
                       >            load_flag $ff
0785 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0787 : 48              >            pha         ;use stack to load status
0788 : a900            >            lda #0     ;precharge accu
078a : 28              >            plp
                        
078b : 48                       pha
                                tst_a 0,$ff
078c : 08              >            php         ;save flags
078d : c900            >            cmp #0     ;test result
                       >            trap_ne
078f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0791 : 68              >            pla         ;load status
0792 : 48              >            pha
                       >            cmp_flag $ff
0793 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0795 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0797 : 28              >            plp         ;restore status
                        
                                set_a $ff,0
                       >            load_flag 0
0798 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
079a : 48              >            pha         ;use stack to load status
079b : a9ff            >            lda #$ff     ;precharge accu
079d : 28              >            plp
                        
079e : 48                       pha
                                tst_a $ff,0
079f : 08              >            php         ;save flags
07a0 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
07a2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07a4 : 68              >            pla         ;load status
07a5 : 48              >            pha
                       >            cmp_flag 0
07a6 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
07a8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07aa : 28              >            plp         ;restore status
                        
                                set_a 0,$ff     ;pull
                       >            load_flag $ff     
07ab : a9ff            >            lda #$ff                  ;allow test to change I-flag (no mask)
                       >
07ad : 48              >            pha         ;use stack to load status
07ae : a900            >            lda #0     ;precharge accu
07b0 : 28              >            plp
                        
07b1 : 68                       pla
                                tst_a $ff,$ff-zero
07b2 : 08              >            php         ;save flags
07b3 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
07b5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07b7 : 68              >            pla         ;load status
07b8 : 48              >            pha
                       >            cmp_flag $ff-zero
07b9 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
07bb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07bd : 28              >            plp         ;restore status
                        
                                set_a $ff,0
                       >            load_flag 0
07be : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
07c0 : 48              >            pha         ;use stack to load status
07c1 : a9ff            >            lda #$ff     ;precharge accu
07c3 : 28              >            plp
                        
07c4 : 68                       pla
                                tst_a 0,zero
07c5 : 08              >            php         ;save flags
07c6 : c900            >            cmp #0     ;test result
                       >            trap_ne
07c8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07ca : 68              >            pla         ;load status
07cb : 48              >            pha
                       >            cmp_flag zero
07cc : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
07ce : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07d0 : 28              >            plp         ;restore status
                        
                                set_a $fe,$ff
                       >            load_flag $ff
07d1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
07d3 : 48              >            pha         ;use stack to load status
07d4 : a9fe            >            lda #$fe     ;precharge accu
07d6 : 28              >            plp
                        
07d7 : 68                       pla
                                tst_a 1,$ff-zero-minus
07d8 : 08              >            php         ;save flags
07d9 : c901            >            cmp #1     ;test result
                       >            trap_ne
07db : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07dd : 68              >            pla         ;load status
07de : 48              >            pha
                       >            cmp_flag $ff-zero-minus
07df : c97d            >            cmp #($ff-zero-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
07e1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07e3 : 28              >            plp         ;restore status
                        
                                set_a 0,0
                       >            load_flag 0
07e4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
07e6 : 48              >            pha         ;use stack to load status
07e7 : a900            >            lda #0     ;precharge accu
07e9 : 28              >            plp
                        
07ea : 68                       pla
                                tst_a $ff,minus
07eb : 08              >            php         ;save flags
07ec : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
07ee : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07f0 : 68              >            pla         ;load status
07f1 : 48              >            pha
                       >            cmp_flag minus
07f2 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
07f4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07f6 : 28              >            plp         ;restore status
                        
                                set_a $ff,$ff
                       >            load_flag $ff
07f7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
07f9 : 48              >            pha         ;use stack to load status
07fa : a9ff            >            lda #$ff     ;precharge accu
07fc : 28              >            plp
                        
07fd : 68                       pla
                                tst_a 0,$ff-minus
07fe : 08              >            php         ;save flags
07ff : c900            >            cmp #0     ;test result
                       >            trap_ne
0801 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0803 : 68              >            pla         ;load status
0804 : 48              >            pha
                       >            cmp_flag $ff-minus
0805 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0807 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0809 : 28              >            plp         ;restore status
                        
                                set_a $fe,0
                       >            load_flag 0
080a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
080c : 48              >            pha         ;use stack to load status
080d : a9fe            >            lda #$fe     ;precharge accu
080f : 28              >            plp
                        
0810 : 68                       pla
                                tst_a 1,0
0811 : 08              >            php         ;save flags
0812 : c901            >            cmp #1     ;test result
                       >            trap_ne
0814 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0816 : 68              >            pla         ;load status
0817 : 48              >            pha
                       >            cmp_flag 0
0818 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
081a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
081c : 28              >            plp         ;restore status
                        
081d : e055                     cpx #$55        ;x & y unchanged?
                                trap_ne
081f : d0fe            >        bne *           ;failed not equal (non zero)
                        
0821 : c0aa                     cpy #$aa
                                trap_ne
0823 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
0825 : ad0002          >            lda test_case   ;previous test
0828 : c905            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
082a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0006 =                 >test_num = test_num + 1
082c : a906            >            lda #test_num   ;*** next tests' number
082e : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                         
                        ; partial pretest EOR #
                                set_a $3c,0
                       >            load_flag 0
0831 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0833 : 48              >            pha         ;use stack to load status
0834 : a93c            >            lda #$3c     ;precharge accu
0836 : 28              >            plp
                        
0837 : 49c3                     eor #$c3
                                tst_a $ff,fn
0839 : 08              >            php         ;save flags
083a : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
083c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
083e : 68              >            pla         ;load status
083f : 48              >            pha
                       >            cmp_flag fn
0840 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0842 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0844 : 28              >            plp         ;restore status
                        
                                set_a $c3,0
                       >            load_flag 0
0845 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0847 : 48              >            pha         ;use stack to load status
0848 : a9c3            >            lda #$c3     ;precharge accu
084a : 28              >            plp
                        
084b : 49c3                     eor #$c3
                                tst_a 0,fz
084d : 08              >            php         ;save flags
084e : c900            >            cmp #0     ;test result
                       >            trap_ne
0850 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0852 : 68              >            pla         ;load status
0853 : 48              >            pha
                       >            cmp_flag fz
0854 : c932            >            cmp #(fz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0856 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0858 : 28              >            plp         ;restore status
                        
                                next_test
0859 : ad0002          >            lda test_case   ;previous test
085c : c906            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
085e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0007 =                 >test_num = test_num + 1
0860 : a907            >            lda #test_num   ;*** next tests' number
0862 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; PC modifying instructions except branches (NOP, JMP, JSR, RTS, BRK, RTI)
                        ; testing NOP
0865 : a224                     ldx #$24
0867 : a042                     ldy #$42
                                set_a $18,0
                       >            load_flag 0
0869 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
086b : 48              >            pha         ;use stack to load status
086c : a918            >            lda #$18     ;precharge accu
086e : 28              >            plp
                        
086f : ea                       nop
                                tst_a $18,0
0870 : 08              >            php         ;save flags
0871 : c918            >            cmp #$18     ;test result
                       >            trap_ne
0873 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0875 : 68              >            pla         ;load status
0876 : 48              >            pha
                       >            cmp_flag 0
0877 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0879 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
087b : 28              >            plp         ;restore status
                        
087c : e024                     cpx #$24
                                trap_ne
087e : d0fe            >        bne *           ;failed not equal (non zero)
                        
0880 : c042                     cpy #$42
                                trap_ne
0882 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0884 : a2db                     ldx #$db
0886 : a0bd                     ldy #$bd
                                set_a $e7,$ff
                       >            load_flag $ff
0888 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
088a : 48              >            pha         ;use stack to load status
088b : a9e7            >            lda #$e7     ;precharge accu
088d : 28              >            plp
                        
088e : ea                       nop
                                tst_a $e7,$ff
088f : 08              >            php         ;save flags
0890 : c9e7            >            cmp #$e7     ;test result
                       >            trap_ne
0892 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0894 : 68              >            pla         ;load status
0895 : 48              >            pha
                       >            cmp_flag $ff
0896 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0898 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
089a : 28              >            plp         ;restore status
                        
089b : e0db                     cpx #$db
                                trap_ne
089d : d0fe            >        bne *           ;failed not equal (non zero)
                        
089f : c0bd                     cpy #$bd
                                trap_ne
08a1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
08a3 : ad0002          >            lda test_case   ;previous test
08a6 : c907            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
08a8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0008 =                 >test_num = test_num + 1
08aa : a908            >            lda #test_num   ;*** next tests' number
08ac : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; jump absolute
                                set_stat $0
                       >            load_flag $0
08af : a900            >            lda #$0             ;allow test to change I-flag (no mask)
                       >
08b1 : 48              >            pha         ;use stack to load status
08b2 : 28              >            plp
                        
08b3 : a946                     lda #'F'
08b5 : a241                     ldx #'A'
08b7 : a052                     ldy #'R'        ;N=0, V=0, Z=0, C=0
08b9 : 4c1b36                   jmp test_far
08bc : ea                       nop
08bd : ea                       nop
                                trap_ne         ;runover protection
08be : d0fe            >        bne *           ;failed not equal (non zero)
                        
08c0 : e8                       inx
08c1 : e8                       inx
08c2 :                  far_ret 
                                trap_eq         ;returned flags OK?
08c2 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
08c4 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                trap_cc
08c6 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
08c8 : 50fe            >        bvc *           ;failed overflow clear
                        
08ca : c9ec                     cmp #('F'^$aa)  ;returned registers OK?
                                trap_ne
08cc : d0fe            >        bne *           ;failed not equal (non zero)
                        
08ce : e042                     cpx #('A'+1)
                                trap_ne
08d0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
08d2 : c04f                     cpy #('R'-3)
                                trap_ne
08d4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
08d6 : ca                       dex
08d7 : c8                       iny
08d8 : c8                       iny
08d9 : c8                       iny
08da : 49aa                     eor #$aa        ;N=0, V=1, Z=0, C=1
08dc : 4ce508                   jmp test_near
08df : ea                       nop
08e0 : ea                       nop
                                trap_ne         ;runover protection
08e1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
08e3 : e8                       inx
08e4 : e8                       inx
08e5 :                  test_near
                                trap_eq         ;passed flags OK?
08e5 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_mi
08e7 : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_cc
08e9 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
08eb : 50fe            >        bvc *           ;failed overflow clear
                        
08ed : c946                     cmp #'F'        ;passed registers OK?
                                trap_ne
08ef : d0fe            >        bne *           ;failed not equal (non zero)
                        
08f1 : e041                     cpx #'A'
                                trap_ne
08f3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
08f5 : c052                     cpy #'R'
                                trap_ne
08f7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
08f9 : ad0002          >            lda test_case   ;previous test
08fc : c908            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
08fe : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0009 =                 >test_num = test_num + 1
0900 : a909            >            lda #test_num   ;*** next tests' number
0902 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; jump indirect
                                set_stat 0
                       >            load_flag 0
0905 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0907 : 48              >            pha         ;use stack to load status
0908 : 28              >            plp
                        
0909 : a949                     lda #'I'
090b : a24e                     ldx #'N'
090d : a044                     ldy #'D'        ;N=0, V=0, Z=0, C=0
090f : 6c4a36                   jmp (ptr_tst_ind)
0912 : ea                       nop
                                trap_ne         ;runover protection
0913 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0915 : 88                       dey
0916 : 88                       dey
0917 :                  ind_ret 
0917 : 08                       php             ;either SP or Y count will fail, if we do not hit
0918 : 88                       dey
0919 : 88                       dey
091a : 88                       dey
091b : 28                       plp
                                trap_eq         ;returned flags OK?
091c : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
091e : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                trap_cc
0920 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
0922 : 50fe            >        bvc *           ;failed overflow clear
                        
0924 : c9e3                     cmp #('I'^$aa)  ;returned registers OK?
                                trap_ne
0926 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0928 : e04f                     cpx #('N'+1)
                                trap_ne
092a : d0fe            >        bne *           ;failed not equal (non zero)
                        
092c : c03e                     cpy #('D'-6)
                                trap_ne
092e : d0fe            >        bne *           ;failed not equal (non zero)
                        
0930 : ba                       tsx             ;SP check
0931 : e0ff                     cpx #$ff
                                trap_ne
0933 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
0935 : ad0002          >            lda test_case   ;previous test
0938 : c909            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
093a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000a =                 >test_num = test_num + 1
093c : a90a            >            lda #test_num   ;*** next tests' number
093e : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; jump subroutine & return from subroutine
                                set_stat 0
                       >            load_flag 0
0941 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0943 : 48              >            pha         ;use stack to load status
0944 : 28              >            plp
                        
0945 : a94a                     lda #'J'
0947 : a253                     ldx #'S'
0949 : a052                     ldy #'R'        ;N=0, V=0, Z=0, C=0
094b : 208636                   jsr test_jsr
094d =                  jsr_ret = *-1           ;last address of jsr = return address
094e : 08                       php             ;either SP or Y count will fail, if we do not hit
094f : 88                       dey
0950 : 88                       dey
0951 : 88                       dey
0952 : 28                       plp
                                trap_eq         ;returned flags OK?
0953 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
0955 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                trap_cc
0957 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
0959 : 50fe            >        bvc *           ;failed overflow clear
                        
095b : c9e0                     cmp #('J'^$aa)  ;returned registers OK?
                                trap_ne
095d : d0fe            >        bne *           ;failed not equal (non zero)
                        
095f : e054                     cpx #('S'+1)
                                trap_ne
0961 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0963 : c04c                     cpy #('R'-6)
                                trap_ne
0965 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0967 : ba                       tsx             ;sp?
0968 : e0ff                     cpx #$ff
                                trap_ne
096a : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
096c : ad0002          >            lda test_case   ;previous test
096f : c90a            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0971 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000b =                 >test_num = test_num + 1
0973 : a90b            >            lda #test_num   ;*** next tests' number
0975 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; break & return from interrupt
                            if ROM_vectors = 1
                                set_stat 0
                       >            load_flag 0
0978 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
097a : 48              >            pha         ;use stack to load status
097b : 28              >            plp
                        
097c : a942                     lda #'B'
097e : a252                     ldx #'R'
0980 : a04b                     ldy #'K'        ;N=0, V=0, Z=0, C=0
0982 : 00                       brk
                            else
                                lda #hi brk_ret ;emulated break
                                pha
                                lda #lo brk_ret
                                pha
                                lda #fao        ;set break & unused on stack
                                pha
                                set_stat intdis
                                lda #'B'
                                ldx #'R'
                                ldy #'K'        ;N=0, V=0, Z=0, C=0
                                jmp irq_trap
                            endif
0983 : 88                       dey             ;should not be executed
0984 :                  brk_ret                 ;address of break return
0984 : 08                       php             ;either SP or Y count will fail, if we do not hit
0985 : 88                       dey
0986 : 88                       dey
0987 : 88                       dey
0988 : c9e8                     cmp #('B'^$aa)  ;returned registers OK?
                                trap_ne
098a : d0fe            >        bne *           ;failed not equal (non zero)
                        
098c : e053                     cpx #('R'+1)
                                trap_ne
098e : d0fe            >        bne *           ;failed not equal (non zero)
                        
0990 : c045                     cpy #('K'-6)
                                trap_ne
0992 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0994 : 68                       pla             ;returned flags OK (unchanged)?
                                cmp_flag 0
0995 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0997 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0999 : ba                       tsx             ;sp?
099a : e0ff                     cpx #$ff
                                trap_ne
099c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
099e : ad0002          >            lda test_case   ;previous test
09a1 : c90b            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
09a3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000c =                 >test_num = test_num + 1
09a5 : a90c            >            lda #test_num   ;*** next tests' number
09a7 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                         
                        ; test set and clear flags CLC CLI CLD CLV SEC SEI SED
                                set_stat $ff
                       >            load_flag $ff
09aa : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
09ac : 48              >            pha         ;use stack to load status
09ad : 28              >            plp
                        
09ae : 18                       clc
                                tst_stat $ff-carry
09af : 08              >            php         ;save status
09b0 : 68              >            pla         ;use stack to retrieve status
09b1 : 48              >            pha
                       >            cmp_flag $ff-carry
09b2 : c9fe            >            cmp #($ff-carry|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
09b4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
09b6 : 28              >            plp         ;restore status
                        
09b7 : 38                       sec
                                tst_stat $ff
09b8 : 08              >            php         ;save status
09b9 : 68              >            pla         ;use stack to retrieve status
09ba : 48              >            pha
                       >            cmp_flag $ff
09bb : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
09bd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
09bf : 28              >            plp         ;restore status
                        
                            if I_flag = 3
09c0 : 58                       cli
                                tst_stat $ff-intdis
09c1 : 08              >            php         ;save status
09c2 : 68              >            pla         ;use stack to retrieve status
09c3 : 48              >            pha
                       >            cmp_flag $ff-intdis
09c4 : c9fb            >            cmp #($ff-intdis|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
09c6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
09c8 : 28              >            plp         ;restore status
                        
09c9 : 78                       sei
                                tst_stat $ff
09ca : 08              >            php         ;save status
09cb : 68              >            pla         ;use stack to retrieve status
09cc : 48              >            pha
                       >            cmp_flag $ff
09cd : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
09cf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
09d1 : 28              >            plp         ;restore status
                        
                            endif
09d2 : d8                       cld
                                tst_stat $ff-decmode
09d3 : 08              >            php         ;save status
09d4 : 68              >            pla         ;use stack to retrieve status
09d5 : 48              >            pha
                       >            cmp_flag $ff-decmode
09d6 : c9f7            >            cmp #($ff-decmode|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
09d8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
09da : 28              >            plp         ;restore status
                        
09db : f8                       sed
                                tst_stat $ff
09dc : 08              >            php         ;save status
09dd : 68              >            pla         ;use stack to retrieve status
09de : 48              >            pha
                       >            cmp_flag $ff
09df : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
09e1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
09e3 : 28              >            plp         ;restore status
                        
09e4 : b8                       clv
                                tst_stat $ff-overfl
09e5 : 08              >            php         ;save status
09e6 : 68              >            pla         ;use stack to retrieve status
09e7 : 48              >            pha
                       >            cmp_flag $ff-overfl
09e8 : c9bf            >            cmp #($ff-overfl|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
09ea : d0fe            >        bne *           ;failed not equal (non zero)
                       >
09ec : 28              >            plp         ;restore status
                        
                                set_stat 0
                       >            load_flag 0
09ed : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
09ef : 48              >            pha         ;use stack to load status
09f0 : 28              >            plp
                        
                                tst_stat 0
09f1 : 08              >            php         ;save status
09f2 : 68              >            pla         ;use stack to retrieve status
09f3 : 48              >            pha
                       >            cmp_flag 0
09f4 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
09f6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
09f8 : 28              >            plp         ;restore status
                        
09f9 : 38                       sec
                                tst_stat carry
09fa : 08              >            php         ;save status
09fb : 68              >            pla         ;use stack to retrieve status
09fc : 48              >            pha
                       >            cmp_flag carry
09fd : c931            >            cmp #(carry|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
09ff : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a01 : 28              >            plp         ;restore status
                        
0a02 : 18                       clc
                                tst_stat 0  
0a03 : 08              >            php         ;save status
0a04 : 68              >            pla         ;use stack to retrieve status
0a05 : 48              >            pha
                       >            cmp_flag 0  
0a06 : c930            >            cmp #(0  |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a08 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a0a : 28              >            plp         ;restore status
                        
                            if I_flag = 3
0a0b : 78                       sei
                                tst_stat intdis
0a0c : 08              >            php         ;save status
0a0d : 68              >            pla         ;use stack to retrieve status
0a0e : 48              >            pha
                       >            cmp_flag intdis
0a0f : c934            >            cmp #(intdis|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a11 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a13 : 28              >            plp         ;restore status
                        
0a14 : 58                       cli
                                tst_stat 0
0a15 : 08              >            php         ;save status
0a16 : 68              >            pla         ;use stack to retrieve status
0a17 : 48              >            pha
                       >            cmp_flag 0
0a18 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a1a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a1c : 28              >            plp         ;restore status
                        
                            endif  
0a1d : f8                       sed
                                tst_stat decmode
0a1e : 08              >            php         ;save status
0a1f : 68              >            pla         ;use stack to retrieve status
0a20 : 48              >            pha
                       >            cmp_flag decmode
0a21 : c938            >            cmp #(decmode|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a23 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a25 : 28              >            plp         ;restore status
                        
0a26 : d8                       cld
                                tst_stat 0  
0a27 : 08              >            php         ;save status
0a28 : 68              >            pla         ;use stack to retrieve status
0a29 : 48              >            pha
                       >            cmp_flag 0  
0a2a : c930            >            cmp #(0  |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a2c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a2e : 28              >            plp         ;restore status
                        
                                set_stat overfl
                       >            load_flag overfl
0a2f : a940            >            lda #overfl             ;allow test to change I-flag (no mask)
                       >
0a31 : 48              >            pha         ;use stack to load status
0a32 : 28              >            plp
                        
                                tst_stat overfl
0a33 : 08              >            php         ;save status
0a34 : 68              >            pla         ;use stack to retrieve status
0a35 : 48              >            pha
                       >            cmp_flag overfl
0a36 : c970            >            cmp #(overfl|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a38 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a3a : 28              >            plp         ;restore status
                        
0a3b : b8                       clv
                                tst_stat 0
0a3c : 08              >            php         ;save status
0a3d : 68              >            pla         ;use stack to retrieve status
0a3e : 48              >            pha
                       >            cmp_flag 0
0a3f : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a41 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a43 : 28              >            plp         ;restore status
                        
                                next_test
0a44 : ad0002          >            lda test_case   ;previous test
0a47 : c90c            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0a49 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000d =                 >test_num = test_num + 1
0a4b : a90d            >            lda #test_num   ;*** next tests' number
0a4d : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        ; testing index register increment/decrement and transfer
                        ; INX INY DEX DEY TAX TXA TAY TYA 
0a50 : a2fe                     ldx #$fe
                                set_stat $ff
                       >            load_flag $ff
0a52 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0a54 : 48              >            pha         ;use stack to load status
0a55 : 28              >            plp
                        
0a56 : e8                       inx             ;ff
                                tst_x $ff,$ff-zero
0a57 : 08              >            php         ;save flags
0a58 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0a5a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a5c : 68              >            pla         ;load status
0a5d : 48              >            pha
                       >            cmp_flag $ff-zero
0a5e : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a60 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a62 : 28              >            plp         ;restore status
                        
0a63 : e8                       inx             ;00
                                tst_x 0,$ff-minus
0a64 : 08              >            php         ;save flags
0a65 : e000            >            cpx #0     ;test result
                       >            trap_ne
0a67 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a69 : 68              >            pla         ;load status
0a6a : 48              >            pha
                       >            cmp_flag $ff-minus
0a6b : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a6d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a6f : 28              >            plp         ;restore status
                        
0a70 : e8                       inx             ;01
                                tst_x 1,$ff-minus-zero
0a71 : 08              >            php         ;save flags
0a72 : e001            >            cpx #1     ;test result
                       >            trap_ne
0a74 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a76 : 68              >            pla         ;load status
0a77 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0a78 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a7a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a7c : 28              >            plp         ;restore status
                        
0a7d : ca                       dex             ;00
                                tst_x 0,$ff-minus
0a7e : 08              >            php         ;save flags
0a7f : e000            >            cpx #0     ;test result
                       >            trap_ne
0a81 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a83 : 68              >            pla         ;load status
0a84 : 48              >            pha
                       >            cmp_flag $ff-minus
0a85 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a87 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a89 : 28              >            plp         ;restore status
                        
0a8a : ca                       dex             ;ff
                                tst_x $ff,$ff-zero
0a8b : 08              >            php         ;save flags
0a8c : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0a8e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a90 : 68              >            pla         ;load status
0a91 : 48              >            pha
                       >            cmp_flag $ff-zero
0a92 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a94 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a96 : 28              >            plp         ;restore status
                        
0a97 : ca                       dex             ;fe
                                set_stat 0
                       >            load_flag 0
0a98 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0a9a : 48              >            pha         ;use stack to load status
0a9b : 28              >            plp
                        
0a9c : e8                       inx             ;ff
                                tst_x $ff,minus
0a9d : 08              >            php         ;save flags
0a9e : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0aa0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0aa2 : 68              >            pla         ;load status
0aa3 : 48              >            pha
                       >            cmp_flag minus
0aa4 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0aa6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0aa8 : 28              >            plp         ;restore status
                        
0aa9 : e8                       inx             ;00
                                tst_x 0,zero
0aaa : 08              >            php         ;save flags
0aab : e000            >            cpx #0     ;test result
                       >            trap_ne
0aad : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0aaf : 68              >            pla         ;load status
0ab0 : 48              >            pha
                       >            cmp_flag zero
0ab1 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ab3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ab5 : 28              >            plp         ;restore status
                        
0ab6 : e8                       inx             ;01
                                tst_x 1,0
0ab7 : 08              >            php         ;save flags
0ab8 : e001            >            cpx #1     ;test result
                       >            trap_ne
0aba : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0abc : 68              >            pla         ;load status
0abd : 48              >            pha
                       >            cmp_flag 0
0abe : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ac0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ac2 : 28              >            plp         ;restore status
                        
0ac3 : ca                       dex             ;00
                                tst_x 0,zero
0ac4 : 08              >            php         ;save flags
0ac5 : e000            >            cpx #0     ;test result
                       >            trap_ne
0ac7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ac9 : 68              >            pla         ;load status
0aca : 48              >            pha
                       >            cmp_flag zero
0acb : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0acd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0acf : 28              >            plp         ;restore status
                        
0ad0 : ca                       dex             ;ff
                                tst_x $ff,minus
0ad1 : 08              >            php         ;save flags
0ad2 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0ad4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ad6 : 68              >            pla         ;load status
0ad7 : 48              >            pha
                       >            cmp_flag minus
0ad8 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ada : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0adc : 28              >            plp         ;restore status
                        
                        
0add : a0fe                     ldy #$fe
                                set_stat $ff
                       >            load_flag $ff
0adf : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0ae1 : 48              >            pha         ;use stack to load status
0ae2 : 28              >            plp
                        
0ae3 : c8                       iny             ;ff
                                tst_y $ff,$ff-zero
0ae4 : 08              >            php         ;save flags
0ae5 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0ae7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ae9 : 68              >            pla         ;load status
0aea : 48              >            pha
                       >            cmp_flag $ff-zero
0aeb : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0aed : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0aef : 28              >            plp         ;restore status
                        
0af0 : c8                       iny             ;00
                                tst_y 0,$ff-minus
0af1 : 08              >            php         ;save flags
0af2 : c000            >            cpy #0     ;test result
                       >            trap_ne
0af4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0af6 : 68              >            pla         ;load status
0af7 : 48              >            pha
                       >            cmp_flag $ff-minus
0af8 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0afa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0afc : 28              >            plp         ;restore status
                        
0afd : c8                       iny             ;01
                                tst_y 1,$ff-minus-zero
0afe : 08              >            php         ;save flags
0aff : c001            >            cpy #1     ;test result
                       >            trap_ne
0b01 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b03 : 68              >            pla         ;load status
0b04 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0b05 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b07 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b09 : 28              >            plp         ;restore status
                        
0b0a : 88                       dey             ;00
                                tst_y 0,$ff-minus
0b0b : 08              >            php         ;save flags
0b0c : c000            >            cpy #0     ;test result
                       >            trap_ne
0b0e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b10 : 68              >            pla         ;load status
0b11 : 48              >            pha
                       >            cmp_flag $ff-minus
0b12 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b14 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b16 : 28              >            plp         ;restore status
                        
0b17 : 88                       dey             ;ff
                                tst_y $ff,$ff-zero
0b18 : 08              >            php         ;save flags
0b19 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0b1b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b1d : 68              >            pla         ;load status
0b1e : 48              >            pha
                       >            cmp_flag $ff-zero
0b1f : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b21 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b23 : 28              >            plp         ;restore status
                        
0b24 : 88                       dey             ;fe
                                set_stat 0
                       >            load_flag 0
0b25 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0b27 : 48              >            pha         ;use stack to load status
0b28 : 28              >            plp
                        
0b29 : c8                       iny             ;ff
                                tst_y $ff,0+minus
0b2a : 08              >            php         ;save flags
0b2b : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0b2d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b2f : 68              >            pla         ;load status
0b30 : 48              >            pha
                       >            cmp_flag 0+minus
0b31 : c9b0            >            cmp #(0+minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b33 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b35 : 28              >            plp         ;restore status
                        
0b36 : c8                       iny             ;00
                                tst_y 0,zero
0b37 : 08              >            php         ;save flags
0b38 : c000            >            cpy #0     ;test result
                       >            trap_ne
0b3a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b3c : 68              >            pla         ;load status
0b3d : 48              >            pha
                       >            cmp_flag zero
0b3e : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b40 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b42 : 28              >            plp         ;restore status
                        
0b43 : c8                       iny             ;01
                                tst_y 1,0
0b44 : 08              >            php         ;save flags
0b45 : c001            >            cpy #1     ;test result
                       >            trap_ne
0b47 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b49 : 68              >            pla         ;load status
0b4a : 48              >            pha
                       >            cmp_flag 0
0b4b : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b4d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b4f : 28              >            plp         ;restore status
                        
0b50 : 88                       dey             ;00
                                tst_y 0,zero
0b51 : 08              >            php         ;save flags
0b52 : c000            >            cpy #0     ;test result
                       >            trap_ne
0b54 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b56 : 68              >            pla         ;load status
0b57 : 48              >            pha
                       >            cmp_flag zero
0b58 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b5a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b5c : 28              >            plp         ;restore status
                        
0b5d : 88                       dey             ;ff
                                tst_y $ff,minus
0b5e : 08              >            php         ;save flags
0b5f : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0b61 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b63 : 68              >            pla         ;load status
0b64 : 48              >            pha
                       >            cmp_flag minus
0b65 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b67 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b69 : 28              >            plp         ;restore status
                        
                                        
0b6a : a2ff                     ldx #$ff
                                set_stat $ff
                       >            load_flag $ff
0b6c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0b6e : 48              >            pha         ;use stack to load status
0b6f : 28              >            plp
                        
0b70 : 8a                       txa
                                tst_a $ff,$ff-zero
0b71 : 08              >            php         ;save flags
0b72 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0b74 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b76 : 68              >            pla         ;load status
0b77 : 48              >            pha
                       >            cmp_flag $ff-zero
0b78 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b7a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b7c : 28              >            plp         ;restore status
                        
0b7d : 08                       php
0b7e : e8                       inx             ;00
0b7f : 28                       plp
0b80 : 8a                       txa
                                tst_a 0,$ff-minus
0b81 : 08              >            php         ;save flags
0b82 : c900            >            cmp #0     ;test result
                       >            trap_ne
0b84 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b86 : 68              >            pla         ;load status
0b87 : 48              >            pha
                       >            cmp_flag $ff-minus
0b88 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b8a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b8c : 28              >            plp         ;restore status
                        
0b8d : 08                       php
0b8e : e8                       inx             ;01
0b8f : 28                       plp
0b90 : 8a                       txa
                                tst_a 1,$ff-minus-zero
0b91 : 08              >            php         ;save flags
0b92 : c901            >            cmp #1     ;test result
                       >            trap_ne
0b94 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b96 : 68              >            pla         ;load status
0b97 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0b98 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b9a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b9c : 28              >            plp         ;restore status
                        
                                set_stat 0
                       >            load_flag 0
0b9d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0b9f : 48              >            pha         ;use stack to load status
0ba0 : 28              >            plp
                        
0ba1 : 8a                       txa
                                tst_a 1,0
0ba2 : 08              >            php         ;save flags
0ba3 : c901            >            cmp #1     ;test result
                       >            trap_ne
0ba5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ba7 : 68              >            pla         ;load status
0ba8 : 48              >            pha
                       >            cmp_flag 0
0ba9 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0bab : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bad : 28              >            plp         ;restore status
                        
0bae : 08                       php
0baf : ca                       dex             ;00
0bb0 : 28                       plp
0bb1 : 8a                       txa
                                tst_a 0,zero
0bb2 : 08              >            php         ;save flags
0bb3 : c900            >            cmp #0     ;test result
                       >            trap_ne
0bb5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bb7 : 68              >            pla         ;load status
0bb8 : 48              >            pha
                       >            cmp_flag zero
0bb9 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0bbb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bbd : 28              >            plp         ;restore status
                        
0bbe : 08                       php
0bbf : ca                       dex             ;ff
0bc0 : 28                       plp
0bc1 : 8a                       txa
                                tst_a $ff,minus
0bc2 : 08              >            php         ;save flags
0bc3 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0bc5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bc7 : 68              >            pla         ;load status
0bc8 : 48              >            pha
                       >            cmp_flag minus
0bc9 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0bcb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bcd : 28              >            plp         ;restore status
                        
                                                
0bce : a0ff                     ldy #$ff
                                set_stat $ff
                       >            load_flag $ff
0bd0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0bd2 : 48              >            pha         ;use stack to load status
0bd3 : 28              >            plp
                        
0bd4 : 98                       tya
                                tst_a $ff,$ff-zero
0bd5 : 08              >            php         ;save flags
0bd6 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0bd8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bda : 68              >            pla         ;load status
0bdb : 48              >            pha
                       >            cmp_flag $ff-zero
0bdc : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0bde : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0be0 : 28              >            plp         ;restore status
                        
0be1 : 08                       php
0be2 : c8                       iny             ;00
0be3 : 28                       plp
0be4 : 98                       tya
                                tst_a 0,$ff-minus
0be5 : 08              >            php         ;save flags
0be6 : c900            >            cmp #0     ;test result
                       >            trap_ne
0be8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bea : 68              >            pla         ;load status
0beb : 48              >            pha
                       >            cmp_flag $ff-minus
0bec : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0bee : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bf0 : 28              >            plp         ;restore status
                        
0bf1 : 08                       php
0bf2 : c8                       iny             ;01
0bf3 : 28                       plp
0bf4 : 98                       tya
                                tst_a 1,$ff-minus-zero
0bf5 : 08              >            php         ;save flags
0bf6 : c901            >            cmp #1     ;test result
                       >            trap_ne
0bf8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bfa : 68              >            pla         ;load status
0bfb : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0bfc : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0bfe : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c00 : 28              >            plp         ;restore status
                        
                                set_stat 0
                       >            load_flag 0
0c01 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0c03 : 48              >            pha         ;use stack to load status
0c04 : 28              >            plp
                        
0c05 : 98                       tya
                                tst_a 1,0
0c06 : 08              >            php         ;save flags
0c07 : c901            >            cmp #1     ;test result
                       >            trap_ne
0c09 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c0b : 68              >            pla         ;load status
0c0c : 48              >            pha
                       >            cmp_flag 0
0c0d : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c0f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c11 : 28              >            plp         ;restore status
                        
0c12 : 08                       php
0c13 : 88                       dey             ;00
0c14 : 28                       plp
0c15 : 98                       tya
                                tst_a 0,zero
0c16 : 08              >            php         ;save flags
0c17 : c900            >            cmp #0     ;test result
                       >            trap_ne
0c19 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c1b : 68              >            pla         ;load status
0c1c : 48              >            pha
                       >            cmp_flag zero
0c1d : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c1f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c21 : 28              >            plp         ;restore status
                        
0c22 : 08                       php
0c23 : 88                       dey             ;ff
0c24 : 28                       plp
0c25 : 98                       tya
                                tst_a $ff,minus
0c26 : 08              >            php         ;save flags
0c27 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0c29 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c2b : 68              >            pla         ;load status
0c2c : 48              >            pha
                       >            cmp_flag minus
0c2d : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c2f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c31 : 28              >            plp         ;restore status
                        
                        
                                load_flag $ff
0c32 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                        
0c34 : 48                       pha
0c35 : a2ff                     ldx #$ff        ;ff
0c37 : 8a                       txa
0c38 : 28                       plp             
0c39 : a8                       tay
                                tst_y $ff,$ff-zero
0c3a : 08              >            php         ;save flags
0c3b : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0c3d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c3f : 68              >            pla         ;load status
0c40 : 48              >            pha
                       >            cmp_flag $ff-zero
0c41 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c43 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c45 : 28              >            plp         ;restore status
                        
0c46 : 08                       php
0c47 : e8                       inx             ;00
0c48 : 8a                       txa
0c49 : 28                       plp
0c4a : a8                       tay
                                tst_y 0,$ff-minus
0c4b : 08              >            php         ;save flags
0c4c : c000            >            cpy #0     ;test result
                       >            trap_ne
0c4e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c50 : 68              >            pla         ;load status
0c51 : 48              >            pha
                       >            cmp_flag $ff-minus
0c52 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c54 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c56 : 28              >            plp         ;restore status
                        
0c57 : 08                       php
0c58 : e8                       inx             ;01
0c59 : 8a                       txa
0c5a : 28                       plp
0c5b : a8                       tay
                                tst_y 1,$ff-minus-zero
0c5c : 08              >            php         ;save flags
0c5d : c001            >            cpy #1     ;test result
                       >            trap_ne
0c5f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c61 : 68              >            pla         ;load status
0c62 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0c63 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c65 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c67 : 28              >            plp         ;restore status
                        
                                load_flag 0
0c68 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                        
0c6a : 48                       pha
0c6b : a900                     lda #0
0c6d : 8a                       txa
0c6e : 28                       plp
0c6f : a8                       tay
                                tst_y 1,0
0c70 : 08              >            php         ;save flags
0c71 : c001            >            cpy #1     ;test result
                       >            trap_ne
0c73 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c75 : 68              >            pla         ;load status
0c76 : 48              >            pha
                       >            cmp_flag 0
0c77 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c79 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c7b : 28              >            plp         ;restore status
                        
0c7c : 08                       php
0c7d : ca                       dex             ;00
0c7e : 8a                       txa
0c7f : 28                       plp
0c80 : a8                       tay
                                tst_y 0,zero
0c81 : 08              >            php         ;save flags
0c82 : c000            >            cpy #0     ;test result
                       >            trap_ne
0c84 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c86 : 68              >            pla         ;load status
0c87 : 48              >            pha
                       >            cmp_flag zero
0c88 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c8a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c8c : 28              >            plp         ;restore status
                        
0c8d : 08                       php
0c8e : ca                       dex             ;ff
0c8f : 8a                       txa
0c90 : 28                       plp
0c91 : a8                       tay
                                tst_y $ff,minus
0c92 : 08              >            php         ;save flags
0c93 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0c95 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c97 : 68              >            pla         ;load status
0c98 : 48              >            pha
                       >            cmp_flag minus
0c99 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c9b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c9d : 28              >            plp         ;restore status
                        
                        
                        
                                load_flag $ff
0c9e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                        
0ca0 : 48                       pha
0ca1 : a0ff                     ldy #$ff        ;ff
0ca3 : 98                       tya
0ca4 : 28                       plp
0ca5 : aa                       tax
                                tst_x $ff,$ff-zero
0ca6 : 08              >            php         ;save flags
0ca7 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0ca9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cab : 68              >            pla         ;load status
0cac : 48              >            pha
                       >            cmp_flag $ff-zero
0cad : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0caf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cb1 : 28              >            plp         ;restore status
                        
0cb2 : 08                       php
0cb3 : c8                       iny             ;00
0cb4 : 98                       tya
0cb5 : 28                       plp
0cb6 : aa                       tax
                                tst_x 0,$ff-minus
0cb7 : 08              >            php         ;save flags
0cb8 : e000            >            cpx #0     ;test result
                       >            trap_ne
0cba : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cbc : 68              >            pla         ;load status
0cbd : 48              >            pha
                       >            cmp_flag $ff-minus
0cbe : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0cc0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cc2 : 28              >            plp         ;restore status
                        
0cc3 : 08                       php
0cc4 : c8                       iny             ;01
0cc5 : 98                       tya
0cc6 : 28                       plp
0cc7 : aa                       tax
                                tst_x 1,$ff-minus-zero
0cc8 : 08              >            php         ;save flags
0cc9 : e001            >            cpx #1     ;test result
                       >            trap_ne
0ccb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ccd : 68              >            pla         ;load status
0cce : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0ccf : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0cd1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cd3 : 28              >            plp         ;restore status
                        
                                load_flag 0
0cd4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                        
0cd6 : 48                       pha
0cd7 : a900                     lda #0          ;preset status
0cd9 : 98                       tya
0cda : 28                       plp
0cdb : aa                       tax
                                tst_x 1,0
0cdc : 08              >            php         ;save flags
0cdd : e001            >            cpx #1     ;test result
                       >            trap_ne
0cdf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ce1 : 68              >            pla         ;load status
0ce2 : 48              >            pha
                       >            cmp_flag 0
0ce3 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ce5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ce7 : 28              >            plp         ;restore status
                        
0ce8 : 08                       php
0ce9 : 88                       dey             ;00
0cea : 98                       tya
0ceb : 28                       plp
0cec : aa                       tax
                                tst_x 0,zero
0ced : 08              >            php         ;save flags
0cee : e000            >            cpx #0     ;test result
                       >            trap_ne
0cf0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cf2 : 68              >            pla         ;load status
0cf3 : 48              >            pha
                       >            cmp_flag zero
0cf4 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0cf6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cf8 : 28              >            plp         ;restore status
                        
0cf9 : 08                       php
0cfa : 88                       dey             ;ff
0cfb : 98                       tya
0cfc : 28                       plp
0cfd : aa                       tax
                                tst_x $ff,minus
0cfe : 08              >            php         ;save flags
0cff : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0d01 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d03 : 68              >            pla         ;load status
0d04 : 48              >            pha
                       >            cmp_flag minus
0d05 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0d07 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d09 : 28              >            plp         ;restore status
                        
                                next_test
0d0a : ad0002          >            lda test_case   ;previous test
0d0d : c90d            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0d0f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000e =                 >test_num = test_num + 1
0d11 : a90e            >            lda #test_num   ;*** next tests' number
0d13 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                             
                        ;TSX sets NZ - TXS does not
0d16 : a201                     ldx #1          ;01
                                set_stat $ff
                       >            load_flag $ff
0d18 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0d1a : 48              >            pha         ;use stack to load status
0d1b : 28              >            plp
                        
0d1c : 9a                       txs
0d1d : 08                       php
0d1e : ad0101                   lda $101
                                cmp_flag $ff
0d21 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0d23 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0d25 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0d27 : 48              >            pha         ;use stack to load status
0d28 : 28              >            plp
                        
0d29 : 9a                       txs
0d2a : 08                       php
0d2b : ad0101                   lda $101
                                cmp_flag 0
0d2e : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0d30 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0d32 : ca                       dex             ;00
                                set_stat $ff
                       >            load_flag $ff
0d33 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0d35 : 48              >            pha         ;use stack to load status
0d36 : 28              >            plp
                        
0d37 : 9a                       txs
0d38 : 08                       php
0d39 : ad0001                   lda $100
                                cmp_flag $ff
0d3c : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0d3e : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0d40 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0d42 : 48              >            pha         ;use stack to load status
0d43 : 28              >            plp
                        
0d44 : 9a                       txs
0d45 : 08                       php
0d46 : ad0001                   lda $100
                                cmp_flag 0
0d49 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0d4b : d0fe            >        bne *           ;failed not equal (non zero)
                        
0d4d : ca                       dex             ;ff
                                set_stat $ff
                       >            load_flag $ff
0d4e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0d50 : 48              >            pha         ;use stack to load status
0d51 : 28              >            plp
                        
0d52 : 9a                       txs
0d53 : 08                       php
0d54 : adff01                   lda $1ff
                                cmp_flag $ff
0d57 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0d59 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0d5b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0d5d : 48              >            pha         ;use stack to load status
0d5e : 28              >            plp
                        
0d5f : 9a                       txs
0d60 : 08                       php
0d61 : adff01                   lda $1ff
                                cmp_flag 0
0d64 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                
0d66 : a201                     ldx #1
0d68 : 9a                       txs             ;sp=01
                                set_stat $ff
                       >            load_flag $ff
0d69 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0d6b : 48              >            pha         ;use stack to load status
0d6c : 28              >            plp
                        
0d6d : ba                       tsx             ;clears Z, N
0d6e : 08                       php             ;sp=00
0d6f : e001                     cpx #1
                                trap_ne
0d71 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0d73 : ad0101                   lda $101
                                cmp_flag $ff-minus-zero
0d76 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0d78 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
0d7a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0d7c : 48              >            pha         ;use stack to load status
0d7d : 28              >            plp
                        
0d7e : ba                       tsx             ;clears N, sets Z
0d7f : 08                       php             ;sp=ff
0d80 : e000                     cpx #0
                                trap_ne
0d82 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0d84 : ad0001                   lda $100
                                cmp_flag $ff-minus
0d87 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0d89 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
0d8b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0d8d : 48              >            pha         ;use stack to load status
0d8e : 28              >            plp
                        
0d8f : ba                       tsx             ;clears N, sets Z
0d90 : 08                       php             ;sp=fe
0d91 : e0ff                     cpx #$ff
                                trap_ne
0d93 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0d95 : adff01                   lda $1ff
                                cmp_flag $ff-zero
0d98 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0d9a : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                
0d9c : a201                     ldx #1
0d9e : 9a                       txs             ;sp=01
                                set_stat 0
                       >            load_flag 0
0d9f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0da1 : 48              >            pha         ;use stack to load status
0da2 : 28              >            plp
                        
0da3 : ba                       tsx             ;clears Z, N
0da4 : 08                       php             ;sp=00
0da5 : e001                     cpx #1
                                trap_ne
0da7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0da9 : ad0101                   lda $101
                                cmp_flag 0
0dac : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0dae : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0db0 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0db2 : 48              >            pha         ;use stack to load status
0db3 : 28              >            plp
                        
0db4 : ba                       tsx             ;clears N, sets Z
0db5 : 08                       php             ;sp=ff
0db6 : e000                     cpx #0
                                trap_ne
0db8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0dba : ad0001                   lda $100
                                cmp_flag zero
0dbd : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0dbf : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0dc1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0dc3 : 48              >            pha         ;use stack to load status
0dc4 : 28              >            plp
                        
0dc5 : ba                       tsx             ;clears N, sets Z
0dc6 : 08                       php             ;sp=fe
0dc7 : e0ff                     cpx #$ff
                                trap_ne
0dc9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0dcb : adff01                   lda $1ff
                                cmp_flag minus
0dce : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0dd0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0dd2 : 68                       pla             ;sp=ff
                                next_test
0dd3 : ad0002          >            lda test_case   ;previous test
0dd6 : c90e            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0dd8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000f =                 >test_num = test_num + 1
0dda : a90f            >            lda #test_num   ;*** next tests' number
0ddc : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; testing index register load & store LDY LDX STY STX all addressing modes
                        ; LDX / STX - zp,y / abs,y
0ddf : a003                     ldy #3
0de1 :                  tldx    
                                set_stat 0
                       >            load_flag 0
0de1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0de3 : 48              >            pha         ;use stack to load status
0de4 : 28              >            plp
                        
0de5 : b613                     ldx zp1,y
0de7 : 08                       php         ;test stores do not alter flags
0de8 : 8a                       txa
0de9 : 49c3                     eor #$c3
0deb : 28                       plp
0dec : 990302                   sta abst,y
0def : 08                       php         ;flags after load/store sequence
0df0 : 49c3                     eor #$c3
0df2 : d90802                   cmp abs1,y  ;test result
                                trap_ne
0df5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0df7 : 68                       pla         ;load status
                                eor_flag 0
0df8 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
0dfa : d90d02                   cmp fLDx,y  ;test flags
                                trap_ne
0dfd : d0fe            >        bne *           ;failed not equal (non zero)
                        
0dff : 88                       dey
0e00 : 10df                     bpl tldx                  
                        
0e02 : a003                     ldy #3
0e04 :                  tldx1   
                                set_stat $ff
                       >            load_flag $ff
0e04 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0e06 : 48              >            pha         ;use stack to load status
0e07 : 28              >            plp
                        
0e08 : b613                     ldx zp1,y
0e0a : 08                       php         ;test stores do not alter flags
0e0b : 8a                       txa
0e0c : 49c3                     eor #$c3
0e0e : 28                       plp
0e0f : 990302                   sta abst,y
0e12 : 08                       php         ;flags after load/store sequence
0e13 : 49c3                     eor #$c3
0e15 : d90802                   cmp abs1,y  ;test result
                                trap_ne
0e18 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e1a : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0e1b : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
0e1d : d90d02                   cmp fLDx,y  ;test flags
                                trap_ne
0e20 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e22 : 88                       dey
0e23 : 10df                     bpl tldx1                  
                        
0e25 : a003                     ldy #3
0e27 :                  tldx2   
                                set_stat 0
                       >            load_flag 0
0e27 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0e29 : 48              >            pha         ;use stack to load status
0e2a : 28              >            plp
                        
0e2b : be0802                   ldx abs1,y
0e2e : 08                       php         ;test stores do not alter flags
0e2f : 8a                       txa
0e30 : 49c3                     eor #$c3
0e32 : aa                       tax
0e33 : 28                       plp
0e34 : 960c                     stx zpt,y
0e36 : 08                       php         ;flags after load/store sequence
0e37 : 49c3                     eor #$c3
0e39 : d91300                   cmp zp1,y   ;test result
                                trap_ne
0e3c : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e3e : 68                       pla         ;load status
                                eor_flag 0
0e3f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
0e41 : d90d02                   cmp fLDx,y  ;test flags
                                trap_ne
0e44 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e46 : 88                       dey
0e47 : 10de                     bpl tldx2                  
                        
0e49 : a003                     ldy #3
0e4b :                  tldx3   
                                set_stat $ff
                       >            load_flag $ff
0e4b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0e4d : 48              >            pha         ;use stack to load status
0e4e : 28              >            plp
                        
0e4f : be0802                   ldx abs1,y
0e52 : 08                       php         ;test stores do not alter flags
0e53 : 8a                       txa
0e54 : 49c3                     eor #$c3
0e56 : aa                       tax
0e57 : 28                       plp
0e58 : 960c                     stx zpt,y
0e5a : 08                       php         ;flags after load/store sequence
0e5b : 49c3                     eor #$c3
0e5d : d91300                   cmp zp1,y   ;test result
                                trap_ne
0e60 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e62 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0e63 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
0e65 : d90d02                   cmp fLDx,y  ;test flags
                                trap_ne
0e68 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e6a : 88                       dey
0e6b : 10de                     bpl tldx3
                                
0e6d : a003                     ldy #3      ;testing store result
0e6f : a200                     ldx #0
0e71 : b90c00           tstx    lda zpt,y
0e74 : 49c3                     eor #$c3
0e76 : d91300                   cmp zp1,y
                                trap_ne     ;store to zp data
0e79 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e7b : 960c                     stx zpt,y   ;clear                
0e7d : b90302                   lda abst,y
0e80 : 49c3                     eor #$c3
0e82 : d90802                   cmp abs1,y
                                trap_ne     ;store to abs data
0e85 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e87 : 8a                       txa
0e88 : 990302                   sta abst,y  ;clear                
0e8b : 88                       dey
0e8c : 10e3                     bpl tstx
                                next_test
0e8e : ad0002          >            lda test_case   ;previous test
0e91 : c90f            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0e93 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0010 =                 >test_num = test_num + 1
0e95 : a910            >            lda #test_num   ;*** next tests' number
0e97 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; indexed wraparound test (only zp should wrap)
0e9a : a0fd                     ldy #3+$fa
0e9c : b619             tldx4   ldx zp1-$fa&$ff,y   ;wrap on indexed zp
0e9e : 8a                       txa
0e9f : 990901                   sta abst-$fa,y      ;no STX abs,y!
0ea2 : 88                       dey
0ea3 : c0fa                     cpy #$fa
0ea5 : b0f5                     bcs tldx4                  
0ea7 : a0fd                     ldy #3+$fa
0ea9 : be0e01           tldx5   ldx abs1-$fa,y      ;no wrap on indexed abs
0eac : 9612                     stx zpt-$fa&$ff,y
0eae : 88                       dey
0eaf : c0fa                     cpy #$fa
0eb1 : b0f6                     bcs tldx5                  
0eb3 : a003                     ldy #3      ;testing wraparound result
0eb5 : a200                     ldx #0
0eb7 : b90c00           tstx1   lda zpt,y
0eba : d91300                   cmp zp1,y
                                trap_ne     ;store to zp data
0ebd : d0fe            >        bne *           ;failed not equal (non zero)
                        
0ebf : 960c                     stx zpt,y   ;clear                
0ec1 : b90302                   lda abst,y
0ec4 : d90802                   cmp abs1,y
                                trap_ne     ;store to abs data
0ec7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0ec9 : 8a                       txa
0eca : 990302                   sta abst,y  ;clear                
0ecd : 88                       dey
0ece : 10e7                     bpl tstx1
                                next_test
0ed0 : ad0002          >            lda test_case   ;previous test
0ed3 : c910            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0ed5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0011 =                 >test_num = test_num + 1
0ed7 : a911            >            lda #test_num   ;*** next tests' number
0ed9 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; LDY / STY - zp,x / abs,x
0edc : a203                     ldx #3
0ede :                  tldy    
                                set_stat 0
                       >            load_flag 0
0ede : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0ee0 : 48              >            pha         ;use stack to load status
0ee1 : 28              >            plp
                        
0ee2 : b413                     ldy zp1,x
0ee4 : 08                       php         ;test stores do not alter flags
0ee5 : 98                       tya
0ee6 : 49c3                     eor #$c3
0ee8 : 28                       plp
0ee9 : 9d0302                   sta abst,x
0eec : 08                       php         ;flags after load/store sequence
0eed : 49c3                     eor #$c3
0eef : dd0802                   cmp abs1,x  ;test result
                                trap_ne
0ef2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0ef4 : 68                       pla         ;load status
                                eor_flag 0
0ef5 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
0ef7 : dd0d02                   cmp fLDx,x  ;test flags
                                trap_ne
0efa : d0fe            >        bne *           ;failed not equal (non zero)
                        
0efc : ca                       dex
0efd : 10df                     bpl tldy                  
                        
0eff : a203                     ldx #3
0f01 :                  tldy1   
                                set_stat $ff
                       >            load_flag $ff
0f01 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0f03 : 48              >            pha         ;use stack to load status
0f04 : 28              >            plp
                        
0f05 : b413                     ldy zp1,x
0f07 : 08                       php         ;test stores do not alter flags
0f08 : 98                       tya
0f09 : 49c3                     eor #$c3
0f0b : 28                       plp
0f0c : 9d0302                   sta abst,x
0f0f : 08                       php         ;flags after load/store sequence
0f10 : 49c3                     eor #$c3
0f12 : dd0802                   cmp abs1,x  ;test result
                                trap_ne
0f15 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f17 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0f18 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
0f1a : dd0d02                   cmp fLDx,x  ;test flags
                                trap_ne
0f1d : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f1f : ca                       dex
0f20 : 10df                     bpl tldy1                  
                        
0f22 : a203                     ldx #3
0f24 :                  tldy2   
                                set_stat 0
                       >            load_flag 0
0f24 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0f26 : 48              >            pha         ;use stack to load status
0f27 : 28              >            plp
                        
0f28 : bc0802                   ldy abs1,x
0f2b : 08                       php         ;test stores do not alter flags
0f2c : 98                       tya
0f2d : 49c3                     eor #$c3
0f2f : a8                       tay
0f30 : 28                       plp
0f31 : 940c                     sty zpt,x
0f33 : 08                       php         ;flags after load/store sequence
0f34 : 49c3                     eor #$c3
0f36 : d513                     cmp zp1,x   ;test result
                                trap_ne
0f38 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f3a : 68                       pla         ;load status
                                eor_flag 0
0f3b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
0f3d : dd0d02                   cmp fLDx,x  ;test flags
                                trap_ne
0f40 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f42 : ca                       dex
0f43 : 10df                     bpl tldy2                  
                        
0f45 : a203                     ldx #3
0f47 :                  tldy3
                                set_stat $ff
                       >            load_flag $ff
0f47 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0f49 : 48              >            pha         ;use stack to load status
0f4a : 28              >            plp
                        
0f4b : bc0802                   ldy abs1,x
0f4e : 08                       php         ;test stores do not alter flags
0f4f : 98                       tya
0f50 : 49c3                     eor #$c3
0f52 : a8                       tay
0f53 : 28                       plp
0f54 : 940c                     sty zpt,x
0f56 : 08                       php         ;flags after load/store sequence
0f57 : 49c3                     eor #$c3
0f59 : d513                     cmp zp1,x   ;test result
                                trap_ne
0f5b : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f5d : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0f5e : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
0f60 : dd0d02                   cmp fLDx,x  ;test flags
                                trap_ne
0f63 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f65 : ca                       dex
0f66 : 10df                     bpl tldy3
                        
0f68 : a203                     ldx #3      ;testing store result
0f6a : a000                     ldy #0
0f6c : b50c             tsty    lda zpt,x
0f6e : 49c3                     eor #$c3
0f70 : d513                     cmp zp1,x
                                trap_ne     ;store to zp,x data
0f72 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f74 : 940c                     sty zpt,x   ;clear                
0f76 : bd0302                   lda abst,x
0f79 : 49c3                     eor #$c3
0f7b : dd0802                   cmp abs1,x
                                trap_ne     ;store to abs,x data
0f7e : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f80 : 8a                       txa
0f81 : 9d0302                   sta abst,x  ;clear                
0f84 : ca                       dex
0f85 : 10e5                     bpl tsty
                                next_test
0f87 : ad0002          >            lda test_case   ;previous test
0f8a : c911            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0f8c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0012 =                 >test_num = test_num + 1
0f8e : a912            >            lda #test_num   ;*** next tests' number
0f90 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; indexed wraparound test (only zp should wrap)
0f93 : a2fd                     ldx #3+$fa
0f95 : b419             tldy4   ldy zp1-$fa&$ff,x   ;wrap on indexed zp
0f97 : 98                       tya
0f98 : 9d0901                   sta abst-$fa,x      ;no STX abs,x!
0f9b : ca                       dex
0f9c : e0fa                     cpx #$fa
0f9e : b0f5                     bcs tldy4                  
0fa0 : a2fd                     ldx #3+$fa
0fa2 : bc0e01           tldy5   ldy abs1-$fa,x      ;no wrap on indexed abs
0fa5 : 9412                     sty zpt-$fa&$ff,x
0fa7 : ca                       dex
0fa8 : e0fa                     cpx #$fa
0faa : b0f6                     bcs tldy5                  
0fac : a203                     ldx #3      ;testing wraparound result
0fae : a000                     ldy #0
0fb0 : b50c             tsty1   lda zpt,x
0fb2 : d513                     cmp zp1,x
                                trap_ne     ;store to zp,x data
0fb4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0fb6 : 940c                     sty zpt,x   ;clear                
0fb8 : bd0302                   lda abst,x
0fbb : dd0802                   cmp abs1,x
                                trap_ne     ;store to abs,x data
0fbe : d0fe            >        bne *           ;failed not equal (non zero)
                        
0fc0 : 8a                       txa
0fc1 : 9d0302                   sta abst,x  ;clear                
0fc4 : ca                       dex
0fc5 : 10e9                     bpl tsty1
                                next_test
0fc7 : ad0002          >            lda test_case   ;previous test
0fca : c912            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0fcc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0013 =                 >test_num = test_num + 1
0fce : a913            >            lda #test_num   ;*** next tests' number
0fd0 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDX / STX - zp / abs / #
                                set_stat 0  
                       >            load_flag 0  
0fd3 : a900            >            lda #0               ;allow test to change I-flag (no mask)
                       >
0fd5 : 48              >            pha         ;use stack to load status
0fd6 : 28              >            plp
                        
0fd7 : a613                     ldx zp1
0fd9 : 08                       php         ;test stores do not alter flags
0fda : 8a                       txa
0fdb : 49c3                     eor #$c3
0fdd : aa                       tax
0fde : 28                       plp
0fdf : 8e0302                   stx abst
0fe2 : 08                       php         ;flags after load/store sequence
0fe3 : 49c3                     eor #$c3
0fe5 : aa                       tax
0fe6 : e0c3                     cpx #$c3    ;test result
                                trap_ne
0fe8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0fea : 68                       pla         ;load status
                                eor_flag 0
0feb : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
0fed : cd0d02                   cmp fLDx    ;test flags
                                trap_ne
0ff0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0ff2 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0ff4 : 48              >            pha         ;use stack to load status
0ff5 : 28              >            plp
                        
0ff6 : a614                     ldx zp1+1
0ff8 : 08                       php         ;test stores do not alter flags
0ff9 : 8a                       txa
0ffa : 49c3                     eor #$c3
0ffc : aa                       tax
0ffd : 28                       plp
0ffe : 8e0402                   stx abst+1
1001 : 08                       php         ;flags after load/store sequence
1002 : 49c3                     eor #$c3
1004 : aa                       tax
1005 : e082                     cpx #$82    ;test result
                                trap_ne
1007 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1009 : 68                       pla         ;load status
                                eor_flag 0
100a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
100c : cd0e02                   cmp fLDx+1  ;test flags
                                trap_ne
100f : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1011 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1013 : 48              >            pha         ;use stack to load status
1014 : 28              >            plp
                        
1015 : a615                     ldx zp1+2
1017 : 08                       php         ;test stores do not alter flags
1018 : 8a                       txa
1019 : 49c3                     eor #$c3
101b : aa                       tax
101c : 28                       plp
101d : 8e0502                   stx abst+2
1020 : 08                       php         ;flags after load/store sequence
1021 : 49c3                     eor #$c3
1023 : aa                       tax
1024 : e041                     cpx #$41    ;test result
                                trap_ne
1026 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1028 : 68                       pla         ;load status
                                eor_flag 0
1029 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
102b : cd0f02                   cmp fLDx+2  ;test flags
                                trap_ne
102e : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1030 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1032 : 48              >            pha         ;use stack to load status
1033 : 28              >            plp
                        
1034 : a616                     ldx zp1+3
1036 : 08                       php         ;test stores do not alter flags
1037 : 8a                       txa
1038 : 49c3                     eor #$c3
103a : aa                       tax
103b : 28                       plp
103c : 8e0602                   stx abst+3
103f : 08                       php         ;flags after load/store sequence
1040 : 49c3                     eor #$c3
1042 : aa                       tax
1043 : e000                     cpx #0      ;test result
                                trap_ne
1045 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1047 : 68                       pla         ;load status
                                eor_flag 0
1048 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
104a : cd1002                   cmp fLDx+3  ;test flags
                                trap_ne
104d : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
104f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1051 : 48              >            pha         ;use stack to load status
1052 : 28              >            plp
                        
1053 : a613                     ldx zp1  
1055 : 08                       php         ;test stores do not alter flags
1056 : 8a                       txa
1057 : 49c3                     eor #$c3
1059 : aa                       tax
105a : 28                       plp
105b : 8e0302                   stx abst  
105e : 08                       php         ;flags after load/store sequence
105f : 49c3                     eor #$c3
1061 : aa                       tax
1062 : e0c3                     cpx #$c3    ;test result
                                trap_ne     ;
1064 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1066 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1067 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1069 : cd0d02                   cmp fLDx    ;test flags
                                trap_ne
106c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
106e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1070 : 48              >            pha         ;use stack to load status
1071 : 28              >            plp
                        
1072 : a614                     ldx zp1+1
1074 : 08                       php         ;test stores do not alter flags
1075 : 8a                       txa
1076 : 49c3                     eor #$c3
1078 : aa                       tax
1079 : 28                       plp
107a : 8e0402                   stx abst+1
107d : 08                       php         ;flags after load/store sequence
107e : 49c3                     eor #$c3
1080 : aa                       tax
1081 : e082                     cpx #$82    ;test result
                                trap_ne
1083 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1085 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1086 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1088 : cd0e02                   cmp fLDx+1  ;test flags
                                trap_ne
108b : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
108d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
108f : 48              >            pha         ;use stack to load status
1090 : 28              >            plp
                        
1091 : a615                     ldx zp1+2
1093 : 08                       php         ;test stores do not alter flags
1094 : 8a                       txa
1095 : 49c3                     eor #$c3
1097 : aa                       tax
1098 : 28                       plp
1099 : 8e0502                   stx abst+2
109c : 08                       php         ;flags after load/store sequence
109d : 49c3                     eor #$c3
109f : aa                       tax
10a0 : e041                     cpx #$41    ;test result
                                trap_ne     ;
10a2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
10a4 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
10a5 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
10a7 : cd0f02                   cmp fLDx+2  ;test flags
                                trap_ne
10aa : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
10ac : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
10ae : 48              >            pha         ;use stack to load status
10af : 28              >            plp
                        
10b0 : a616                     ldx zp1+3
10b2 : 08                       php         ;test stores do not alter flags
10b3 : 8a                       txa
10b4 : 49c3                     eor #$c3
10b6 : aa                       tax
10b7 : 28                       plp
10b8 : 8e0602                   stx abst+3
10bb : 08                       php         ;flags after load/store sequence
10bc : 49c3                     eor #$c3
10be : aa                       tax
10bf : e000                     cpx #0      ;test result
                                trap_ne
10c1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
10c3 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
10c4 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
10c6 : cd1002                   cmp fLDx+3  ;test flags
                                trap_ne
10c9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat 0
                       >            load_flag 0
10cb : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
10cd : 48              >            pha         ;use stack to load status
10ce : 28              >            plp
                        
10cf : ae0802                   ldx abs1  
10d2 : 08                       php         ;test stores do not alter flags
10d3 : 8a                       txa
10d4 : 49c3                     eor #$c3
10d6 : aa                       tax
10d7 : 28                       plp
10d8 : 860c                     stx zpt  
10da : 08                       php         ;flags after load/store sequence
10db : 49c3                     eor #$c3
10dd : c513                     cmp zp1     ;test result
                                trap_ne
10df : d0fe            >        bne *           ;failed not equal (non zero)
                        
10e1 : 68                       pla         ;load status
                                eor_flag 0
10e2 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
10e4 : cd0d02                   cmp fLDx    ;test flags
                                trap_ne
10e7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
10e9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
10eb : 48              >            pha         ;use stack to load status
10ec : 28              >            plp
                        
10ed : ae0902                   ldx abs1+1
10f0 : 08                       php         ;test stores do not alter flags
10f1 : 8a                       txa
10f2 : 49c3                     eor #$c3
10f4 : aa                       tax
10f5 : 28                       plp
10f6 : 860d                     stx zpt+1
10f8 : 08                       php         ;flags after load/store sequence
10f9 : 49c3                     eor #$c3
10fb : c514                     cmp zp1+1   ;test result
                                trap_ne
10fd : d0fe            >        bne *           ;failed not equal (non zero)
                        
10ff : 68                       pla         ;load status
                                eor_flag 0
1100 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1102 : cd0e02                   cmp fLDx+1  ;test flags
                                trap_ne
1105 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1107 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1109 : 48              >            pha         ;use stack to load status
110a : 28              >            plp
                        
110b : ae0a02                   ldx abs1+2
110e : 08                       php         ;test stores do not alter flags
110f : 8a                       txa
1110 : 49c3                     eor #$c3
1112 : aa                       tax
1113 : 28                       plp
1114 : 860e                     stx zpt+2
1116 : 08                       php         ;flags after load/store sequence
1117 : 49c3                     eor #$c3
1119 : c515                     cmp zp1+2   ;test result
                                trap_ne
111b : d0fe            >        bne *           ;failed not equal (non zero)
                        
111d : 68                       pla         ;load status
                                eor_flag 0
111e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1120 : cd0f02                   cmp fLDx+2  ;test flags
                                trap_ne
1123 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1125 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1127 : 48              >            pha         ;use stack to load status
1128 : 28              >            plp
                        
1129 : ae0b02                   ldx abs1+3
112c : 08                       php         ;test stores do not alter flags
112d : 8a                       txa
112e : 49c3                     eor #$c3
1130 : aa                       tax
1131 : 28                       plp
1132 : 860f                     stx zpt+3
1134 : 08                       php         ;flags after load/store sequence
1135 : 49c3                     eor #$c3
1137 : c516                     cmp zp1+3   ;test result
                                trap_ne
1139 : d0fe            >        bne *           ;failed not equal (non zero)
                        
113b : 68                       pla         ;load status
                                eor_flag 0
113c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
113e : cd1002                   cmp fLDx+3  ;test flags
                                trap_ne
1141 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
1143 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1145 : 48              >            pha         ;use stack to load status
1146 : 28              >            plp
                        
1147 : ae0802                   ldx abs1  
114a : 08                       php         ;test stores do not alter flags
114b : 8a                       txa
114c : 49c3                     eor #$c3
114e : aa                       tax
114f : 28                       plp
1150 : 860c                     stx zpt  
1152 : 08                       php         ;flags after load/store sequence
1153 : 49c3                     eor #$c3
1155 : aa                       tax
1156 : e413                     cpx zp1     ;test result
                                trap_ne
1158 : d0fe            >        bne *           ;failed not equal (non zero)
                        
115a : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
115b : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
115d : cd0d02                   cmp fLDx    ;test flags
                                trap_ne
1160 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1162 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1164 : 48              >            pha         ;use stack to load status
1165 : 28              >            plp
                        
1166 : ae0902                   ldx abs1+1
1169 : 08                       php         ;test stores do not alter flags
116a : 8a                       txa
116b : 49c3                     eor #$c3
116d : aa                       tax
116e : 28                       plp
116f : 860d                     stx zpt+1
1171 : 08                       php         ;flags after load/store sequence
1172 : 49c3                     eor #$c3
1174 : aa                       tax
1175 : e414                     cpx zp1+1   ;test result
                                trap_ne
1177 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1179 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
117a : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
117c : cd0e02                   cmp fLDx+1  ;test flags
                                trap_ne
117f : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1181 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1183 : 48              >            pha         ;use stack to load status
1184 : 28              >            plp
                        
1185 : ae0a02                   ldx abs1+2
1188 : 08                       php         ;test stores do not alter flags
1189 : 8a                       txa
118a : 49c3                     eor #$c3
118c : aa                       tax
118d : 28                       plp
118e : 860e                     stx zpt+2
1190 : 08                       php         ;flags after load/store sequence
1191 : 49c3                     eor #$c3
1193 : aa                       tax
1194 : e415                     cpx zp1+2   ;test result
                                trap_ne
1196 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1198 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1199 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
119b : cd0f02                   cmp fLDx+2  ;test flags
                                trap_ne
119e : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
11a0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
11a2 : 48              >            pha         ;use stack to load status
11a3 : 28              >            plp
                        
11a4 : ae0b02                   ldx abs1+3
11a7 : 08                       php         ;test stores do not alter flags
11a8 : 8a                       txa
11a9 : 49c3                     eor #$c3
11ab : aa                       tax
11ac : 28                       plp
11ad : 860f                     stx zpt+3
11af : 08                       php         ;flags after load/store sequence
11b0 : 49c3                     eor #$c3
11b2 : aa                       tax
11b3 : e416                     cpx zp1+3   ;test result
                                trap_ne
11b5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
11b7 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
11b8 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
11ba : cd1002                   cmp fLDx+3  ;test flags
                                trap_ne
11bd : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat 0  
                       >            load_flag 0  
11bf : a900            >            lda #0               ;allow test to change I-flag (no mask)
                       >
11c1 : 48              >            pha         ;use stack to load status
11c2 : 28              >            plp
                        
11c3 : a2c3                     ldx #$c3
11c5 : 08                       php
11c6 : ec0802                   cpx abs1    ;test result
                                trap_ne
11c9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
11cb : 68                       pla         ;load status
                                eor_flag 0
11cc : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
11ce : cd0d02                   cmp fLDx    ;test flags
                                trap_ne
11d1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
11d3 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
11d5 : 48              >            pha         ;use stack to load status
11d6 : 28              >            plp
                        
11d7 : a282                     ldx #$82
11d9 : 08                       php
11da : ec0902                   cpx abs1+1  ;test result
                                trap_ne
11dd : d0fe            >        bne *           ;failed not equal (non zero)
                        
11df : 68                       pla         ;load status
                                eor_flag 0
11e0 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
11e2 : cd0e02                   cmp fLDx+1  ;test flags
                                trap_ne
11e5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
11e7 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
11e9 : 48              >            pha         ;use stack to load status
11ea : 28              >            plp
                        
11eb : a241                     ldx #$41
11ed : 08                       php
11ee : ec0a02                   cpx abs1+2  ;test result
                                trap_ne
11f1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
11f3 : 68                       pla         ;load status
                                eor_flag 0
11f4 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
11f6 : cd0f02                   cmp fLDx+2  ;test flags
                                trap_ne
11f9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
11fb : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
11fd : 48              >            pha         ;use stack to load status
11fe : 28              >            plp
                        
11ff : a200                     ldx #0
1201 : 08                       php
1202 : ec0b02                   cpx abs1+3  ;test result
                                trap_ne
1205 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1207 : 68                       pla         ;load status
                                eor_flag 0
1208 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
120a : cd1002                   cmp fLDx+3  ;test flags
                                trap_ne
120d : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
120f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1211 : 48              >            pha         ;use stack to load status
1212 : 28              >            plp
                        
1213 : a2c3                     ldx #$c3  
1215 : 08                       php
1216 : ec0802                   cpx abs1    ;test result
                                trap_ne
1219 : d0fe            >        bne *           ;failed not equal (non zero)
                        
121b : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
121c : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
121e : cd0d02                   cmp fLDx    ;test flags
                                trap_ne
1221 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1223 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1225 : 48              >            pha         ;use stack to load status
1226 : 28              >            plp
                        
1227 : a282                     ldx #$82
1229 : 08                       php
122a : ec0902                   cpx abs1+1  ;test result
                                trap_ne
122d : d0fe            >        bne *           ;failed not equal (non zero)
                        
122f : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1230 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1232 : cd0e02                   cmp fLDx+1  ;test flags
                                trap_ne
1235 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1237 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1239 : 48              >            pha         ;use stack to load status
123a : 28              >            plp
                        
123b : a241                     ldx #$41
123d : 08                       php
123e : ec0a02                   cpx abs1+2  ;test result
                                trap_ne
1241 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1243 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1244 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1246 : cd0f02                   cmp fLDx+2  ;test flags
                                trap_ne
1249 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
124b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
124d : 48              >            pha         ;use stack to load status
124e : 28              >            plp
                        
124f : a200                     ldx #0
1251 : 08                       php
1252 : ec0b02                   cpx abs1+3  ;test result
                                trap_ne
1255 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1257 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1258 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
125a : cd1002                   cmp fLDx+3  ;test flags
                                trap_ne
125d : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
125f : a200                     ldx #0
1261 : a50c                     lda zpt  
1263 : 49c3                     eor #$c3
1265 : c513                     cmp zp1  
                                trap_ne     ;store to zp data
1267 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1269 : 860c                     stx zpt     ;clear                
126b : ad0302                   lda abst  
126e : 49c3                     eor #$c3
1270 : cd0802                   cmp abs1  
                                trap_ne     ;store to abs data
1273 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1275 : 8e0302                   stx abst    ;clear                
1278 : a50d                     lda zpt+1
127a : 49c3                     eor #$c3
127c : c514                     cmp zp1+1
                                trap_ne     ;store to zp data
127e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1280 : 860d                     stx zpt+1   ;clear                
1282 : ad0402                   lda abst+1
1285 : 49c3                     eor #$c3
1287 : cd0902                   cmp abs1+1
                                trap_ne     ;store to abs data
128a : d0fe            >        bne *           ;failed not equal (non zero)
                        
128c : 8e0402                   stx abst+1  ;clear                
128f : a50e                     lda zpt+2
1291 : 49c3                     eor #$c3
1293 : c515                     cmp zp1+2
                                trap_ne     ;store to zp data
1295 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1297 : 860e                     stx zpt+2   ;clear                
1299 : ad0502                   lda abst+2
129c : 49c3                     eor #$c3
129e : cd0a02                   cmp abs1+2
                                trap_ne     ;store to abs data
12a1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
12a3 : 8e0502                   stx abst+2  ;clear                
12a6 : a50f                     lda zpt+3
12a8 : 49c3                     eor #$c3
12aa : c516                     cmp zp1+3
                                trap_ne     ;store to zp data
12ac : d0fe            >        bne *           ;failed not equal (non zero)
                        
12ae : 860f                     stx zpt+3   ;clear                
12b0 : ad0602                   lda abst+3
12b3 : 49c3                     eor #$c3
12b5 : cd0b02                   cmp abs1+3
                                trap_ne     ;store to abs data
12b8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
12ba : 8e0602                   stx abst+3  ;clear                
                                next_test
12bd : ad0002          >            lda test_case   ;previous test
12c0 : c913            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
12c2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0014 =                 >test_num = test_num + 1
12c4 : a914            >            lda #test_num   ;*** next tests' number
12c6 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDY / STY - zp / abs / #
                                set_stat 0
                       >            load_flag 0
12c9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
12cb : 48              >            pha         ;use stack to load status
12cc : 28              >            plp
                        
12cd : a413                     ldy zp1  
12cf : 08                       php         ;test stores do not alter flags
12d0 : 98                       tya
12d1 : 49c3                     eor #$c3
12d3 : a8                       tay
12d4 : 28                       plp
12d5 : 8c0302                   sty abst  
12d8 : 08                       php         ;flags after load/store sequence
12d9 : 49c3                     eor #$c3
12db : a8                       tay
12dc : c0c3                     cpy #$c3    ;test result
                                trap_ne
12de : d0fe            >        bne *           ;failed not equal (non zero)
                        
12e0 : 68                       pla         ;load status
                                eor_flag 0
12e1 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
12e3 : cd0d02                   cmp fLDx    ;test flags
                                trap_ne
12e6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
12e8 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
12ea : 48              >            pha         ;use stack to load status
12eb : 28              >            plp
                        
12ec : a414                     ldy zp1+1
12ee : 08                       php         ;test stores do not alter flags
12ef : 98                       tya
12f0 : 49c3                     eor #$c3
12f2 : a8                       tay
12f3 : 28                       plp
12f4 : 8c0402                   sty abst+1
12f7 : 08                       php         ;flags after load/store sequence
12f8 : 49c3                     eor #$c3
12fa : a8                       tay
12fb : c082                     cpy #$82    ;test result
                                trap_ne
12fd : d0fe            >        bne *           ;failed not equal (non zero)
                        
12ff : 68                       pla         ;load status
                                eor_flag 0
1300 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1302 : cd0e02                   cmp fLDx+1  ;test flags
                                trap_ne
1305 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1307 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1309 : 48              >            pha         ;use stack to load status
130a : 28              >            plp
                        
130b : a415                     ldy zp1+2
130d : 08                       php         ;test stores do not alter flags
130e : 98                       tya
130f : 49c3                     eor #$c3
1311 : a8                       tay
1312 : 28                       plp
1313 : 8c0502                   sty abst+2
1316 : 08                       php         ;flags after load/store sequence
1317 : 49c3                     eor #$c3
1319 : a8                       tay
131a : c041                     cpy #$41    ;test result
                                trap_ne
131c : d0fe            >        bne *           ;failed not equal (non zero)
                        
131e : 68                       pla         ;load status
                                eor_flag 0
131f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1321 : cd0f02                   cmp fLDx+2  ;test flags
                                trap_ne
1324 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1326 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1328 : 48              >            pha         ;use stack to load status
1329 : 28              >            plp
                        
132a : a416                     ldy zp1+3
132c : 08                       php         ;test stores do not alter flags
132d : 98                       tya
132e : 49c3                     eor #$c3
1330 : a8                       tay
1331 : 28                       plp
1332 : 8c0602                   sty abst+3
1335 : 08                       php         ;flags after load/store sequence
1336 : 49c3                     eor #$c3
1338 : a8                       tay
1339 : c000                     cpy #0      ;test result
                                trap_ne
133b : d0fe            >        bne *           ;failed not equal (non zero)
                        
133d : 68                       pla         ;load status
                                eor_flag 0
133e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1340 : cd1002                   cmp fLDx+3  ;test flags
                                trap_ne
1343 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
1345 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1347 : 48              >            pha         ;use stack to load status
1348 : 28              >            plp
                        
1349 : a413                     ldy zp1  
134b : 08                       php         ;test stores do not alter flags
134c : 98                       tya
134d : 49c3                     eor #$c3
134f : a8                       tay
1350 : 28                       plp
1351 : 8c0302                   sty abst  
1354 : 08                       php         ;flags after load/store sequence
1355 : 49c3                     eor #$c3
1357 : a8                       tay
1358 : c0c3                     cpy #$c3    ;test result
                                trap_ne
135a : d0fe            >        bne *           ;failed not equal (non zero)
                        
135c : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
135d : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
135f : cd0d02                   cmp fLDx    ;test flags
                                trap_ne
1362 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1364 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1366 : 48              >            pha         ;use stack to load status
1367 : 28              >            plp
                        
1368 : a414                     ldy zp1+1
136a : 08                       php         ;test stores do not alter flags
136b : 98                       tya
136c : 49c3                     eor #$c3
136e : a8                       tay
136f : 28                       plp
1370 : 8c0402                   sty abst+1
1373 : 08                       php         ;flags after load/store sequence
1374 : 49c3                     eor #$c3
1376 : a8                       tay
1377 : c082                     cpy #$82   ;test result
                                trap_ne
1379 : d0fe            >        bne *           ;failed not equal (non zero)
                        
137b : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
137c : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
137e : cd0e02                   cmp fLDx+1  ;test flags
                                trap_ne
1381 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1383 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1385 : 48              >            pha         ;use stack to load status
1386 : 28              >            plp
                        
1387 : a415                     ldy zp1+2
1389 : 08                       php         ;test stores do not alter flags
138a : 98                       tya
138b : 49c3                     eor #$c3
138d : a8                       tay
138e : 28                       plp
138f : 8c0502                   sty abst+2
1392 : 08                       php         ;flags after load/store sequence
1393 : 49c3                     eor #$c3
1395 : a8                       tay
1396 : c041                     cpy #$41    ;test result
                                trap_ne
1398 : d0fe            >        bne *           ;failed not equal (non zero)
                        
139a : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
139b : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
139d : cd0f02                   cmp fLDx+2  ;test flags
                                trap_ne
13a0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
13a2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
13a4 : 48              >            pha         ;use stack to load status
13a5 : 28              >            plp
                        
13a6 : a416                     ldy zp1+3
13a8 : 08                       php         ;test stores do not alter flags
13a9 : 98                       tya
13aa : 49c3                     eor #$c3
13ac : a8                       tay
13ad : 28                       plp
13ae : 8c0602                   sty abst+3
13b1 : 08                       php         ;flags after load/store sequence
13b2 : 49c3                     eor #$c3
13b4 : a8                       tay
13b5 : c000                     cpy #0      ;test result
                                trap_ne
13b7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
13b9 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
13ba : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
13bc : cd1002                   cmp fLDx+3  ;test flags
                                trap_ne
13bf : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                
                                set_stat 0
                       >            load_flag 0
13c1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
13c3 : 48              >            pha         ;use stack to load status
13c4 : 28              >            plp
                        
13c5 : ac0802                   ldy abs1  
13c8 : 08                       php         ;test stores do not alter flags
13c9 : 98                       tya
13ca : 49c3                     eor #$c3
13cc : a8                       tay
13cd : 28                       plp
13ce : 840c                     sty zpt  
13d0 : 08                       php         ;flags after load/store sequence
13d1 : 49c3                     eor #$c3
13d3 : a8                       tay
13d4 : c413                     cpy zp1     ;test result
                                trap_ne
13d6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
13d8 : 68                       pla         ;load status
                                eor_flag 0
13d9 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
13db : cd0d02                   cmp fLDx    ;test flags
                                trap_ne
13de : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
13e0 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
13e2 : 48              >            pha         ;use stack to load status
13e3 : 28              >            plp
                        
13e4 : ac0902                   ldy abs1+1
13e7 : 08                       php         ;test stores do not alter flags
13e8 : 98                       tya
13e9 : 49c3                     eor #$c3
13eb : a8                       tay
13ec : 28                       plp
13ed : 840d                     sty zpt+1
13ef : 08                       php         ;flags after load/store sequence
13f0 : 49c3                     eor #$c3
13f2 : a8                       tay
13f3 : c414                     cpy zp1+1   ;test result
                                trap_ne
13f5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
13f7 : 68                       pla         ;load status
                                eor_flag 0
13f8 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
13fa : cd0e02                   cmp fLDx+1  ;test flags
                                trap_ne
13fd : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
13ff : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1401 : 48              >            pha         ;use stack to load status
1402 : 28              >            plp
                        
1403 : ac0a02                   ldy abs1+2
1406 : 08                       php         ;test stores do not alter flags
1407 : 98                       tya
1408 : 49c3                     eor #$c3
140a : a8                       tay
140b : 28                       plp
140c : 840e                     sty zpt+2
140e : 08                       php         ;flags after load/store sequence
140f : 49c3                     eor #$c3
1411 : a8                       tay
1412 : c415                     cpy zp1+2   ;test result
                                trap_ne
1414 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1416 : 68                       pla         ;load status
                                eor_flag 0
1417 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1419 : cd0f02                   cmp fLDx+2  ;test flags
                                trap_ne
141c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
141e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1420 : 48              >            pha         ;use stack to load status
1421 : 28              >            plp
                        
1422 : ac0b02                   ldy abs1+3
1425 : 08                       php         ;test stores do not alter flags
1426 : 98                       tya
1427 : 49c3                     eor #$c3
1429 : a8                       tay
142a : 28                       plp
142b : 840f                     sty zpt+3
142d : 08                       php         ;flags after load/store sequence
142e : 49c3                     eor #$c3
1430 : a8                       tay
1431 : c416                     cpy zp1+3   ;test result
                                trap_ne
1433 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1435 : 68                       pla         ;load status
                                eor_flag 0
1436 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1438 : cd1002                   cmp fLDx+3  ;test flags
                                trap_ne
143b : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
143d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
143f : 48              >            pha         ;use stack to load status
1440 : 28              >            plp
                        
1441 : ac0802                   ldy abs1  
1444 : 08                       php         ;test stores do not alter flags
1445 : 98                       tya
1446 : 49c3                     eor #$c3
1448 : a8                       tay
1449 : 28                       plp
144a : 840c                     sty zpt  
144c : 08                       php         ;flags after load/store sequence
144d : 49c3                     eor #$c3
144f : a8                       tay
1450 : c513                     cmp zp1     ;test result
                                trap_ne
1452 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1454 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1455 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1457 : cd0d02                   cmp fLDx    ;test flags
                                trap_ne
145a : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
145c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
145e : 48              >            pha         ;use stack to load status
145f : 28              >            plp
                        
1460 : ac0902                   ldy abs1+1
1463 : 08                       php         ;test stores do not alter flags
1464 : 98                       tya
1465 : 49c3                     eor #$c3
1467 : a8                       tay
1468 : 28                       plp
1469 : 840d                     sty zpt+1
146b : 08                       php         ;flags after load/store sequence
146c : 49c3                     eor #$c3
146e : a8                       tay
146f : c514                     cmp zp1+1   ;test result
                                trap_ne
1471 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1473 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1474 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1476 : cd0e02                   cmp fLDx+1  ;test flags
                                trap_ne
1479 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
147b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
147d : 48              >            pha         ;use stack to load status
147e : 28              >            plp
                        
147f : ac0a02                   ldy abs1+2
1482 : 08                       php         ;test stores do not alter flags
1483 : 98                       tya
1484 : 49c3                     eor #$c3
1486 : a8                       tay
1487 : 28                       plp
1488 : 840e                     sty zpt+2
148a : 08                       php         ;flags after load/store sequence
148b : 49c3                     eor #$c3
148d : a8                       tay
148e : c515                     cmp zp1+2   ;test result
                                trap_ne
1490 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1492 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1493 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1495 : cd0f02                   cmp fLDx+2  ;test flags
                                trap_ne
1498 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
149a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
149c : 48              >            pha         ;use stack to load status
149d : 28              >            plp
                        
149e : ac0b02                   ldy abs1+3
14a1 : 08                       php         ;test stores do not alter flags
14a2 : 98                       tya
14a3 : 49c3                     eor #$c3
14a5 : a8                       tay
14a6 : 28                       plp
14a7 : 840f                     sty zpt+3
14a9 : 08                       php         ;flags after load/store sequence
14aa : 49c3                     eor #$c3
14ac : a8                       tay
14ad : c516                     cmp zp1+3   ;test result
                                trap_ne
14af : d0fe            >        bne *           ;failed not equal (non zero)
                        
14b1 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
14b2 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
14b4 : cd1002                   cmp fLDx+3  ;test flags
                                trap_ne
14b7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                        
                                set_stat 0
                       >            load_flag 0
14b9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
14bb : 48              >            pha         ;use stack to load status
14bc : 28              >            plp
                        
14bd : a0c3                     ldy #$c3  
14bf : 08                       php
14c0 : cc0802                   cpy abs1    ;test result
                                trap_ne
14c3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
14c5 : 68                       pla         ;load status
                                eor_flag 0
14c6 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
14c8 : cd0d02                   cmp fLDx    ;test flags
                                trap_ne
14cb : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
14cd : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
14cf : 48              >            pha         ;use stack to load status
14d0 : 28              >            plp
                        
14d1 : a082                     ldy #$82
14d3 : 08                       php
14d4 : cc0902                   cpy abs1+1  ;test result
                                trap_ne
14d7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
14d9 : 68                       pla         ;load status
                                eor_flag 0
14da : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
14dc : cd0e02                   cmp fLDx+1  ;test flags
                                trap_ne
14df : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
14e1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
14e3 : 48              >            pha         ;use stack to load status
14e4 : 28              >            plp
                        
14e5 : a041                     ldy #$41
14e7 : 08                       php
14e8 : cc0a02                   cpy abs1+2  ;test result
                                trap_ne
14eb : d0fe            >        bne *           ;failed not equal (non zero)
                        
14ed : 68                       pla         ;load status
                                eor_flag 0
14ee : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
14f0 : cd0f02                   cmp fLDx+2  ;test flags
                                trap_ne
14f3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
14f5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
14f7 : 48              >            pha         ;use stack to load status
14f8 : 28              >            plp
                        
14f9 : a000                     ldy #0
14fb : 08                       php
14fc : cc0b02                   cpy abs1+3  ;test result
                                trap_ne
14ff : d0fe            >        bne *           ;failed not equal (non zero)
                        
1501 : 68                       pla         ;load status
                                eor_flag 0
1502 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1504 : cd1002                   cmp fLDx+3  ;test flags
                                trap_ne
1507 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
1509 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
150b : 48              >            pha         ;use stack to load status
150c : 28              >            plp
                        
150d : a0c3                     ldy #$c3  
150f : 08                       php
1510 : cc0802                   cpy abs1    ;test result
                                trap_ne
1513 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1515 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1516 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1518 : cd0d02                   cmp fLDx    ;test flags
                                trap_ne
151b : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
151d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
151f : 48              >            pha         ;use stack to load status
1520 : 28              >            plp
                        
1521 : a082                     ldy #$82
1523 : 08                       php
1524 : cc0902                   cpy abs1+1  ;test result
                                trap_ne
1527 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1529 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
152a : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
152c : cd0e02                   cmp fLDx+1  ;test flags
                                trap_ne
152f : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1531 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1533 : 48              >            pha         ;use stack to load status
1534 : 28              >            plp
                        
1535 : a041                     ldy #$41
1537 : 08                       php
1538 : cc0a02                   cpy abs1+2   ;test result
                                trap_ne
153b : d0fe            >        bne *           ;failed not equal (non zero)
                        
153d : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
153e : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1540 : cd0f02                   cmp fLDx+2  ;test flags
                                trap_ne
1543 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1545 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1547 : 48              >            pha         ;use stack to load status
1548 : 28              >            plp
                        
1549 : a000                     ldy #0
154b : 08                       php
154c : cc0b02                   cpy abs1+3  ;test result
                                trap_ne
154f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1551 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1552 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1554 : cd1002                   cmp fLDx+3  ;test flags
                                trap_ne
1557 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                
1559 : a000                     ldy #0
155b : a50c                     lda zpt  
155d : 49c3                     eor #$c3
155f : c513                     cmp zp1  
                                trap_ne     ;store to zp   data
1561 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1563 : 840c                     sty zpt     ;clear                
1565 : ad0302                   lda abst  
1568 : 49c3                     eor #$c3
156a : cd0802                   cmp abs1  
                                trap_ne     ;store to abs   data
156d : d0fe            >        bne *           ;failed not equal (non zero)
                        
156f : 8c0302                   sty abst    ;clear                
1572 : a50d                     lda zpt+1
1574 : 49c3                     eor #$c3
1576 : c514                     cmp zp1+1
                                trap_ne     ;store to zp+1 data
1578 : d0fe            >        bne *           ;failed not equal (non zero)
                        
157a : 840d                     sty zpt+1   ;clear                
157c : ad0402                   lda abst+1
157f : 49c3                     eor #$c3
1581 : cd0902                   cmp abs1+1
                                trap_ne     ;store to abs+1 data
1584 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1586 : 8c0402                   sty abst+1  ;clear                
1589 : a50e                     lda zpt+2
158b : 49c3                     eor #$c3
158d : c515                     cmp zp1+2
                                trap_ne     ;store to zp+2 data
158f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1591 : 840e                     sty zpt+2   ;clear                
1593 : ad0502                   lda abst+2
1596 : 49c3                     eor #$c3
1598 : cd0a02                   cmp abs1+2
                                trap_ne     ;store to abs+2 data
159b : d0fe            >        bne *           ;failed not equal (non zero)
                        
159d : 8c0502                   sty abst+2  ;clear                
15a0 : a50f                     lda zpt+3
15a2 : 49c3                     eor #$c3
15a4 : c516                     cmp zp1+3
                                trap_ne     ;store to zp+3 data
15a6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
15a8 : 840f                     sty zpt+3   ;clear                
15aa : ad0602                   lda abst+3
15ad : 49c3                     eor #$c3
15af : cd0b02                   cmp abs1+3
                                trap_ne     ;store to abs+3 data
15b2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
15b4 : 8c0602                   sty abst+3  ;clear                
                                next_test
15b7 : ad0002          >            lda test_case   ;previous test
15ba : c914            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
15bc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0015 =                 >test_num = test_num + 1
15be : a915            >            lda #test_num   ;*** next tests' number
15c0 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing load / store accumulator LDA / STA all addressing modes
                        ; LDA / STA - zp,x / abs,x
15c3 : a203                     ldx #3
15c5 :                  tldax    
                                set_stat 0
                       >            load_flag 0
15c5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
15c7 : 48              >            pha         ;use stack to load status
15c8 : 28              >            plp
                        
15c9 : b513                     lda zp1,x
15cb : 08                       php         ;test stores do not alter flags
15cc : 49c3                     eor #$c3
15ce : 28                       plp
15cf : 9d0302                   sta abst,x
15d2 : 08                       php         ;flags after load/store sequence
15d3 : 49c3                     eor #$c3
15d5 : dd0802                   cmp abs1,x  ;test result
                                trap_ne
15d8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
15da : 68                       pla         ;load status
                                eor_flag 0
15db : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
15dd : dd0d02                   cmp fLDx,x  ;test flags
                                trap_ne
15e0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
15e2 : ca                       dex
15e3 : 10e0                     bpl tldax                  
                        
15e5 : a203                     ldx #3
15e7 :                  tldax1   
                                set_stat $ff
                       >            load_flag $ff
15e7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
15e9 : 48              >            pha         ;use stack to load status
15ea : 28              >            plp
                        
15eb : b513                     lda zp1,x
15ed : 08                       php         ;test stores do not alter flags
15ee : 49c3                     eor #$c3
15f0 : 28                       plp
15f1 : 9d0302                   sta abst,x
15f4 : 08                       php         ;flags after load/store sequence
15f5 : 49c3                     eor #$c3
15f7 : dd0802                   cmp abs1,x   ;test result
                                trap_ne
15fa : d0fe            >        bne *           ;failed not equal (non zero)
                        
15fc : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
15fd : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
15ff : dd0d02                   cmp fLDx,x  ;test flags
                                trap_ne
1602 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1604 : ca                       dex
1605 : 10e0                     bpl tldax1                  
                        
1607 : a203                     ldx #3
1609 :                  tldax2   
                                set_stat 0
                       >            load_flag 0
1609 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
160b : 48              >            pha         ;use stack to load status
160c : 28              >            plp
                        
160d : bd0802                   lda abs1,x
1610 : 08                       php         ;test stores do not alter flags
1611 : 49c3                     eor #$c3
1613 : 28                       plp
1614 : 950c                     sta zpt,x
1616 : 08                       php         ;flags after load/store sequence
1617 : 49c3                     eor #$c3
1619 : d513                     cmp zp1,x   ;test result
                                trap_ne
161b : d0fe            >        bne *           ;failed not equal (non zero)
                        
161d : 68                       pla         ;load status
                                eor_flag 0
161e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1620 : dd0d02                   cmp fLDx,x  ;test flags
                                trap_ne
1623 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1625 : ca                       dex
1626 : 10e1                     bpl tldax2                  
                        
1628 : a203                     ldx #3
162a :                  tldax3
                                set_stat $ff
                       >            load_flag $ff
162a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
162c : 48              >            pha         ;use stack to load status
162d : 28              >            plp
                        
162e : bd0802                   lda abs1,x
1631 : 08                       php         ;test stores do not alter flags
1632 : 49c3                     eor #$c3
1634 : 28                       plp
1635 : 950c                     sta zpt,x
1637 : 08                       php         ;flags after load/store sequence
1638 : 49c3                     eor #$c3
163a : d513                     cmp zp1,x   ;test result
                                trap_ne
163c : d0fe            >        bne *           ;failed not equal (non zero)
                        
163e : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
163f : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1641 : dd0d02                   cmp fLDx,x  ;test flags
                                trap_ne
1644 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1646 : ca                       dex
1647 : 10e1                     bpl tldax3
                        
1649 : a203                     ldx #3      ;testing store result
164b : a000                     ldy #0
164d : b50c             tstax   lda zpt,x
164f : 49c3                     eor #$c3
1651 : d513                     cmp zp1,x
                                trap_ne     ;store to zp,x data
1653 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1655 : 940c                     sty zpt,x   ;clear                
1657 : bd0302                   lda abst,x
165a : 49c3                     eor #$c3
165c : dd0802                   cmp abs1,x
                                trap_ne     ;store to abs,x data
165f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1661 : 8a                       txa
1662 : 9d0302                   sta abst,x  ;clear                
1665 : ca                       dex
1666 : 10e5                     bpl tstax
                                next_test
1668 : ad0002          >            lda test_case   ;previous test
166b : c915            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
166d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0016 =                 >test_num = test_num + 1
166f : a916            >            lda #test_num   ;*** next tests' number
1671 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDA / STA - (zp),y / abs,y / (zp,x)
1674 : a003                     ldy #3
1676 :                  tlday    
                                set_stat 0
                       >            load_flag 0
1676 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1678 : 48              >            pha         ;use stack to load status
1679 : 28              >            plp
                        
167a : b124                     lda (ind1),y
167c : 08                       php         ;test stores do not alter flags
167d : 49c3                     eor #$c3
167f : 28                       plp
1680 : 990302                   sta abst,y
1683 : 08                       php         ;flags after load/store sequence
1684 : 49c3                     eor #$c3
1686 : d90802                   cmp abs1,y  ;test result
                                trap_ne
1689 : d0fe            >        bne *           ;failed not equal (non zero)
                        
168b : 68                       pla         ;load status
                                eor_flag 0
168c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
168e : d90d02                   cmp fLDx,y  ;test flags
                                trap_ne
1691 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1693 : 88                       dey
1694 : 10e0                     bpl tlday                  
                        
1696 : a003                     ldy #3
1698 :                  tlday1   
                                set_stat $ff
                       >            load_flag $ff
1698 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
169a : 48              >            pha         ;use stack to load status
169b : 28              >            plp
                        
169c : b124                     lda (ind1),y
169e : 08                       php         ;test stores do not alter flags
169f : 49c3                     eor #$c3
16a1 : 28                       plp
16a2 : 990302                   sta abst,y
16a5 : 08                       php         ;flags after load/store sequence
16a6 : 49c3                     eor #$c3
16a8 : d90802                   cmp abs1,y  ;test result
                                trap_ne
16ab : d0fe            >        bne *           ;failed not equal (non zero)
                        
16ad : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
16ae : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
16b0 : d90d02                   cmp fLDx,y  ;test flags
                                trap_ne
16b3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
16b5 : 88                       dey
16b6 : 10e0                     bpl tlday1                  
                        
16b8 : a003                     ldy #3      ;testing store result
16ba : a200                     ldx #0
16bc : b90302           tstay   lda abst,y
16bf : 49c3                     eor #$c3
16c1 : d90802                   cmp abs1,y
                                trap_ne     ;store to abs data
16c4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
16c6 : 8a                       txa
16c7 : 990302                   sta abst,y  ;clear                
16ca : 88                       dey
16cb : 10ef                     bpl tstay
                        
16cd : a003                     ldy #3
16cf :                  tlday2   
                                set_stat 0
                       >            load_flag 0
16cf : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
16d1 : 48              >            pha         ;use stack to load status
16d2 : 28              >            plp
                        
16d3 : b90802                   lda abs1,y
16d6 : 08                       php         ;test stores do not alter flags
16d7 : 49c3                     eor #$c3
16d9 : 28                       plp
16da : 9130                     sta (indt),y
16dc : 08                       php         ;flags after load/store sequence
16dd : 49c3                     eor #$c3
16df : d124                     cmp (ind1),y    ;test result
                                trap_ne
16e1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
16e3 : 68                       pla         ;load status
                                eor_flag 0
16e4 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
16e6 : d90d02                   cmp fLDx,y  ;test flags
                                trap_ne
16e9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
16eb : 88                       dey
16ec : 10e1                     bpl tlday2                  
                        
16ee : a003                     ldy #3
16f0 :                  tlday3   
                                set_stat $ff
                       >            load_flag $ff
16f0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
16f2 : 48              >            pha         ;use stack to load status
16f3 : 28              >            plp
                        
16f4 : b90802                   lda abs1,y
16f7 : 08                       php         ;test stores do not alter flags
16f8 : 49c3                     eor #$c3
16fa : 28                       plp
16fb : 9130                     sta (indt),y
16fd : 08                       php         ;flags after load/store sequence
16fe : 49c3                     eor #$c3
1700 : d124                     cmp (ind1),y   ;test result
                                trap_ne
1702 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1704 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1705 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1707 : d90d02                   cmp fLDx,y  ;test flags
                                trap_ne
170a : d0fe            >        bne *           ;failed not equal (non zero)
                        
170c : 88                       dey
170d : 10e1                     bpl tlday3
                                
170f : a003                     ldy #3      ;testing store result
1711 : a200                     ldx #0
1713 : b90302           tstay1  lda abst,y
1716 : 49c3                     eor #$c3
1718 : d90802                   cmp abs1,y
                                trap_ne     ;store to abs data
171b : d0fe            >        bne *           ;failed not equal (non zero)
                        
171d : 8a                       txa
171e : 990302                   sta abst,y  ;clear                
1721 : 88                       dey
1722 : 10ef                     bpl tstay1
                                
1724 : a206                     ldx #6
1726 : a003                     ldy #3
1728 :                  tldax4   
                                set_stat 0
                       >            load_flag 0
1728 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
172a : 48              >            pha         ;use stack to load status
172b : 28              >            plp
                        
172c : a124                     lda (ind1,x)
172e : 08                       php         ;test stores do not alter flags
172f : 49c3                     eor #$c3
1731 : 28                       plp
1732 : 8130                     sta (indt,x)
1734 : 08                       php         ;flags after load/store sequence
1735 : 49c3                     eor #$c3
1737 : d90802                   cmp abs1,y  ;test result
                                trap_ne
173a : d0fe            >        bne *           ;failed not equal (non zero)
                        
173c : 68                       pla         ;load status
                                eor_flag 0
173d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
173f : d90d02                   cmp fLDx,y  ;test flags
                                trap_ne
1742 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1744 : ca                       dex
1745 : ca                       dex
1746 : 88                       dey
1747 : 10df                     bpl tldax4                  
                        
1749 : a206                     ldx #6
174b : a003                     ldy #3
174d :                  tldax5
                                set_stat $ff
                       >            load_flag $ff
174d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
174f : 48              >            pha         ;use stack to load status
1750 : 28              >            plp
                        
1751 : a124                     lda (ind1,x)
1753 : 08                       php         ;test stores do not alter flags
1754 : 49c3                     eor #$c3
1756 : 28                       plp
1757 : 8130                     sta (indt,x)
1759 : 08                       php         ;flags after load/store sequence
175a : 49c3                     eor #$c3
175c : d90802                   cmp abs1,y  ;test result
                                trap_ne
175f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1761 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1762 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1764 : d90d02                   cmp fLDx,y  ;test flags
                                trap_ne
1767 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1769 : ca                       dex
176a : ca                       dex
176b : 88                       dey
176c : 10df                     bpl tldax5
                        
176e : a003                     ldy #3      ;testing store result
1770 : a200                     ldx #0
1772 : b90302           tstay2  lda abst,y
1775 : 49c3                     eor #$c3
1777 : d90802                   cmp abs1,y
                                trap_ne     ;store to abs data
177a : d0fe            >        bne *           ;failed not equal (non zero)
                        
177c : 8a                       txa
177d : 990302                   sta abst,y  ;clear                
1780 : 88                       dey
1781 : 10ef                     bpl tstay2
                                next_test
1783 : ad0002          >            lda test_case   ;previous test
1786 : c916            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1788 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0017 =                 >test_num = test_num + 1
178a : a917            >            lda #test_num   ;*** next tests' number
178c : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; indexed wraparound test (only zp should wrap)
178f : a2fd                     ldx #3+$fa
1791 : b519             tldax6  lda zp1-$fa&$ff,x   ;wrap on indexed zp
1793 : 9d0901                   sta abst-$fa,x      ;no STX abs,x!
1796 : ca                       dex
1797 : e0fa                     cpx #$fa
1799 : b0f6                     bcs tldax6                  
179b : a2fd                     ldx #3+$fa
179d : bd0e01           tldax7  lda abs1-$fa,x      ;no wrap on indexed abs
17a0 : 9512                     sta zpt-$fa&$ff,x
17a2 : ca                       dex
17a3 : e0fa                     cpx #$fa
17a5 : b0f6                     bcs tldax7
                                                  
17a7 : a203                     ldx #3      ;testing wraparound result
17a9 : a000                     ldy #0
17ab : b50c             tstax1  lda zpt,x
17ad : d513                     cmp zp1,x
                                trap_ne     ;store to zp,x data
17af : d0fe            >        bne *           ;failed not equal (non zero)
                        
17b1 : 940c                     sty zpt,x   ;clear                
17b3 : bd0302                   lda abst,x
17b6 : dd0802                   cmp abs1,x
                                trap_ne     ;store to abs,x data
17b9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
17bb : 8a                       txa
17bc : 9d0302                   sta abst,x  ;clear                
17bf : ca                       dex
17c0 : 10e9                     bpl tstax1
                        
17c2 : a0fb                     ldy #3+$f8
17c4 : a2fe                     ldx #6+$f8
17c6 : a12c             tlday4  lda (ind1-$f8&$ff,x) ;wrap on indexed zp indirect
17c8 : 990b01                   sta abst-$f8,y
17cb : ca                       dex
17cc : ca                       dex
17cd : 88                       dey
17ce : c0f8                     cpy #$f8
17d0 : b0f4                     bcs tlday4
17d2 : a003                     ldy #3      ;testing wraparound result
17d4 : a200                     ldx #0
17d6 : b90302           tstay4  lda abst,y
17d9 : d90802                   cmp abs1,y
                                trap_ne     ;store to abs data
17dc : d0fe            >        bne *           ;failed not equal (non zero)
                        
17de : 8a                       txa
17df : 990302                   sta abst,y  ;clear                
17e2 : 88                       dey
17e3 : 10f1                     bpl tstay4
                                
17e5 : a0fb                     ldy #3+$f8
17e7 : b91001           tlday5  lda abs1-$f8,y  ;no wrap on indexed abs
17ea : 9138                     sta (inwt),y
17ec : 88                       dey
17ed : c0f8                     cpy #$f8
17ef : b0f6                     bcs tlday5                  
17f1 : a003                     ldy #3      ;testing wraparound result
17f3 : a200                     ldx #0
17f5 : b90302           tstay5  lda abst,y
17f8 : d90802                   cmp abs1,y
                                trap_ne     ;store to abs data
17fb : d0fe            >        bne *           ;failed not equal (non zero)
                        
17fd : 8a                       txa
17fe : 990302                   sta abst,y  ;clear                
1801 : 88                       dey
1802 : 10f1                     bpl tstay5
                        
1804 : a0fb                     ldy #3+$f8
1806 : a2fe                     ldx #6+$f8
1808 : b12e             tlday6  lda (inw1),y    ;no wrap on zp indirect indexed 
180a : 8138                     sta (indt-$f8&$ff,x)
180c : ca                       dex
180d : ca                       dex
180e : 88                       dey
180f : c0f8                     cpy #$f8
1811 : b0f5                     bcs tlday6
1813 : a003                     ldy #3      ;testing wraparound result
1815 : a200                     ldx #0
1817 : b90302           tstay6  lda abst,y
181a : d90802                   cmp abs1,y
                                trap_ne     ;store to abs data
181d : d0fe            >        bne *           ;failed not equal (non zero)
                        
181f : 8a                       txa
1820 : 990302                   sta abst,y  ;clear                
1823 : 88                       dey
1824 : 10f1                     bpl tstay6
                                next_test
1826 : ad0002          >            lda test_case   ;previous test
1829 : c917            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
182b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0018 =                 >test_num = test_num + 1
182d : a918            >            lda #test_num   ;*** next tests' number
182f : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDA / STA - zp / abs / #
                                set_stat 0  
                       >            load_flag 0  
1832 : a900            >            lda #0               ;allow test to change I-flag (no mask)
                       >
1834 : 48              >            pha         ;use stack to load status
1835 : 28              >            plp
                        
1836 : a513                     lda zp1
1838 : 08                       php         ;test stores do not alter flags
1839 : 49c3                     eor #$c3
183b : 28                       plp
183c : 8d0302                   sta abst
183f : 08                       php         ;flags after load/store sequence
1840 : 49c3                     eor #$c3
1842 : c9c3                     cmp #$c3    ;test result
                                trap_ne
1844 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1846 : 68                       pla         ;load status
                                eor_flag 0
1847 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1849 : cd0d02                   cmp fLDx    ;test flags
                                trap_ne
184c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
184e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1850 : 48              >            pha         ;use stack to load status
1851 : 28              >            plp
                        
1852 : a514                     lda zp1+1
1854 : 08                       php         ;test stores do not alter flags
1855 : 49c3                     eor #$c3
1857 : 28                       plp
1858 : 8d0402                   sta abst+1
185b : 08                       php         ;flags after load/store sequence
185c : 49c3                     eor #$c3
185e : c982                     cmp #$82    ;test result
                                trap_ne
1860 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1862 : 68                       pla         ;load status
                                eor_flag 0
1863 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1865 : cd0e02                   cmp fLDx+1  ;test flags
                                trap_ne
1868 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
186a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
186c : 48              >            pha         ;use stack to load status
186d : 28              >            plp
                        
186e : a515                     lda zp1+2
1870 : 08                       php         ;test stores do not alter flags
1871 : 49c3                     eor #$c3
1873 : 28                       plp
1874 : 8d0502                   sta abst+2
1877 : 08                       php         ;flags after load/store sequence
1878 : 49c3                     eor #$c3
187a : c941                     cmp #$41    ;test result
                                trap_ne
187c : d0fe            >        bne *           ;failed not equal (non zero)
                        
187e : 68                       pla         ;load status
                                eor_flag 0
187f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1881 : cd0f02                   cmp fLDx+2  ;test flags
                                trap_ne
1884 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1886 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1888 : 48              >            pha         ;use stack to load status
1889 : 28              >            plp
                        
188a : a516                     lda zp1+3
188c : 08                       php         ;test stores do not alter flags
188d : 49c3                     eor #$c3
188f : 28                       plp
1890 : 8d0602                   sta abst+3
1893 : 08                       php         ;flags after load/store sequence
1894 : 49c3                     eor #$c3
1896 : c900                     cmp #0      ;test result
                                trap_ne
1898 : d0fe            >        bne *           ;failed not equal (non zero)
                        
189a : 68                       pla         ;load status
                                eor_flag 0
189b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
189d : cd1002                   cmp fLDx+3  ;test flags
                                trap_ne
18a0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
18a2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
18a4 : 48              >            pha         ;use stack to load status
18a5 : 28              >            plp
                        
18a6 : a513                     lda zp1  
18a8 : 08                       php         ;test stores do not alter flags
18a9 : 49c3                     eor #$c3
18ab : 28                       plp
18ac : 8d0302                   sta abst  
18af : 08                       php         ;flags after load/store sequence
18b0 : 49c3                     eor #$c3
18b2 : c9c3                     cmp #$c3    ;test result
                                trap_ne
18b4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
18b6 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
18b7 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
18b9 : cd0d02                   cmp fLDx    ;test flags
                                trap_ne
18bc : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
18be : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
18c0 : 48              >            pha         ;use stack to load status
18c1 : 28              >            plp
                        
18c2 : a514                     lda zp1+1
18c4 : 08                       php         ;test stores do not alter flags
18c5 : 49c3                     eor #$c3
18c7 : 28                       plp
18c8 : 8d0402                   sta abst+1
18cb : 08                       php         ;flags after load/store sequence
18cc : 49c3                     eor #$c3
18ce : c982                     cmp #$82    ;test result
                                trap_ne
18d0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
18d2 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
18d3 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
18d5 : cd0e02                   cmp fLDx+1  ;test flags
                                trap_ne
18d8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
18da : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
18dc : 48              >            pha         ;use stack to load status
18dd : 28              >            plp
                        
18de : a515                     lda zp1+2
18e0 : 08                       php         ;test stores do not alter flags
18e1 : 49c3                     eor #$c3
18e3 : 28                       plp
18e4 : 8d0502                   sta abst+2
18e7 : 08                       php         ;flags after load/store sequence
18e8 : 49c3                     eor #$c3
18ea : c941                     cmp #$41    ;test result
                                trap_ne
18ec : d0fe            >        bne *           ;failed not equal (non zero)
                        
18ee : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
18ef : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
18f1 : cd0f02                   cmp fLDx+2  ;test flags
                                trap_ne
18f4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
18f6 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
18f8 : 48              >            pha         ;use stack to load status
18f9 : 28              >            plp
                        
18fa : a516                     lda zp1+3
18fc : 08                       php         ;test stores do not alter flags
18fd : 49c3                     eor #$c3
18ff : 28                       plp
1900 : 8d0602                   sta abst+3
1903 : 08                       php         ;flags after load/store sequence
1904 : 49c3                     eor #$c3
1906 : c900                     cmp #0      ;test result
                                trap_ne
1908 : d0fe            >        bne *           ;failed not equal (non zero)
                        
190a : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
190b : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
190d : cd1002                   cmp fLDx+3  ;test flags
                                trap_ne
1910 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1912 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1914 : 48              >            pha         ;use stack to load status
1915 : 28              >            plp
                        
1916 : ad0802                   lda abs1  
1919 : 08                       php         ;test stores do not alter flags
191a : 49c3                     eor #$c3
191c : 28                       plp
191d : 850c                     sta zpt  
191f : 08                       php         ;flags after load/store sequence
1920 : 49c3                     eor #$c3
1922 : c513                     cmp zp1     ;test result
                                trap_ne
1924 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1926 : 68                       pla         ;load status
                                eor_flag 0
1927 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1929 : cd0d02                   cmp fLDx    ;test flags
                                trap_ne
192c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
192e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1930 : 48              >            pha         ;use stack to load status
1931 : 28              >            plp
                        
1932 : ad0902                   lda abs1+1
1935 : 08                       php         ;test stores do not alter flags
1936 : 49c3                     eor #$c3
1938 : 28                       plp
1939 : 850d                     sta zpt+1
193b : 08                       php         ;flags after load/store sequence
193c : 49c3                     eor #$c3
193e : c514                     cmp zp1+1   ;test result
                                trap_ne
1940 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1942 : 68                       pla         ;load status
                                eor_flag 0
1943 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1945 : cd0e02                   cmp fLDx+1  ;test flags
                                trap_ne
1948 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
194a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
194c : 48              >            pha         ;use stack to load status
194d : 28              >            plp
                        
194e : ad0a02                   lda abs1+2
1951 : 08                       php         ;test stores do not alter flags
1952 : 49c3                     eor #$c3
1954 : 28                       plp
1955 : 850e                     sta zpt+2
1957 : 08                       php         ;flags after load/store sequence
1958 : 49c3                     eor #$c3
195a : c515                     cmp zp1+2   ;test result
                                trap_ne
195c : d0fe            >        bne *           ;failed not equal (non zero)
                        
195e : 68                       pla         ;load status
                                eor_flag 0
195f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1961 : cd0f02                   cmp fLDx+2  ;test flags
                                trap_ne
1964 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1966 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1968 : 48              >            pha         ;use stack to load status
1969 : 28              >            plp
                        
196a : ad0b02                   lda abs1+3
196d : 08                       php         ;test stores do not alter flags
196e : 49c3                     eor #$c3
1970 : 28                       plp
1971 : 850f                     sta zpt+3
1973 : 08                       php         ;flags after load/store sequence
1974 : 49c3                     eor #$c3
1976 : c516                     cmp zp1+3   ;test result
                                trap_ne
1978 : d0fe            >        bne *           ;failed not equal (non zero)
                        
197a : 68                       pla         ;load status
                                eor_flag 0
197b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
197d : cd1002                   cmp fLDx+3  ;test flags
                                trap_ne
1980 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1982 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1984 : 48              >            pha         ;use stack to load status
1985 : 28              >            plp
                        
1986 : ad0802                   lda abs1  
1989 : 08                       php         ;test stores do not alter flags
198a : 49c3                     eor #$c3
198c : 28                       plp
198d : 850c                     sta zpt  
198f : 08                       php         ;flags after load/store sequence
1990 : 49c3                     eor #$c3
1992 : c513                     cmp zp1     ;test result
                                trap_ne
1994 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1996 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1997 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1999 : cd0d02                   cmp fLDx    ;test flags
                                trap_ne
199c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
199e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
19a0 : 48              >            pha         ;use stack to load status
19a1 : 28              >            plp
                        
19a2 : ad0902                   lda abs1+1
19a5 : 08                       php         ;test stores do not alter flags
19a6 : 49c3                     eor #$c3
19a8 : 28                       plp
19a9 : 850d                     sta zpt+1
19ab : 08                       php         ;flags after load/store sequence
19ac : 49c3                     eor #$c3
19ae : c514                     cmp zp1+1   ;test result
                                trap_ne
19b0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
19b2 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
19b3 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
19b5 : cd0e02                   cmp fLDx+1  ;test flags
                                trap_ne
19b8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
19ba : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
19bc : 48              >            pha         ;use stack to load status
19bd : 28              >            plp
                        
19be : ad0a02                   lda abs1+2
19c1 : 08                       php         ;test stores do not alter flags
19c2 : 49c3                     eor #$c3
19c4 : 28                       plp
19c5 : 850e                     sta zpt+2
19c7 : 08                       php         ;flags after load/store sequence
19c8 : 49c3                     eor #$c3
19ca : c515                     cmp zp1+2   ;test result
                                trap_ne
19cc : d0fe            >        bne *           ;failed not equal (non zero)
                        
19ce : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
19cf : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
19d1 : cd0f02                   cmp fLDx+2  ;test flags
                                trap_ne
19d4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
19d6 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
19d8 : 48              >            pha         ;use stack to load status
19d9 : 28              >            plp
                        
19da : ad0b02                   lda abs1+3
19dd : 08                       php         ;test stores do not alter flags
19de : 49c3                     eor #$c3
19e0 : 28                       plp
19e1 : 850f                     sta zpt+3
19e3 : 08                       php         ;flags after load/store sequence
19e4 : 49c3                     eor #$c3
19e6 : c516                     cmp zp1+3   ;test result
                                trap_ne
19e8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
19ea : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
19eb : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
19ed : cd1002                   cmp fLDx+3  ;test flags
                                trap_ne
19f0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0  
                       >            load_flag 0  
19f2 : a900            >            lda #0               ;allow test to change I-flag (no mask)
                       >
19f4 : 48              >            pha         ;use stack to load status
19f5 : 28              >            plp
                        
19f6 : a9c3                     lda #$c3
19f8 : 08                       php
19f9 : cd0802                   cmp abs1    ;test result
                                trap_ne
19fc : d0fe            >        bne *           ;failed not equal (non zero)
                        
19fe : 68                       pla         ;load status
                                eor_flag 0
19ff : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1a01 : cd0d02                   cmp fLDx    ;test flags
                                trap_ne
1a04 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1a06 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1a08 : 48              >            pha         ;use stack to load status
1a09 : 28              >            plp
                        
1a0a : a982                     lda #$82
1a0c : 08                       php
1a0d : cd0902                   cmp abs1+1  ;test result
                                trap_ne
1a10 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a12 : 68                       pla         ;load status
                                eor_flag 0
1a13 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1a15 : cd0e02                   cmp fLDx+1  ;test flags
                                trap_ne
1a18 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1a1a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1a1c : 48              >            pha         ;use stack to load status
1a1d : 28              >            plp
                        
1a1e : a941                     lda #$41
1a20 : 08                       php
1a21 : cd0a02                   cmp abs1+2  ;test result
                                trap_ne
1a24 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a26 : 68                       pla         ;load status
                                eor_flag 0
1a27 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1a29 : cd0f02                   cmp fLDx+2  ;test flags
                                trap_ne
1a2c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1a2e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1a30 : 48              >            pha         ;use stack to load status
1a31 : 28              >            plp
                        
1a32 : a900                     lda #0
1a34 : 08                       php
1a35 : cd0b02                   cmp abs1+3  ;test result
                                trap_ne
1a38 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a3a : 68                       pla         ;load status
                                eor_flag 0
1a3b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1a3d : cd1002                   cmp fLDx+3  ;test flags
                                trap_ne
1a40 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
1a42 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1a44 : 48              >            pha         ;use stack to load status
1a45 : 28              >            plp
                        
1a46 : a9c3                     lda #$c3  
1a48 : 08                       php
1a49 : cd0802                   cmp abs1    ;test result
                                trap_ne
1a4c : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a4e : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1a4f : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1a51 : cd0d02                   cmp fLDx    ;test flags
                                trap_ne
1a54 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1a56 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1a58 : 48              >            pha         ;use stack to load status
1a59 : 28              >            plp
                        
1a5a : a982                     lda #$82
1a5c : 08                       php
1a5d : cd0902                   cmp abs1+1  ;test result
                                trap_ne
1a60 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a62 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1a63 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1a65 : cd0e02                   cmp fLDx+1  ;test flags
                                trap_ne
1a68 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1a6a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1a6c : 48              >            pha         ;use stack to load status
1a6d : 28              >            plp
                        
1a6e : a941                     lda #$41
1a70 : 08                       php
1a71 : cd0a02                   cmp abs1+2  ;test result
                                trap_ne
1a74 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a76 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1a77 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1a79 : cd0f02                   cmp fLDx+2  ;test flags
                                trap_ne
1a7c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1a7e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1a80 : 48              >            pha         ;use stack to load status
1a81 : 28              >            plp
                        
1a82 : a900                     lda #0
1a84 : 08                       php
1a85 : cd0b02                   cmp abs1+3  ;test result
                                trap_ne
1a88 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a8a : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1a8b : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1a8d : cd1002                   cmp fLDx+3  ;test flags
                                trap_ne
1a90 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
1a92 : a200                     ldx #0
1a94 : a50c                     lda zpt  
1a96 : 49c3                     eor #$c3
1a98 : c513                     cmp zp1  
                                trap_ne     ;store to zp data
1a9a : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a9c : 860c                     stx zpt     ;clear                
1a9e : ad0302                   lda abst  
1aa1 : 49c3                     eor #$c3
1aa3 : cd0802                   cmp abs1  
                                trap_ne     ;store to abs data
1aa6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1aa8 : 8e0302                   stx abst    ;clear                
1aab : a50d                     lda zpt+1
1aad : 49c3                     eor #$c3
1aaf : c514                     cmp zp1+1
                                trap_ne     ;store to zp data
1ab1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1ab3 : 860d                     stx zpt+1   ;clear                
1ab5 : ad0402                   lda abst+1
1ab8 : 49c3                     eor #$c3
1aba : cd0902                   cmp abs1+1
                                trap_ne     ;store to abs data
1abd : d0fe            >        bne *           ;failed not equal (non zero)
                        
1abf : 8e0402                   stx abst+1  ;clear                
1ac2 : a50e                     lda zpt+2
1ac4 : 49c3                     eor #$c3
1ac6 : c515                     cmp zp1+2
                                trap_ne     ;store to zp data
1ac8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1aca : 860e                     stx zpt+2   ;clear                
1acc : ad0502                   lda abst+2
1acf : 49c3                     eor #$c3
1ad1 : cd0a02                   cmp abs1+2
                                trap_ne     ;store to abs data
1ad4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1ad6 : 8e0502                   stx abst+2  ;clear                
1ad9 : a50f                     lda zpt+3
1adb : 49c3                     eor #$c3
1add : c516                     cmp zp1+3
                                trap_ne     ;store to zp data
1adf : d0fe            >        bne *           ;failed not equal (non zero)
                        
1ae1 : 860f                     stx zpt+3   ;clear                
1ae3 : ad0602                   lda abst+3
1ae6 : 49c3                     eor #$c3
1ae8 : cd0b02                   cmp abs1+3
                                trap_ne     ;store to abs data
1aeb : d0fe            >        bne *           ;failed not equal (non zero)
                        
1aed : 8e0602                   stx abst+3  ;clear                
                                next_test
1af0 : ad0002          >            lda test_case   ;previous test
1af3 : c918            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1af5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0019 =                 >test_num = test_num + 1
1af7 : a919            >            lda #test_num   ;*** next tests' number
1af9 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing bit test & compares BIT CPX CPY CMP all addressing modes
                        ; BIT - zp / abs
                                set_a $ff,0
                       >            load_flag 0
1afc : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1afe : 48              >            pha         ;use stack to load status
1aff : a9ff            >            lda #$ff     ;precharge accu
1b01 : 28              >            plp
                        
1b02 : 2416                     bit zp1+3   ;00 - should set Z / clear  NV
                                tst_a $ff,fz 
1b04 : 08              >            php         ;save flags
1b05 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1b07 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b09 : 68              >            pla         ;load status
1b0a : 48              >            pha
                       >            cmp_flag fz 
1b0b : c932            >            cmp #(fz |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1b0d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b0f : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1b10 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1b12 : 48              >            pha         ;use stack to load status
1b13 : a901            >            lda #1     ;precharge accu
1b15 : 28              >            plp
                        
1b16 : 2415                     bit zp1+2   ;41 - should set V (M6) / clear NZ
                                tst_a 1,fv
1b18 : 08              >            php         ;save flags
1b19 : c901            >            cmp #1     ;test result
                       >            trap_ne
1b1b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b1d : 68              >            pla         ;load status
1b1e : 48              >            pha
                       >            cmp_flag fv
1b1f : c970            >            cmp #(fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1b21 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b23 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1b24 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1b26 : 48              >            pha         ;use stack to load status
1b27 : a901            >            lda #1     ;precharge accu
1b29 : 28              >            plp
                        
1b2a : 2414                     bit zp1+1   ;82 - should set N (M7) & Z / clear V
                                tst_a 1,fnz
1b2c : 08              >            php         ;save flags
1b2d : c901            >            cmp #1     ;test result
                       >            trap_ne
1b2f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b31 : 68              >            pla         ;load status
1b32 : 48              >            pha
                       >            cmp_flag fnz
1b33 : c9b2            >            cmp #(fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1b35 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b37 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1b38 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1b3a : 48              >            pha         ;use stack to load status
1b3b : a901            >            lda #1     ;precharge accu
1b3d : 28              >            plp
                        
1b3e : 2413                     bit zp1     ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,fnv
1b40 : 08              >            php         ;save flags
1b41 : c901            >            cmp #1     ;test result
                       >            trap_ne
1b43 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b45 : 68              >            pla         ;load status
1b46 : 48              >            pha
                       >            cmp_flag fnv
1b47 : c9f0            >            cmp #(fnv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1b49 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b4b : 28              >            plp         ;restore status
                        
                                
                                set_a $ff,$ff
                       >            load_flag $ff
1b4c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1b4e : 48              >            pha         ;use stack to load status
1b4f : a9ff            >            lda #$ff     ;precharge accu
1b51 : 28              >            plp
                        
1b52 : 2416                     bit zp1+3   ;00 - should set Z / clear  NV
                                tst_a $ff,~fnv 
1b54 : 08              >            php         ;save flags
1b55 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1b57 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b59 : 68              >            pla         ;load status
1b5a : 48              >            pha
                       >            cmp_flag ~fnv 
1b5b : c93f            >            cmp #(~fnv |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1b5d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b5f : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1b60 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1b62 : 48              >            pha         ;use stack to load status
1b63 : a901            >            lda #1     ;precharge accu
1b65 : 28              >            plp
                        
1b66 : 2415                     bit zp1+2   ;41 - should set V (M6) / clear NZ
                                tst_a 1,~fnz
1b68 : 08              >            php         ;save flags
1b69 : c901            >            cmp #1     ;test result
                       >            trap_ne
1b6b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b6d : 68              >            pla         ;load status
1b6e : 48              >            pha
                       >            cmp_flag ~fnz
1b6f : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1b71 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b73 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1b74 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1b76 : 48              >            pha         ;use stack to load status
1b77 : a901            >            lda #1     ;precharge accu
1b79 : 28              >            plp
                        
1b7a : 2414                     bit zp1+1   ;82 - should set N (M7) & Z / clear V
                                tst_a 1,~fv
1b7c : 08              >            php         ;save flags
1b7d : c901            >            cmp #1     ;test result
                       >            trap_ne
1b7f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b81 : 68              >            pla         ;load status
1b82 : 48              >            pha
                       >            cmp_flag ~fv
1b83 : c9bf            >            cmp #(~fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1b85 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b87 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1b88 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1b8a : 48              >            pha         ;use stack to load status
1b8b : a901            >            lda #1     ;precharge accu
1b8d : 28              >            plp
                        
1b8e : 2413                     bit zp1     ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,~fz
1b90 : 08              >            php         ;save flags
1b91 : c901            >            cmp #1     ;test result
                       >            trap_ne
1b93 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b95 : 68              >            pla         ;load status
1b96 : 48              >            pha
                       >            cmp_flag ~fz
1b97 : c9fd            >            cmp #(~fz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1b99 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b9b : 28              >            plp         ;restore status
                        
                                
                                set_a $ff,0
                       >            load_flag 0
1b9c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1b9e : 48              >            pha         ;use stack to load status
1b9f : a9ff            >            lda #$ff     ;precharge accu
1ba1 : 28              >            plp
                        
1ba2 : 2c0b02                   bit abs1+3  ;00 - should set Z / clear  NV
                                tst_a $ff,fz 
1ba5 : 08              >            php         ;save flags
1ba6 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1ba8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1baa : 68              >            pla         ;load status
1bab : 48              >            pha
                       >            cmp_flag fz 
1bac : c932            >            cmp #(fz |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1bae : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bb0 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1bb1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1bb3 : 48              >            pha         ;use stack to load status
1bb4 : a901            >            lda #1     ;precharge accu
1bb6 : 28              >            plp
                        
1bb7 : 2c0a02                   bit abs1+2  ;41 - should set V (M6) / clear NZ
                                tst_a 1,fv
1bba : 08              >            php         ;save flags
1bbb : c901            >            cmp #1     ;test result
                       >            trap_ne
1bbd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bbf : 68              >            pla         ;load status
1bc0 : 48              >            pha
                       >            cmp_flag fv
1bc1 : c970            >            cmp #(fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1bc3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bc5 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1bc6 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1bc8 : 48              >            pha         ;use stack to load status
1bc9 : a901            >            lda #1     ;precharge accu
1bcb : 28              >            plp
                        
1bcc : 2c0902                   bit abs1+1  ;82 - should set N (M7) & Z / clear V
                                tst_a 1,fnz
1bcf : 08              >            php         ;save flags
1bd0 : c901            >            cmp #1     ;test result
                       >            trap_ne
1bd2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bd4 : 68              >            pla         ;load status
1bd5 : 48              >            pha
                       >            cmp_flag fnz
1bd6 : c9b2            >            cmp #(fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1bd8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bda : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1bdb : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1bdd : 48              >            pha         ;use stack to load status
1bde : a901            >            lda #1     ;precharge accu
1be0 : 28              >            plp
                        
1be1 : 2c0802                   bit abs1    ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,fnv
1be4 : 08              >            php         ;save flags
1be5 : c901            >            cmp #1     ;test result
                       >            trap_ne
1be7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1be9 : 68              >            pla         ;load status
1bea : 48              >            pha
                       >            cmp_flag fnv
1beb : c9f0            >            cmp #(fnv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1bed : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bef : 28              >            plp         ;restore status
                        
                                
                                set_a $ff,$ff
                       >            load_flag $ff
1bf0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1bf2 : 48              >            pha         ;use stack to load status
1bf3 : a9ff            >            lda #$ff     ;precharge accu
1bf5 : 28              >            plp
                        
1bf6 : 2c0b02                   bit abs1+3  ;00 - should set Z / clear  NV
                                tst_a $ff,~fnv 
1bf9 : 08              >            php         ;save flags
1bfa : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1bfc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bfe : 68              >            pla         ;load status
1bff : 48              >            pha
                       >            cmp_flag ~fnv 
1c00 : c93f            >            cmp #(~fnv |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c02 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c04 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1c05 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1c07 : 48              >            pha         ;use stack to load status
1c08 : a901            >            lda #1     ;precharge accu
1c0a : 28              >            plp
                        
1c0b : 2c0a02                   bit abs1+2  ;41 - should set V (M6) / clear NZ
                                tst_a 1,~fnz
1c0e : 08              >            php         ;save flags
1c0f : c901            >            cmp #1     ;test result
                       >            trap_ne
1c11 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c13 : 68              >            pla         ;load status
1c14 : 48              >            pha
                       >            cmp_flag ~fnz
1c15 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c17 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c19 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1c1a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1c1c : 48              >            pha         ;use stack to load status
1c1d : a901            >            lda #1     ;precharge accu
1c1f : 28              >            plp
                        
1c20 : 2c0902                   bit abs1+1  ;82 - should set N (M7) & Z / clear V
                                tst_a 1,~fv
1c23 : 08              >            php         ;save flags
1c24 : c901            >            cmp #1     ;test result
                       >            trap_ne
1c26 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c28 : 68              >            pla         ;load status
1c29 : 48              >            pha
                       >            cmp_flag ~fv
1c2a : c9bf            >            cmp #(~fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c2c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c2e : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1c2f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1c31 : 48              >            pha         ;use stack to load status
1c32 : a901            >            lda #1     ;precharge accu
1c34 : 28              >            plp
                        
1c35 : 2c0802                   bit abs1    ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,~fz
1c38 : 08              >            php         ;save flags
1c39 : c901            >            cmp #1     ;test result
                       >            trap_ne
1c3b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c3d : 68              >            pla         ;load status
1c3e : 48              >            pha
                       >            cmp_flag ~fz
1c3f : c9fd            >            cmp #(~fz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c41 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c43 : 28              >            plp         ;restore status
                        
                                next_test
1c44 : ad0002          >            lda test_case   ;previous test
1c47 : c919            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1c49 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001a =                 >test_num = test_num + 1
1c4b : a91a            >            lda #test_num   ;*** next tests' number
1c4d : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; CPX - zp / abs / #         
                                set_x $80,0
                       >            load_flag 0
1c50 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1c52 : 48              >            pha         ;use stack to load status
1c53 : a280            >            ldx #$80     ;precharge index x
1c55 : 28              >            plp
                        
1c56 : e417                     cpx zp7f
                                tst_stat fc
1c58 : 08              >            php         ;save status
1c59 : 68              >            pla         ;use stack to retrieve status
1c5a : 48              >            pha
                       >            cmp_flag fc
1c5b : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c5d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c5f : 28              >            plp         ;restore status
                        
1c60 : ca                       dex
1c61 : e417                     cpx zp7f
                                tst_stat fzc
1c63 : 08              >            php         ;save status
1c64 : 68              >            pla         ;use stack to retrieve status
1c65 : 48              >            pha
                       >            cmp_flag fzc
1c66 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c68 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c6a : 28              >            plp         ;restore status
                        
1c6b : ca                       dex
1c6c : e417                     cpx zp7f
                                tst_x $7e,fn
1c6e : 08              >            php         ;save flags
1c6f : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1c71 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c73 : 68              >            pla         ;load status
1c74 : 48              >            pha
                       >            cmp_flag fn
1c75 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c77 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c79 : 28              >            plp         ;restore status
                        
                                set_x $80,$ff
                       >            load_flag $ff
1c7a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1c7c : 48              >            pha         ;use stack to load status
1c7d : a280            >            ldx #$80     ;precharge index x
1c7f : 28              >            plp
                        
1c80 : e417                     cpx zp7f
                                tst_stat ~fnz
1c82 : 08              >            php         ;save status
1c83 : 68              >            pla         ;use stack to retrieve status
1c84 : 48              >            pha
                       >            cmp_flag ~fnz
1c85 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c87 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c89 : 28              >            plp         ;restore status
                        
1c8a : ca                       dex
1c8b : e417                     cpx zp7f
                                tst_stat ~fn
1c8d : 08              >            php         ;save status
1c8e : 68              >            pla         ;use stack to retrieve status
1c8f : 48              >            pha
                       >            cmp_flag ~fn
1c90 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c92 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c94 : 28              >            plp         ;restore status
                        
1c95 : ca                       dex
1c96 : e417                     cpx zp7f
                                tst_x $7e,~fzc
1c98 : 08              >            php         ;save flags
1c99 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1c9b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c9d : 68              >            pla         ;load status
1c9e : 48              >            pha
                       >            cmp_flag ~fzc
1c9f : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ca1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ca3 : 28              >            plp         ;restore status
                        
                        
                                set_x $80,0
                       >            load_flag 0
1ca4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1ca6 : 48              >            pha         ;use stack to load status
1ca7 : a280            >            ldx #$80     ;precharge index x
1ca9 : 28              >            plp
                        
1caa : ec0c02                   cpx abs7f
                                tst_stat fc
1cad : 08              >            php         ;save status
1cae : 68              >            pla         ;use stack to retrieve status
1caf : 48              >            pha
                       >            cmp_flag fc
1cb0 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1cb2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cb4 : 28              >            plp         ;restore status
                        
1cb5 : ca                       dex
1cb6 : ec0c02                   cpx abs7f
                                tst_stat fzc
1cb9 : 08              >            php         ;save status
1cba : 68              >            pla         ;use stack to retrieve status
1cbb : 48              >            pha
                       >            cmp_flag fzc
1cbc : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1cbe : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cc0 : 28              >            plp         ;restore status
                        
1cc1 : ca                       dex
1cc2 : ec0c02                   cpx abs7f
                                tst_x $7e,fn
1cc5 : 08              >            php         ;save flags
1cc6 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1cc8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cca : 68              >            pla         ;load status
1ccb : 48              >            pha
                       >            cmp_flag fn
1ccc : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1cce : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cd0 : 28              >            plp         ;restore status
                        
                                set_x $80,$ff
                       >            load_flag $ff
1cd1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1cd3 : 48              >            pha         ;use stack to load status
1cd4 : a280            >            ldx #$80     ;precharge index x
1cd6 : 28              >            plp
                        
1cd7 : ec0c02                   cpx abs7f
                                tst_stat ~fnz
1cda : 08              >            php         ;save status
1cdb : 68              >            pla         ;use stack to retrieve status
1cdc : 48              >            pha
                       >            cmp_flag ~fnz
1cdd : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1cdf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ce1 : 28              >            plp         ;restore status
                        
1ce2 : ca                       dex
1ce3 : ec0c02                   cpx abs7f
                                tst_stat ~fn
1ce6 : 08              >            php         ;save status
1ce7 : 68              >            pla         ;use stack to retrieve status
1ce8 : 48              >            pha
                       >            cmp_flag ~fn
1ce9 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ceb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ced : 28              >            plp         ;restore status
                        
1cee : ca                       dex
1cef : ec0c02                   cpx abs7f
                                tst_x $7e,~fzc
1cf2 : 08              >            php         ;save flags
1cf3 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1cf5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cf7 : 68              >            pla         ;load status
1cf8 : 48              >            pha
                       >            cmp_flag ~fzc
1cf9 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1cfb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cfd : 28              >            plp         ;restore status
                        
                        
                                set_x $80,0
                       >            load_flag 0
1cfe : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1d00 : 48              >            pha         ;use stack to load status
1d01 : a280            >            ldx #$80     ;precharge index x
1d03 : 28              >            plp
                        
1d04 : e07f                     cpx #$7f
                                tst_stat fc
1d06 : 08              >            php         ;save status
1d07 : 68              >            pla         ;use stack to retrieve status
1d08 : 48              >            pha
                       >            cmp_flag fc
1d09 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d0b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d0d : 28              >            plp         ;restore status
                        
1d0e : ca                       dex
1d0f : e07f                     cpx #$7f
                                tst_stat fzc
1d11 : 08              >            php         ;save status
1d12 : 68              >            pla         ;use stack to retrieve status
1d13 : 48              >            pha
                       >            cmp_flag fzc
1d14 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d16 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d18 : 28              >            plp         ;restore status
                        
1d19 : ca                       dex
1d1a : e07f                     cpx #$7f
                                tst_x $7e,fn
1d1c : 08              >            php         ;save flags
1d1d : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1d1f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d21 : 68              >            pla         ;load status
1d22 : 48              >            pha
                       >            cmp_flag fn
1d23 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d25 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d27 : 28              >            plp         ;restore status
                        
                                set_x $80,$ff
                       >            load_flag $ff
1d28 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1d2a : 48              >            pha         ;use stack to load status
1d2b : a280            >            ldx #$80     ;precharge index x
1d2d : 28              >            plp
                        
1d2e : e07f                     cpx #$7f
                                tst_stat ~fnz
1d30 : 08              >            php         ;save status
1d31 : 68              >            pla         ;use stack to retrieve status
1d32 : 48              >            pha
                       >            cmp_flag ~fnz
1d33 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d35 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d37 : 28              >            plp         ;restore status
                        
1d38 : ca                       dex
1d39 : e07f                     cpx #$7f
                                tst_stat ~fn
1d3b : 08              >            php         ;save status
1d3c : 68              >            pla         ;use stack to retrieve status
1d3d : 48              >            pha
                       >            cmp_flag ~fn
1d3e : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d40 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d42 : 28              >            plp         ;restore status
                        
1d43 : ca                       dex
1d44 : e07f                     cpx #$7f
                                tst_x $7e,~fzc
1d46 : 08              >            php         ;save flags
1d47 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1d49 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d4b : 68              >            pla         ;load status
1d4c : 48              >            pha
                       >            cmp_flag ~fzc
1d4d : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d4f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d51 : 28              >            plp         ;restore status
                        
                                next_test
1d52 : ad0002          >            lda test_case   ;previous test
1d55 : c91a            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1d57 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001b =                 >test_num = test_num + 1
1d59 : a91b            >            lda #test_num   ;*** next tests' number
1d5b : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; CPY - zp / abs / #         
                                set_y $80,0
                       >            load_flag 0
1d5e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1d60 : 48              >            pha         ;use stack to load status
1d61 : a080            >            ldy #$80     ;precharge index y
1d63 : 28              >            plp
                        
1d64 : c417                     cpy zp7f
                                tst_stat fc
1d66 : 08              >            php         ;save status
1d67 : 68              >            pla         ;use stack to retrieve status
1d68 : 48              >            pha
                       >            cmp_flag fc
1d69 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d6b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d6d : 28              >            plp         ;restore status
                        
1d6e : 88                       dey
1d6f : c417                     cpy zp7f
                                tst_stat fzc
1d71 : 08              >            php         ;save status
1d72 : 68              >            pla         ;use stack to retrieve status
1d73 : 48              >            pha
                       >            cmp_flag fzc
1d74 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d76 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d78 : 28              >            plp         ;restore status
                        
1d79 : 88                       dey
1d7a : c417                     cpy zp7f
                                tst_y $7e,fn
1d7c : 08              >            php         ;save flags
1d7d : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1d7f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d81 : 68              >            pla         ;load status
1d82 : 48              >            pha
                       >            cmp_flag fn
1d83 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d85 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d87 : 28              >            plp         ;restore status
                        
                                set_y $80,$ff
                       >            load_flag $ff
1d88 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1d8a : 48              >            pha         ;use stack to load status
1d8b : a080            >            ldy #$80     ;precharge index y
1d8d : 28              >            plp
                        
1d8e : c417                     cpy zp7f
                                tst_stat ~fnz
1d90 : 08              >            php         ;save status
1d91 : 68              >            pla         ;use stack to retrieve status
1d92 : 48              >            pha
                       >            cmp_flag ~fnz
1d93 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d95 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d97 : 28              >            plp         ;restore status
                        
1d98 : 88                       dey
1d99 : c417                     cpy zp7f
                                tst_stat ~fn
1d9b : 08              >            php         ;save status
1d9c : 68              >            pla         ;use stack to retrieve status
1d9d : 48              >            pha
                       >            cmp_flag ~fn
1d9e : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1da0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1da2 : 28              >            plp         ;restore status
                        
1da3 : 88                       dey
1da4 : c417                     cpy zp7f
                                tst_y $7e,~fzc
1da6 : 08              >            php         ;save flags
1da7 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1da9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1dab : 68              >            pla         ;load status
1dac : 48              >            pha
                       >            cmp_flag ~fzc
1dad : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1daf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1db1 : 28              >            plp         ;restore status
                        
                        
                                set_y $80,0
                       >            load_flag 0
1db2 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1db4 : 48              >            pha         ;use stack to load status
1db5 : a080            >            ldy #$80     ;precharge index y
1db7 : 28              >            plp
                        
1db8 : cc0c02                   cpy abs7f
                                tst_stat fc
1dbb : 08              >            php         ;save status
1dbc : 68              >            pla         ;use stack to retrieve status
1dbd : 48              >            pha
                       >            cmp_flag fc
1dbe : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1dc0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1dc2 : 28              >            plp         ;restore status
                        
1dc3 : 88                       dey
1dc4 : cc0c02                   cpy abs7f
                                tst_stat fzc
1dc7 : 08              >            php         ;save status
1dc8 : 68              >            pla         ;use stack to retrieve status
1dc9 : 48              >            pha
                       >            cmp_flag fzc
1dca : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1dcc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1dce : 28              >            plp         ;restore status
                        
1dcf : 88                       dey
1dd0 : cc0c02                   cpy abs7f
                                tst_y $7e,fn
1dd3 : 08              >            php         ;save flags
1dd4 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1dd6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1dd8 : 68              >            pla         ;load status
1dd9 : 48              >            pha
                       >            cmp_flag fn
1dda : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ddc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1dde : 28              >            plp         ;restore status
                        
                                set_y $80,$ff
                       >            load_flag $ff
1ddf : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1de1 : 48              >            pha         ;use stack to load status
1de2 : a080            >            ldy #$80     ;precharge index y
1de4 : 28              >            plp
                        
1de5 : cc0c02                   cpy abs7f
                                tst_stat ~fnz
1de8 : 08              >            php         ;save status
1de9 : 68              >            pla         ;use stack to retrieve status
1dea : 48              >            pha
                       >            cmp_flag ~fnz
1deb : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ded : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1def : 28              >            plp         ;restore status
                        
1df0 : 88                       dey
1df1 : cc0c02                   cpy abs7f
                                tst_stat ~fn
1df4 : 08              >            php         ;save status
1df5 : 68              >            pla         ;use stack to retrieve status
1df6 : 48              >            pha
                       >            cmp_flag ~fn
1df7 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1df9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1dfb : 28              >            plp         ;restore status
                        
1dfc : 88                       dey
1dfd : cc0c02                   cpy abs7f
                                tst_y $7e,~fzc
1e00 : 08              >            php         ;save flags
1e01 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1e03 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e05 : 68              >            pla         ;load status
1e06 : 48              >            pha
                       >            cmp_flag ~fzc
1e07 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e09 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e0b : 28              >            plp         ;restore status
                        
                        
                                set_y $80,0
                       >            load_flag 0
1e0c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1e0e : 48              >            pha         ;use stack to load status
1e0f : a080            >            ldy #$80     ;precharge index y
1e11 : 28              >            plp
                        
1e12 : c07f                     cpy #$7f
                                tst_stat fc
1e14 : 08              >            php         ;save status
1e15 : 68              >            pla         ;use stack to retrieve status
1e16 : 48              >            pha
                       >            cmp_flag fc
1e17 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e19 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e1b : 28              >            plp         ;restore status
                        
1e1c : 88                       dey
1e1d : c07f                     cpy #$7f
                                tst_stat fzc
1e1f : 08              >            php         ;save status
1e20 : 68              >            pla         ;use stack to retrieve status
1e21 : 48              >            pha
                       >            cmp_flag fzc
1e22 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e24 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e26 : 28              >            plp         ;restore status
                        
1e27 : 88                       dey
1e28 : c07f                     cpy #$7f
                                tst_y $7e,fn
1e2a : 08              >            php         ;save flags
1e2b : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1e2d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e2f : 68              >            pla         ;load status
1e30 : 48              >            pha
                       >            cmp_flag fn
1e31 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e33 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e35 : 28              >            plp         ;restore status
                        
                                set_y $80,$ff
                       >            load_flag $ff
1e36 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1e38 : 48              >            pha         ;use stack to load status
1e39 : a080            >            ldy #$80     ;precharge index y
1e3b : 28              >            plp
                        
1e3c : c07f                     cpy #$7f
                                tst_stat ~fnz
1e3e : 08              >            php         ;save status
1e3f : 68              >            pla         ;use stack to retrieve status
1e40 : 48              >            pha
                       >            cmp_flag ~fnz
1e41 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e43 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e45 : 28              >            plp         ;restore status
                        
1e46 : 88                       dey
1e47 : c07f                     cpy #$7f
                                tst_stat ~fn
1e49 : 08              >            php         ;save status
1e4a : 68              >            pla         ;use stack to retrieve status
1e4b : 48              >            pha
                       >            cmp_flag ~fn
1e4c : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e4e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e50 : 28              >            plp         ;restore status
                        
1e51 : 88                       dey
1e52 : c07f                     cpy #$7f
                                tst_y $7e,~fzc
1e54 : 08              >            php         ;save flags
1e55 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1e57 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e59 : 68              >            pla         ;load status
1e5a : 48              >            pha
                       >            cmp_flag ~fzc
1e5b : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e5d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e5f : 28              >            plp         ;restore status
                        
                                next_test
1e60 : ad0002          >            lda test_case   ;previous test
1e63 : c91b            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1e65 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001c =                 >test_num = test_num + 1
1e67 : a91c            >            lda #test_num   ;*** next tests' number
1e69 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; CMP - zp / abs / #         
                                set_a $80,0
                       >            load_flag 0
1e6c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1e6e : 48              >            pha         ;use stack to load status
1e6f : a980            >            lda #$80     ;precharge accu
1e71 : 28              >            plp
                        
1e72 : c517                     cmp zp7f
                                tst_a $80,fc
1e74 : 08              >            php         ;save flags
1e75 : c980            >            cmp #$80     ;test result
                       >            trap_ne
1e77 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e79 : 68              >            pla         ;load status
1e7a : 48              >            pha
                       >            cmp_flag fc
1e7b : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e7d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e7f : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
1e80 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1e82 : 48              >            pha         ;use stack to load status
1e83 : a97f            >            lda #$7f     ;precharge accu
1e85 : 28              >            plp
                        
1e86 : c517                     cmp zp7f
                                tst_a $7f,fzc
1e88 : 08              >            php         ;save flags
1e89 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1e8b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e8d : 68              >            pla         ;load status
1e8e : 48              >            pha
                       >            cmp_flag fzc
1e8f : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e91 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e93 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
1e94 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1e96 : 48              >            pha         ;use stack to load status
1e97 : a97e            >            lda #$7e     ;precharge accu
1e99 : 28              >            plp
                        
1e9a : c517                     cmp zp7f
                                tst_a $7e,fn
1e9c : 08              >            php         ;save flags
1e9d : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1e9f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ea1 : 68              >            pla         ;load status
1ea2 : 48              >            pha
                       >            cmp_flag fn
1ea3 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ea5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ea7 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
1ea8 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1eaa : 48              >            pha         ;use stack to load status
1eab : a980            >            lda #$80     ;precharge accu
1ead : 28              >            plp
                        
1eae : c517                     cmp zp7f
                                tst_a $80,~fnz
1eb0 : 08              >            php         ;save flags
1eb1 : c980            >            cmp #$80     ;test result
                       >            trap_ne
1eb3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1eb5 : 68              >            pla         ;load status
1eb6 : 48              >            pha
                       >            cmp_flag ~fnz
1eb7 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1eb9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ebb : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
1ebc : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1ebe : 48              >            pha         ;use stack to load status
1ebf : a97f            >            lda #$7f     ;precharge accu
1ec1 : 28              >            plp
                        
1ec2 : c517                     cmp zp7f
                                tst_a $7f,~fn
1ec4 : 08              >            php         ;save flags
1ec5 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1ec7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ec9 : 68              >            pla         ;load status
1eca : 48              >            pha
                       >            cmp_flag ~fn
1ecb : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ecd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ecf : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
1ed0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1ed2 : 48              >            pha         ;use stack to load status
1ed3 : a97e            >            lda #$7e     ;precharge accu
1ed5 : 28              >            plp
                        
1ed6 : c517                     cmp zp7f
                                tst_a $7e,~fzc
1ed8 : 08              >            php         ;save flags
1ed9 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1edb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1edd : 68              >            pla         ;load status
1ede : 48              >            pha
                       >            cmp_flag ~fzc
1edf : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ee1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ee3 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
1ee4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1ee6 : 48              >            pha         ;use stack to load status
1ee7 : a980            >            lda #$80     ;precharge accu
1ee9 : 28              >            plp
                        
1eea : cd0c02                   cmp abs7f
                                tst_a $80,fc
1eed : 08              >            php         ;save flags
1eee : c980            >            cmp #$80     ;test result
                       >            trap_ne
1ef0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ef2 : 68              >            pla         ;load status
1ef3 : 48              >            pha
                       >            cmp_flag fc
1ef4 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ef6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ef8 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
1ef9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1efb : 48              >            pha         ;use stack to load status
1efc : a97f            >            lda #$7f     ;precharge accu
1efe : 28              >            plp
                        
1eff : cd0c02                   cmp abs7f
                                tst_a $7f,fzc
1f02 : 08              >            php         ;save flags
1f03 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1f05 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f07 : 68              >            pla         ;load status
1f08 : 48              >            pha
                       >            cmp_flag fzc
1f09 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f0b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f0d : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
1f0e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1f10 : 48              >            pha         ;use stack to load status
1f11 : a97e            >            lda #$7e     ;precharge accu
1f13 : 28              >            plp
                        
1f14 : cd0c02                   cmp abs7f
                                tst_a $7e,fn
1f17 : 08              >            php         ;save flags
1f18 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1f1a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f1c : 68              >            pla         ;load status
1f1d : 48              >            pha
                       >            cmp_flag fn
1f1e : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f20 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f22 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
1f23 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1f25 : 48              >            pha         ;use stack to load status
1f26 : a980            >            lda #$80     ;precharge accu
1f28 : 28              >            plp
                        
1f29 : cd0c02                   cmp abs7f
                                tst_a $80,~fnz
1f2c : 08              >            php         ;save flags
1f2d : c980            >            cmp #$80     ;test result
                       >            trap_ne
1f2f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f31 : 68              >            pla         ;load status
1f32 : 48              >            pha
                       >            cmp_flag ~fnz
1f33 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f35 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f37 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
1f38 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1f3a : 48              >            pha         ;use stack to load status
1f3b : a97f            >            lda #$7f     ;precharge accu
1f3d : 28              >            plp
                        
1f3e : cd0c02                   cmp abs7f
                                tst_a $7f,~fn
1f41 : 08              >            php         ;save flags
1f42 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1f44 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f46 : 68              >            pla         ;load status
1f47 : 48              >            pha
                       >            cmp_flag ~fn
1f48 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f4a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f4c : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
1f4d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1f4f : 48              >            pha         ;use stack to load status
1f50 : a97e            >            lda #$7e     ;precharge accu
1f52 : 28              >            plp
                        
1f53 : cd0c02                   cmp abs7f
                                tst_a $7e,~fzc
1f56 : 08              >            php         ;save flags
1f57 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1f59 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f5b : 68              >            pla         ;load status
1f5c : 48              >            pha
                       >            cmp_flag ~fzc
1f5d : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f5f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f61 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
1f62 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1f64 : 48              >            pha         ;use stack to load status
1f65 : a980            >            lda #$80     ;precharge accu
1f67 : 28              >            plp
                        
1f68 : c97f                     cmp #$7f
                                tst_a $80,fc
1f6a : 08              >            php         ;save flags
1f6b : c980            >            cmp #$80     ;test result
                       >            trap_ne
1f6d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f6f : 68              >            pla         ;load status
1f70 : 48              >            pha
                       >            cmp_flag fc
1f71 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f73 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f75 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
1f76 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1f78 : 48              >            pha         ;use stack to load status
1f79 : a97f            >            lda #$7f     ;precharge accu
1f7b : 28              >            plp
                        
1f7c : c97f                     cmp #$7f
                                tst_a $7f,fzc
1f7e : 08              >            php         ;save flags
1f7f : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1f81 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f83 : 68              >            pla         ;load status
1f84 : 48              >            pha
                       >            cmp_flag fzc
1f85 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f87 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f89 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
1f8a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1f8c : 48              >            pha         ;use stack to load status
1f8d : a97e            >            lda #$7e     ;precharge accu
1f8f : 28              >            plp
                        
1f90 : c97f                     cmp #$7f
                                tst_a $7e,fn
1f92 : 08              >            php         ;save flags
1f93 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1f95 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f97 : 68              >            pla         ;load status
1f98 : 48              >            pha
                       >            cmp_flag fn
1f99 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f9b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f9d : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
1f9e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1fa0 : 48              >            pha         ;use stack to load status
1fa1 : a980            >            lda #$80     ;precharge accu
1fa3 : 28              >            plp
                        
1fa4 : c97f                     cmp #$7f
                                tst_a $80,~fnz
1fa6 : 08              >            php         ;save flags
1fa7 : c980            >            cmp #$80     ;test result
                       >            trap_ne
1fa9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fab : 68              >            pla         ;load status
1fac : 48              >            pha
                       >            cmp_flag ~fnz
1fad : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1faf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fb1 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
1fb2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1fb4 : 48              >            pha         ;use stack to load status
1fb5 : a97f            >            lda #$7f     ;precharge accu
1fb7 : 28              >            plp
                        
1fb8 : c97f                     cmp #$7f
                                tst_a $7f,~fn
1fba : 08              >            php         ;save flags
1fbb : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1fbd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fbf : 68              >            pla         ;load status
1fc0 : 48              >            pha
                       >            cmp_flag ~fn
1fc1 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1fc3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fc5 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
1fc6 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1fc8 : 48              >            pha         ;use stack to load status
1fc9 : a97e            >            lda #$7e     ;precharge accu
1fcb : 28              >            plp
                        
1fcc : c97f                     cmp #$7f
                                tst_a $7e,~fzc
1fce : 08              >            php         ;save flags
1fcf : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1fd1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fd3 : 68              >            pla         ;load status
1fd4 : 48              >            pha
                       >            cmp_flag ~fzc
1fd5 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1fd7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fd9 : 28              >            plp         ;restore status
                        
                        
1fda : a204                     ldx #4          ;with indexing by X
                                set_a $80,0
                       >            load_flag 0
1fdc : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1fde : 48              >            pha         ;use stack to load status
1fdf : a980            >            lda #$80     ;precharge accu
1fe1 : 28              >            plp
                        
1fe2 : d513                     cmp zp1,x
                                tst_a $80,fc
1fe4 : 08              >            php         ;save flags
1fe5 : c980            >            cmp #$80     ;test result
                       >            trap_ne
1fe7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fe9 : 68              >            pla         ;load status
1fea : 48              >            pha
                       >            cmp_flag fc
1feb : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1fed : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fef : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
1ff0 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1ff2 : 48              >            pha         ;use stack to load status
1ff3 : a97f            >            lda #$7f     ;precharge accu
1ff5 : 28              >            plp
                        
1ff6 : d513                     cmp zp1,x
                                tst_a $7f,fzc
1ff8 : 08              >            php         ;save flags
1ff9 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1ffb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ffd : 68              >            pla         ;load status
1ffe : 48              >            pha
                       >            cmp_flag fzc
1fff : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2001 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2003 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
2004 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2006 : 48              >            pha         ;use stack to load status
2007 : a97e            >            lda #$7e     ;precharge accu
2009 : 28              >            plp
                        
200a : d513                     cmp zp1,x
                                tst_a $7e,fn
200c : 08              >            php         ;save flags
200d : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
200f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2011 : 68              >            pla         ;load status
2012 : 48              >            pha
                       >            cmp_flag fn
2013 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2015 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2017 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
2018 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
201a : 48              >            pha         ;use stack to load status
201b : a980            >            lda #$80     ;precharge accu
201d : 28              >            plp
                        
201e : d513                     cmp zp1,x
                                tst_a $80,~fnz
2020 : 08              >            php         ;save flags
2021 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2023 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2025 : 68              >            pla         ;load status
2026 : 48              >            pha
                       >            cmp_flag ~fnz
2027 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2029 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
202b : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
202c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
202e : 48              >            pha         ;use stack to load status
202f : a97f            >            lda #$7f     ;precharge accu
2031 : 28              >            plp
                        
2032 : d513                     cmp zp1,x
                                tst_a $7f,~fn
2034 : 08              >            php         ;save flags
2035 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2037 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2039 : 68              >            pla         ;load status
203a : 48              >            pha
                       >            cmp_flag ~fn
203b : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
203d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
203f : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
2040 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2042 : 48              >            pha         ;use stack to load status
2043 : a97e            >            lda #$7e     ;precharge accu
2045 : 28              >            plp
                        
2046 : d513                     cmp zp1,x
                                tst_a $7e,~fzc
2048 : 08              >            php         ;save flags
2049 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
204b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
204d : 68              >            pla         ;load status
204e : 48              >            pha
                       >            cmp_flag ~fzc
204f : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2051 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2053 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
2054 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2056 : 48              >            pha         ;use stack to load status
2057 : a980            >            lda #$80     ;precharge accu
2059 : 28              >            plp
                        
205a : dd0802                   cmp abs1,x
                                tst_a $80,fc
205d : 08              >            php         ;save flags
205e : c980            >            cmp #$80     ;test result
                       >            trap_ne
2060 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2062 : 68              >            pla         ;load status
2063 : 48              >            pha
                       >            cmp_flag fc
2064 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2066 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2068 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
2069 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
206b : 48              >            pha         ;use stack to load status
206c : a97f            >            lda #$7f     ;precharge accu
206e : 28              >            plp
                        
206f : dd0802                   cmp abs1,x
                                tst_a $7f,fzc
2072 : 08              >            php         ;save flags
2073 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2075 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2077 : 68              >            pla         ;load status
2078 : 48              >            pha
                       >            cmp_flag fzc
2079 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
207b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
207d : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
207e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2080 : 48              >            pha         ;use stack to load status
2081 : a97e            >            lda #$7e     ;precharge accu
2083 : 28              >            plp
                        
2084 : dd0802                   cmp abs1,x
                                tst_a $7e,fn
2087 : 08              >            php         ;save flags
2088 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
208a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
208c : 68              >            pla         ;load status
208d : 48              >            pha
                       >            cmp_flag fn
208e : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2090 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2092 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
2093 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2095 : 48              >            pha         ;use stack to load status
2096 : a980            >            lda #$80     ;precharge accu
2098 : 28              >            plp
                        
2099 : dd0802                   cmp abs1,x
                                tst_a $80,~fnz
209c : 08              >            php         ;save flags
209d : c980            >            cmp #$80     ;test result
                       >            trap_ne
209f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20a1 : 68              >            pla         ;load status
20a2 : 48              >            pha
                       >            cmp_flag ~fnz
20a3 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
20a5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20a7 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
20a8 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
20aa : 48              >            pha         ;use stack to load status
20ab : a97f            >            lda #$7f     ;precharge accu
20ad : 28              >            plp
                        
20ae : dd0802                   cmp abs1,x
                                tst_a $7f,~fn
20b1 : 08              >            php         ;save flags
20b2 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
20b4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20b6 : 68              >            pla         ;load status
20b7 : 48              >            pha
                       >            cmp_flag ~fn
20b8 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
20ba : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20bc : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
20bd : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
20bf : 48              >            pha         ;use stack to load status
20c0 : a97e            >            lda #$7e     ;precharge accu
20c2 : 28              >            plp
                        
20c3 : dd0802                   cmp abs1,x
                                tst_a $7e,~fzc
20c6 : 08              >            php         ;save flags
20c7 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
20c9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20cb : 68              >            pla         ;load status
20cc : 48              >            pha
                       >            cmp_flag ~fzc
20cd : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
20cf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20d1 : 28              >            plp         ;restore status
                        
                        
20d2 : a004                     ldy #4          ;with indexing by Y
20d4 : a208                     ldx #8          ;with indexed indirect
                                set_a $80,0
                       >            load_flag 0
20d6 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
20d8 : 48              >            pha         ;use stack to load status
20d9 : a980            >            lda #$80     ;precharge accu
20db : 28              >            plp
                        
20dc : d90802                   cmp abs1,y
                                tst_a $80,fc
20df : 08              >            php         ;save flags
20e0 : c980            >            cmp #$80     ;test result
                       >            trap_ne
20e2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20e4 : 68              >            pla         ;load status
20e5 : 48              >            pha
                       >            cmp_flag fc
20e6 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
20e8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20ea : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
20eb : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
20ed : 48              >            pha         ;use stack to load status
20ee : a97f            >            lda #$7f     ;precharge accu
20f0 : 28              >            plp
                        
20f1 : d90802                   cmp abs1,y
                                tst_a $7f,fzc
20f4 : 08              >            php         ;save flags
20f5 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
20f7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20f9 : 68              >            pla         ;load status
20fa : 48              >            pha
                       >            cmp_flag fzc
20fb : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
20fd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20ff : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
2100 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2102 : 48              >            pha         ;use stack to load status
2103 : a97e            >            lda #$7e     ;precharge accu
2105 : 28              >            plp
                        
2106 : d90802                   cmp abs1,y
                                tst_a $7e,fn
2109 : 08              >            php         ;save flags
210a : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
210c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
210e : 68              >            pla         ;load status
210f : 48              >            pha
                       >            cmp_flag fn
2110 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2112 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2114 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
2115 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2117 : 48              >            pha         ;use stack to load status
2118 : a980            >            lda #$80     ;precharge accu
211a : 28              >            plp
                        
211b : d90802                   cmp abs1,y
                                tst_a $80,~fnz
211e : 08              >            php         ;save flags
211f : c980            >            cmp #$80     ;test result
                       >            trap_ne
2121 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2123 : 68              >            pla         ;load status
2124 : 48              >            pha
                       >            cmp_flag ~fnz
2125 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2127 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2129 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
212a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
212c : 48              >            pha         ;use stack to load status
212d : a97f            >            lda #$7f     ;precharge accu
212f : 28              >            plp
                        
2130 : d90802                   cmp abs1,y
                                tst_a $7f,~fn
2133 : 08              >            php         ;save flags
2134 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2136 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2138 : 68              >            pla         ;load status
2139 : 48              >            pha
                       >            cmp_flag ~fn
213a : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
213c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
213e : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
213f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2141 : 48              >            pha         ;use stack to load status
2142 : a97e            >            lda #$7e     ;precharge accu
2144 : 28              >            plp
                        
2145 : d90802                   cmp abs1,y
                                tst_a $7e,~fzc
2148 : 08              >            php         ;save flags
2149 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
214b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
214d : 68              >            pla         ;load status
214e : 48              >            pha
                       >            cmp_flag ~fzc
214f : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2151 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2153 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
2154 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2156 : 48              >            pha         ;use stack to load status
2157 : a980            >            lda #$80     ;precharge accu
2159 : 28              >            plp
                        
215a : c124                     cmp (ind1,x)
                                tst_a $80,fc
215c : 08              >            php         ;save flags
215d : c980            >            cmp #$80     ;test result
                       >            trap_ne
215f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2161 : 68              >            pla         ;load status
2162 : 48              >            pha
                       >            cmp_flag fc
2163 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2165 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2167 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
2168 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
216a : 48              >            pha         ;use stack to load status
216b : a97f            >            lda #$7f     ;precharge accu
216d : 28              >            plp
                        
216e : c124                     cmp (ind1,x)
                                tst_a $7f,fzc
2170 : 08              >            php         ;save flags
2171 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2173 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2175 : 68              >            pla         ;load status
2176 : 48              >            pha
                       >            cmp_flag fzc
2177 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2179 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
217b : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
217c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
217e : 48              >            pha         ;use stack to load status
217f : a97e            >            lda #$7e     ;precharge accu
2181 : 28              >            plp
                        
2182 : c124                     cmp (ind1,x)
                                tst_a $7e,fn
2184 : 08              >            php         ;save flags
2185 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2187 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2189 : 68              >            pla         ;load status
218a : 48              >            pha
                       >            cmp_flag fn
218b : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
218d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
218f : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
2190 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2192 : 48              >            pha         ;use stack to load status
2193 : a980            >            lda #$80     ;precharge accu
2195 : 28              >            plp
                        
2196 : c124                     cmp (ind1,x)
                                tst_a $80,~fnz
2198 : 08              >            php         ;save flags
2199 : c980            >            cmp #$80     ;test result
                       >            trap_ne
219b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
219d : 68              >            pla         ;load status
219e : 48              >            pha
                       >            cmp_flag ~fnz
219f : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
21a1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21a3 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
21a4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
21a6 : 48              >            pha         ;use stack to load status
21a7 : a97f            >            lda #$7f     ;precharge accu
21a9 : 28              >            plp
                        
21aa : c124                     cmp (ind1,x)
                                tst_a $7f,~fn
21ac : 08              >            php         ;save flags
21ad : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
21af : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21b1 : 68              >            pla         ;load status
21b2 : 48              >            pha
                       >            cmp_flag ~fn
21b3 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
21b5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21b7 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
21b8 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
21ba : 48              >            pha         ;use stack to load status
21bb : a97e            >            lda #$7e     ;precharge accu
21bd : 28              >            plp
                        
21be : c124                     cmp (ind1,x)
                                tst_a $7e,~fzc
21c0 : 08              >            php         ;save flags
21c1 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
21c3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21c5 : 68              >            pla         ;load status
21c6 : 48              >            pha
                       >            cmp_flag ~fzc
21c7 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
21c9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21cb : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
21cc : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
21ce : 48              >            pha         ;use stack to load status
21cf : a980            >            lda #$80     ;precharge accu
21d1 : 28              >            plp
                        
21d2 : d124                     cmp (ind1),y
                                tst_a $80,fc
21d4 : 08              >            php         ;save flags
21d5 : c980            >            cmp #$80     ;test result
                       >            trap_ne
21d7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21d9 : 68              >            pla         ;load status
21da : 48              >            pha
                       >            cmp_flag fc
21db : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
21dd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21df : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
21e0 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
21e2 : 48              >            pha         ;use stack to load status
21e3 : a97f            >            lda #$7f     ;precharge accu
21e5 : 28              >            plp
                        
21e6 : d124                     cmp (ind1),y
                                tst_a $7f,fzc
21e8 : 08              >            php         ;save flags
21e9 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
21eb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21ed : 68              >            pla         ;load status
21ee : 48              >            pha
                       >            cmp_flag fzc
21ef : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
21f1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21f3 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
21f4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
21f6 : 48              >            pha         ;use stack to load status
21f7 : a97e            >            lda #$7e     ;precharge accu
21f9 : 28              >            plp
                        
21fa : d124                     cmp (ind1),y
                                tst_a $7e,fn
21fc : 08              >            php         ;save flags
21fd : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
21ff : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2201 : 68              >            pla         ;load status
2202 : 48              >            pha
                       >            cmp_flag fn
2203 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2205 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2207 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
2208 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
220a : 48              >            pha         ;use stack to load status
220b : a980            >            lda #$80     ;precharge accu
220d : 28              >            plp
                        
220e : d124                     cmp (ind1),y
                                tst_a $80,~fnz
2210 : 08              >            php         ;save flags
2211 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2213 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2215 : 68              >            pla         ;load status
2216 : 48              >            pha
                       >            cmp_flag ~fnz
2217 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2219 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
221b : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
221c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
221e : 48              >            pha         ;use stack to load status
221f : a97f            >            lda #$7f     ;precharge accu
2221 : 28              >            plp
                        
2222 : d124                     cmp (ind1),y
                                tst_a $7f,~fn
2224 : 08              >            php         ;save flags
2225 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2227 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2229 : 68              >            pla         ;load status
222a : 48              >            pha
                       >            cmp_flag ~fn
222b : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
222d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
222f : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
2230 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2232 : 48              >            pha         ;use stack to load status
2233 : a97e            >            lda #$7e     ;precharge accu
2235 : 28              >            plp
                        
2236 : d124                     cmp (ind1),y
                                tst_a $7e,~fzc
2238 : 08              >            php         ;save flags
2239 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
223b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
223d : 68              >            pla         ;load status
223e : 48              >            pha
                       >            cmp_flag ~fzc
223f : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2241 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2243 : 28              >            plp         ;restore status
                        
                                next_test
2244 : ad0002          >            lda test_case   ;previous test
2247 : c91c            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2249 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001d =                 >test_num = test_num + 1
224b : a91d            >            lda #test_num   ;*** next tests' number
224d : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing shifts - ASL LSR ROL ROR all addressing modes
                        ; shifts - accumulator
2250 : a203                     ldx #3
2252 :                  tasl
                                set_ax zp1,0
                       >            load_flag 0
2252 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2254 : 48              >            pha         ;use stack to load status
2255 : b513            >            lda zp1,x    ;precharge accu
2257 : 28              >            plp
                        
2258 : 0a                       asl a
                                tst_ax rASL,fASL,0
2259 : 08              >            php         ;save flags
225a : dd1102          >            cmp rASL,x    ;test result
                       >            trap_ne
225d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
225f : 68              >            pla         ;load status
                       >            eor_flag 0
2260 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2262 : dd2102          >            cmp fASL,x    ;test flags
                       >            trap_ne     ;
2265 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2267 : ca                       dex
2268 : 10e8                     bpl tasl
226a : a203                     ldx #3
226c :                  tasl1
                                set_ax zp1,$ff
                       >            load_flag $ff
226c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
226e : 48              >            pha         ;use stack to load status
226f : b513            >            lda zp1,x    ;precharge accu
2271 : 28              >            plp
                        
2272 : 0a                       asl a
                                tst_ax rASL,fASL,$ff-fnzc
2273 : 08              >            php         ;save flags
2274 : dd1102          >            cmp rASL,x    ;test result
                       >            trap_ne
2277 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2279 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
227a : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
227c : dd2102          >            cmp fASL,x    ;test flags
                       >            trap_ne     ;
227f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2281 : ca                       dex
2282 : 10e8                     bpl tasl1
                        
2284 : a203                     ldx #3
2286 :                  tlsr
                                set_ax zp1,0
                       >            load_flag 0
2286 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2288 : 48              >            pha         ;use stack to load status
2289 : b513            >            lda zp1,x    ;precharge accu
228b : 28              >            plp
                        
228c : 4a                       lsr a
                                tst_ax rLSR,fLSR,0
228d : 08              >            php         ;save flags
228e : dd1902          >            cmp rLSR,x    ;test result
                       >            trap_ne
2291 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2293 : 68              >            pla         ;load status
                       >            eor_flag 0
2294 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2296 : dd2902          >            cmp fLSR,x    ;test flags
                       >            trap_ne     ;
2299 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
229b : ca                       dex
229c : 10e8                     bpl tlsr
229e : a203                     ldx #3
22a0 :                  tlsr1
                                set_ax zp1,$ff
                       >            load_flag $ff
22a0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
22a2 : 48              >            pha         ;use stack to load status
22a3 : b513            >            lda zp1,x    ;precharge accu
22a5 : 28              >            plp
                        
22a6 : 4a                       lsr a
                                tst_ax rLSR,fLSR,$ff-fnzc
22a7 : 08              >            php         ;save flags
22a8 : dd1902          >            cmp rLSR,x    ;test result
                       >            trap_ne
22ab : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22ad : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
22ae : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
22b0 : dd2902          >            cmp fLSR,x    ;test flags
                       >            trap_ne     ;
22b3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
22b5 : ca                       dex
22b6 : 10e8                     bpl tlsr1
                        
22b8 : a203                     ldx #3
22ba :                  trol
                                set_ax zp1,0
                       >            load_flag 0
22ba : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
22bc : 48              >            pha         ;use stack to load status
22bd : b513            >            lda zp1,x    ;precharge accu
22bf : 28              >            plp
                        
22c0 : 2a                       rol a
                                tst_ax rROL,fROL,0
22c1 : 08              >            php         ;save flags
22c2 : dd1102          >            cmp rROL,x    ;test result
                       >            trap_ne
22c5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22c7 : 68              >            pla         ;load status
                       >            eor_flag 0
22c8 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
22ca : dd2102          >            cmp fROL,x    ;test flags
                       >            trap_ne     ;
22cd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
22cf : ca                       dex
22d0 : 10e8                     bpl trol
22d2 : a203                     ldx #3
22d4 :                  trol1
                                set_ax zp1,$ff-fc
                       >            load_flag $ff-fc
22d4 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
22d6 : 48              >            pha         ;use stack to load status
22d7 : b513            >            lda zp1,x    ;precharge accu
22d9 : 28              >            plp
                        
22da : 2a                       rol a
                                tst_ax rROL,fROL,$ff-fnzc
22db : 08              >            php         ;save flags
22dc : dd1102          >            cmp rROL,x    ;test result
                       >            trap_ne
22df : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22e1 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
22e2 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
22e4 : dd2102          >            cmp fROL,x    ;test flags
                       >            trap_ne     ;
22e7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
22e9 : ca                       dex
22ea : 10e8                     bpl trol1
                        
22ec : a203                     ldx #3
22ee :                  trolc
                                set_ax zp1,fc
                       >            load_flag fc
22ee : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
22f0 : 48              >            pha         ;use stack to load status
22f1 : b513            >            lda zp1,x    ;precharge accu
22f3 : 28              >            plp
                        
22f4 : 2a                       rol a
                                tst_ax rROLc,fROLc,0
22f5 : 08              >            php         ;save flags
22f6 : dd1502          >            cmp rROLc,x    ;test result
                       >            trap_ne
22f9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22fb : 68              >            pla         ;load status
                       >            eor_flag 0
22fc : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
22fe : dd2502          >            cmp fROLc,x    ;test flags
                       >            trap_ne     ;
2301 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2303 : ca                       dex
2304 : 10e8                     bpl trolc
2306 : a203                     ldx #3
2308 :                  trolc1
                                set_ax zp1,$ff
                       >            load_flag $ff
2308 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
230a : 48              >            pha         ;use stack to load status
230b : b513            >            lda zp1,x    ;precharge accu
230d : 28              >            plp
                        
230e : 2a                       rol a
                                tst_ax rROLc,fROLc,$ff-fnzc
230f : 08              >            php         ;save flags
2310 : dd1502          >            cmp rROLc,x    ;test result
                       >            trap_ne
2313 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2315 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2316 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2318 : dd2502          >            cmp fROLc,x    ;test flags
                       >            trap_ne     ;
231b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
231d : ca                       dex
231e : 10e8                     bpl trolc1
                        
2320 : a203                     ldx #3
2322 :                  tror
                                set_ax zp1,0
                       >            load_flag 0
2322 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2324 : 48              >            pha         ;use stack to load status
2325 : b513            >            lda zp1,x    ;precharge accu
2327 : 28              >            plp
                        
2328 : 6a                       ror a
                                tst_ax rROR,fROR,0
2329 : 08              >            php         ;save flags
232a : dd1902          >            cmp rROR,x    ;test result
                       >            trap_ne
232d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
232f : 68              >            pla         ;load status
                       >            eor_flag 0
2330 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2332 : dd2902          >            cmp fROR,x    ;test flags
                       >            trap_ne     ;
2335 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2337 : ca                       dex
2338 : 10e8                     bpl tror
233a : a203                     ldx #3
233c :                  tror1
                                set_ax zp1,$ff-fc
                       >            load_flag $ff-fc
233c : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
233e : 48              >            pha         ;use stack to load status
233f : b513            >            lda zp1,x    ;precharge accu
2341 : 28              >            plp
                        
2342 : 6a                       ror a
                                tst_ax rROR,fROR,$ff-fnzc
2343 : 08              >            php         ;save flags
2344 : dd1902          >            cmp rROR,x    ;test result
                       >            trap_ne
2347 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2349 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
234a : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
234c : dd2902          >            cmp fROR,x    ;test flags
                       >            trap_ne     ;
234f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2351 : ca                       dex
2352 : 10e8                     bpl tror1
                        
2354 : a203                     ldx #3
2356 :                  trorc
                                set_ax zp1,fc
                       >            load_flag fc
2356 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
2358 : 48              >            pha         ;use stack to load status
2359 : b513            >            lda zp1,x    ;precharge accu
235b : 28              >            plp
                        
235c : 6a                       ror a
                                tst_ax rRORc,fRORc,0
235d : 08              >            php         ;save flags
235e : dd1d02          >            cmp rRORc,x    ;test result
                       >            trap_ne
2361 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2363 : 68              >            pla         ;load status
                       >            eor_flag 0
2364 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2366 : dd2d02          >            cmp fRORc,x    ;test flags
                       >            trap_ne     ;
2369 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
236b : ca                       dex
236c : 10e8                     bpl trorc
236e : a203                     ldx #3
2370 :                  trorc1
                                set_ax zp1,$ff
                       >            load_flag $ff
2370 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2372 : 48              >            pha         ;use stack to load status
2373 : b513            >            lda zp1,x    ;precharge accu
2375 : 28              >            plp
                        
2376 : 6a                       ror a
                                tst_ax rRORc,fRORc,$ff-fnzc
2377 : 08              >            php         ;save flags
2378 : dd1d02          >            cmp rRORc,x    ;test result
                       >            trap_ne
237b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
237d : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
237e : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2380 : dd2d02          >            cmp fRORc,x    ;test flags
                       >            trap_ne     ;
2383 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2385 : ca                       dex
2386 : 10e8                     bpl trorc1
                                next_test
2388 : ad0002          >            lda test_case   ;previous test
238b : c91d            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
238d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001e =                 >test_num = test_num + 1
238f : a91e            >            lda #test_num   ;*** next tests' number
2391 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - zeropage
2394 : a203                     ldx #3
2396 :                  tasl2
                                set_z zp1,0
                       >            load_flag 0
2396 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2398 : 48              >            pha         ;use stack to load status
2399 : b513            >            lda zp1,x    ;load to zeropage
239b : 850c            >            sta zpt
239d : 28              >            plp
                        
239e : 060c                     asl zpt
                                tst_z rASL,fASL,0
23a0 : 08              >            php         ;save flags
23a1 : a50c            >            lda zpt
23a3 : dd1102          >            cmp rASL,x    ;test result
                       >            trap_ne
23a6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
23a8 : 68              >            pla         ;load status
                       >            eor_flag 0
23a9 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
23ab : dd2102          >            cmp fASL,x    ;test flags
                       >            trap_ne
23ae : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
23b0 : ca                       dex
23b1 : 10e3                     bpl tasl2
23b3 : a203                     ldx #3
23b5 :                  tasl3
                                set_z zp1,$ff
                       >            load_flag $ff
23b5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
23b7 : 48              >            pha         ;use stack to load status
23b8 : b513            >            lda zp1,x    ;load to zeropage
23ba : 850c            >            sta zpt
23bc : 28              >            plp
                        
23bd : 060c                     asl zpt
                                tst_z rASL,fASL,$ff-fnzc
23bf : 08              >            php         ;save flags
23c0 : a50c            >            lda zpt
23c2 : dd1102          >            cmp rASL,x    ;test result
                       >            trap_ne
23c5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
23c7 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
23c8 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
23ca : dd2102          >            cmp fASL,x    ;test flags
                       >            trap_ne
23cd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
23cf : ca                       dex
23d0 : 10e3                     bpl tasl3
                        
23d2 : a203                     ldx #3
23d4 :                  tlsr2
                                set_z zp1,0
                       >            load_flag 0
23d4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
23d6 : 48              >            pha         ;use stack to load status
23d7 : b513            >            lda zp1,x    ;load to zeropage
23d9 : 850c            >            sta zpt
23db : 28              >            plp
                        
23dc : 460c                     lsr zpt
                                tst_z rLSR,fLSR,0
23de : 08              >            php         ;save flags
23df : a50c            >            lda zpt
23e1 : dd1902          >            cmp rLSR,x    ;test result
                       >            trap_ne
23e4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
23e6 : 68              >            pla         ;load status
                       >            eor_flag 0
23e7 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
23e9 : dd2902          >            cmp fLSR,x    ;test flags
                       >            trap_ne
23ec : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
23ee : ca                       dex
23ef : 10e3                     bpl tlsr2
23f1 : a203                     ldx #3
23f3 :                  tlsr3
                                set_z zp1,$ff
                       >            load_flag $ff
23f3 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
23f5 : 48              >            pha         ;use stack to load status
23f6 : b513            >            lda zp1,x    ;load to zeropage
23f8 : 850c            >            sta zpt
23fa : 28              >            plp
                        
23fb : 460c                     lsr zpt
                                tst_z rLSR,fLSR,$ff-fnzc
23fd : 08              >            php         ;save flags
23fe : a50c            >            lda zpt
2400 : dd1902          >            cmp rLSR,x    ;test result
                       >            trap_ne
2403 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2405 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2406 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2408 : dd2902          >            cmp fLSR,x    ;test flags
                       >            trap_ne
240b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
240d : ca                       dex
240e : 10e3                     bpl tlsr3
                        
2410 : a203                     ldx #3
2412 :                  trol2
                                set_z zp1,0
                       >            load_flag 0
2412 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2414 : 48              >            pha         ;use stack to load status
2415 : b513            >            lda zp1,x    ;load to zeropage
2417 : 850c            >            sta zpt
2419 : 28              >            plp
                        
241a : 260c                     rol zpt
                                tst_z rROL,fROL,0
241c : 08              >            php         ;save flags
241d : a50c            >            lda zpt
241f : dd1102          >            cmp rROL,x    ;test result
                       >            trap_ne
2422 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2424 : 68              >            pla         ;load status
                       >            eor_flag 0
2425 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2427 : dd2102          >            cmp fROL,x    ;test flags
                       >            trap_ne
242a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
242c : ca                       dex
242d : 10e3                     bpl trol2
242f : a203                     ldx #3
2431 :                  trol3
                                set_z zp1,$ff-fc
                       >            load_flag $ff-fc
2431 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
2433 : 48              >            pha         ;use stack to load status
2434 : b513            >            lda zp1,x    ;load to zeropage
2436 : 850c            >            sta zpt
2438 : 28              >            plp
                        
2439 : 260c                     rol zpt
                                tst_z rROL,fROL,$ff-fnzc
243b : 08              >            php         ;save flags
243c : a50c            >            lda zpt
243e : dd1102          >            cmp rROL,x    ;test result
                       >            trap_ne
2441 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2443 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2444 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2446 : dd2102          >            cmp fROL,x    ;test flags
                       >            trap_ne
2449 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
244b : ca                       dex
244c : 10e3                     bpl trol3
                        
244e : a203                     ldx #3
2450 :                  trolc2
                                set_z zp1,fc
                       >            load_flag fc
2450 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
2452 : 48              >            pha         ;use stack to load status
2453 : b513            >            lda zp1,x    ;load to zeropage
2455 : 850c            >            sta zpt
2457 : 28              >            plp
                        
2458 : 260c                     rol zpt
                                tst_z rROLc,fROLc,0
245a : 08              >            php         ;save flags
245b : a50c            >            lda zpt
245d : dd1502          >            cmp rROLc,x    ;test result
                       >            trap_ne
2460 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2462 : 68              >            pla         ;load status
                       >            eor_flag 0
2463 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2465 : dd2502          >            cmp fROLc,x    ;test flags
                       >            trap_ne
2468 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
246a : ca                       dex
246b : 10e3                     bpl trolc2
246d : a203                     ldx #3
246f :                  trolc3
                                set_z zp1,$ff
                       >            load_flag $ff
246f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2471 : 48              >            pha         ;use stack to load status
2472 : b513            >            lda zp1,x    ;load to zeropage
2474 : 850c            >            sta zpt
2476 : 28              >            plp
                        
2477 : 260c                     rol zpt
                                tst_z rROLc,fROLc,$ff-fnzc
2479 : 08              >            php         ;save flags
247a : a50c            >            lda zpt
247c : dd1502          >            cmp rROLc,x    ;test result
                       >            trap_ne
247f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2481 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2482 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2484 : dd2502          >            cmp fROLc,x    ;test flags
                       >            trap_ne
2487 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2489 : ca                       dex
248a : 10e3                     bpl trolc3
                        
248c : a203                     ldx #3
248e :                  tror2
                                set_z zp1,0
                       >            load_flag 0
248e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2490 : 48              >            pha         ;use stack to load status
2491 : b513            >            lda zp1,x    ;load to zeropage
2493 : 850c            >            sta zpt
2495 : 28              >            plp
                        
2496 : 660c                     ror zpt
                                tst_z rROR,fROR,0
2498 : 08              >            php         ;save flags
2499 : a50c            >            lda zpt
249b : dd1902          >            cmp rROR,x    ;test result
                       >            trap_ne
249e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
24a0 : 68              >            pla         ;load status
                       >            eor_flag 0
24a1 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
24a3 : dd2902          >            cmp fROR,x    ;test flags
                       >            trap_ne
24a6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
24a8 : ca                       dex
24a9 : 10e3                     bpl tror2
24ab : a203                     ldx #3
24ad :                  tror3
                                set_z zp1,$ff-fc
                       >            load_flag $ff-fc
24ad : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
24af : 48              >            pha         ;use stack to load status
24b0 : b513            >            lda zp1,x    ;load to zeropage
24b2 : 850c            >            sta zpt
24b4 : 28              >            plp
                        
24b5 : 660c                     ror zpt
                                tst_z rROR,fROR,$ff-fnzc
24b7 : 08              >            php         ;save flags
24b8 : a50c            >            lda zpt
24ba : dd1902          >            cmp rROR,x    ;test result
                       >            trap_ne
24bd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
24bf : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
24c0 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
24c2 : dd2902          >            cmp fROR,x    ;test flags
                       >            trap_ne
24c5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
24c7 : ca                       dex
24c8 : 10e3                     bpl tror3
                        
24ca : a203                     ldx #3
24cc :                  trorc2
                                set_z zp1,fc
                       >            load_flag fc
24cc : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
24ce : 48              >            pha         ;use stack to load status
24cf : b513            >            lda zp1,x    ;load to zeropage
24d1 : 850c            >            sta zpt
24d3 : 28              >            plp
                        
24d4 : 660c                     ror zpt
                                tst_z rRORc,fRORc,0
24d6 : 08              >            php         ;save flags
24d7 : a50c            >            lda zpt
24d9 : dd1d02          >            cmp rRORc,x    ;test result
                       >            trap_ne
24dc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
24de : 68              >            pla         ;load status
                       >            eor_flag 0
24df : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
24e1 : dd2d02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
24e4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
24e6 : ca                       dex
24e7 : 10e3                     bpl trorc2
24e9 : a203                     ldx #3
24eb :                  trorc3
                                set_z zp1,$ff
                       >            load_flag $ff
24eb : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
24ed : 48              >            pha         ;use stack to load status
24ee : b513            >            lda zp1,x    ;load to zeropage
24f0 : 850c            >            sta zpt
24f2 : 28              >            plp
                        
24f3 : 660c                     ror zpt
                                tst_z rRORc,fRORc,$ff-fnzc
24f5 : 08              >            php         ;save flags
24f6 : a50c            >            lda zpt
24f8 : dd1d02          >            cmp rRORc,x    ;test result
                       >            trap_ne
24fb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
24fd : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
24fe : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2500 : dd2d02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
2503 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2505 : ca                       dex
2506 : 10e3                     bpl trorc3
                                next_test
2508 : ad0002          >            lda test_case   ;previous test
250b : c91e            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
250d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001f =                 >test_num = test_num + 1
250f : a91f            >            lda #test_num   ;*** next tests' number
2511 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - absolute
2514 : a203                     ldx #3
2516 :                  tasl4
                                set_abs zp1,0
                       >            load_flag 0
2516 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2518 : 48              >            pha         ;use stack to load status
2519 : b513            >            lda zp1,x    ;load to memory
251b : 8d0302          >            sta abst
251e : 28              >            plp
                        
251f : 0e0302                   asl abst
                                tst_abs rASL,fASL,0
2522 : 08              >            php         ;save flags
2523 : ad0302          >            lda abst
2526 : dd1102          >            cmp rASL,x    ;test result
                       >            trap_ne
2529 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
252b : 68              >            pla         ;load status
                       >            eor_flag 0
252c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
252e : dd2102          >            cmp fASL,x    ;test flags
                       >            trap_ne
2531 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2533 : ca                       dex
2534 : 10e0                     bpl tasl4
2536 : a203                     ldx #3
2538 :                  tasl5
                                set_abs zp1,$ff
                       >            load_flag $ff
2538 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
253a : 48              >            pha         ;use stack to load status
253b : b513            >            lda zp1,x    ;load to memory
253d : 8d0302          >            sta abst
2540 : 28              >            plp
                        
2541 : 0e0302                   asl abst
                                tst_abs rASL,fASL,$ff-fnzc
2544 : 08              >            php         ;save flags
2545 : ad0302          >            lda abst
2548 : dd1102          >            cmp rASL,x    ;test result
                       >            trap_ne
254b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
254d : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
254e : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2550 : dd2102          >            cmp fASL,x    ;test flags
                       >            trap_ne
2553 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2555 : ca                       dex
2556 : 10e0                     bpl tasl5
                        
2558 : a203                     ldx #3
255a :                  tlsr4
                                set_abs zp1,0
                       >            load_flag 0
255a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
255c : 48              >            pha         ;use stack to load status
255d : b513            >            lda zp1,x    ;load to memory
255f : 8d0302          >            sta abst
2562 : 28              >            plp
                        
2563 : 4e0302                   lsr abst
                                tst_abs rLSR,fLSR,0
2566 : 08              >            php         ;save flags
2567 : ad0302          >            lda abst
256a : dd1902          >            cmp rLSR,x    ;test result
                       >            trap_ne
256d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
256f : 68              >            pla         ;load status
                       >            eor_flag 0
2570 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2572 : dd2902          >            cmp fLSR,x    ;test flags
                       >            trap_ne
2575 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2577 : ca                       dex
2578 : 10e0                     bpl tlsr4
257a : a203                     ldx #3
257c :                  tlsr5
                                set_abs zp1,$ff
                       >            load_flag $ff
257c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
257e : 48              >            pha         ;use stack to load status
257f : b513            >            lda zp1,x    ;load to memory
2581 : 8d0302          >            sta abst
2584 : 28              >            plp
                        
2585 : 4e0302                   lsr abst
                                tst_abs rLSR,fLSR,$ff-fnzc
2588 : 08              >            php         ;save flags
2589 : ad0302          >            lda abst
258c : dd1902          >            cmp rLSR,x    ;test result
                       >            trap_ne
258f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2591 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2592 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2594 : dd2902          >            cmp fLSR,x    ;test flags
                       >            trap_ne
2597 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2599 : ca                       dex
259a : 10e0                     bpl tlsr5
                        
259c : a203                     ldx #3
259e :                  trol4
                                set_abs zp1,0
                       >            load_flag 0
259e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
25a0 : 48              >            pha         ;use stack to load status
25a1 : b513            >            lda zp1,x    ;load to memory
25a3 : 8d0302          >            sta abst
25a6 : 28              >            plp
                        
25a7 : 2e0302                   rol abst
                                tst_abs rROL,fROL,0
25aa : 08              >            php         ;save flags
25ab : ad0302          >            lda abst
25ae : dd1102          >            cmp rROL,x    ;test result
                       >            trap_ne
25b1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
25b3 : 68              >            pla         ;load status
                       >            eor_flag 0
25b4 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
25b6 : dd2102          >            cmp fROL,x    ;test flags
                       >            trap_ne
25b9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
25bb : ca                       dex
25bc : 10e0                     bpl trol4
25be : a203                     ldx #3
25c0 :                  trol5
                                set_abs zp1,$ff-fc
                       >            load_flag $ff-fc
25c0 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
25c2 : 48              >            pha         ;use stack to load status
25c3 : b513            >            lda zp1,x    ;load to memory
25c5 : 8d0302          >            sta abst
25c8 : 28              >            plp
                        
25c9 : 2e0302                   rol abst
                                tst_abs rROL,fROL,$ff-fnzc
25cc : 08              >            php         ;save flags
25cd : ad0302          >            lda abst
25d0 : dd1102          >            cmp rROL,x    ;test result
                       >            trap_ne
25d3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
25d5 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
25d6 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
25d8 : dd2102          >            cmp fROL,x    ;test flags
                       >            trap_ne
25db : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
25dd : ca                       dex
25de : 10e0                     bpl trol5
                        
25e0 : a203                     ldx #3
25e2 :                  trolc4
                                set_abs zp1,fc
                       >            load_flag fc
25e2 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
25e4 : 48              >            pha         ;use stack to load status
25e5 : b513            >            lda zp1,x    ;load to memory
25e7 : 8d0302          >            sta abst
25ea : 28              >            plp
                        
25eb : 2e0302                   rol abst
                                tst_abs rROLc,fROLc,0
25ee : 08              >            php         ;save flags
25ef : ad0302          >            lda abst
25f2 : dd1502          >            cmp rROLc,x    ;test result
                       >            trap_ne
25f5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
25f7 : 68              >            pla         ;load status
                       >            eor_flag 0
25f8 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
25fa : dd2502          >            cmp fROLc,x    ;test flags
                       >            trap_ne
25fd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
25ff : ca                       dex
2600 : 10e0                     bpl trolc4
2602 : a203                     ldx #3
2604 :                  trolc5
                                set_abs zp1,$ff
                       >            load_flag $ff
2604 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2606 : 48              >            pha         ;use stack to load status
2607 : b513            >            lda zp1,x    ;load to memory
2609 : 8d0302          >            sta abst
260c : 28              >            plp
                        
260d : 2e0302                   rol abst
                                tst_abs rROLc,fROLc,$ff-fnzc
2610 : 08              >            php         ;save flags
2611 : ad0302          >            lda abst
2614 : dd1502          >            cmp rROLc,x    ;test result
                       >            trap_ne
2617 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2619 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
261a : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
261c : dd2502          >            cmp fROLc,x    ;test flags
                       >            trap_ne
261f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2621 : ca                       dex
2622 : 10e0                     bpl trolc5
                        
2624 : a203                     ldx #3
2626 :                  tror4
                                set_abs zp1,0
                       >            load_flag 0
2626 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2628 : 48              >            pha         ;use stack to load status
2629 : b513            >            lda zp1,x    ;load to memory
262b : 8d0302          >            sta abst
262e : 28              >            plp
                        
262f : 6e0302                   ror abst
                                tst_abs rROR,fROR,0
2632 : 08              >            php         ;save flags
2633 : ad0302          >            lda abst
2636 : dd1902          >            cmp rROR,x    ;test result
                       >            trap_ne
2639 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
263b : 68              >            pla         ;load status
                       >            eor_flag 0
263c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
263e : dd2902          >            cmp fROR,x    ;test flags
                       >            trap_ne
2641 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2643 : ca                       dex
2644 : 10e0                     bpl tror4
2646 : a203                     ldx #3
2648 :                  tror5
                                set_abs zp1,$ff-fc
                       >            load_flag $ff-fc
2648 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
264a : 48              >            pha         ;use stack to load status
264b : b513            >            lda zp1,x    ;load to memory
264d : 8d0302          >            sta abst
2650 : 28              >            plp
                        
2651 : 6e0302                   ror abst
                                tst_abs rROR,fROR,$ff-fnzc
2654 : 08              >            php         ;save flags
2655 : ad0302          >            lda abst
2658 : dd1902          >            cmp rROR,x    ;test result
                       >            trap_ne
265b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
265d : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
265e : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2660 : dd2902          >            cmp fROR,x    ;test flags
                       >            trap_ne
2663 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2665 : ca                       dex
2666 : 10e0                     bpl tror5
                        
2668 : a203                     ldx #3
266a :                  trorc4
                                set_abs zp1,fc
                       >            load_flag fc
266a : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
266c : 48              >            pha         ;use stack to load status
266d : b513            >            lda zp1,x    ;load to memory
266f : 8d0302          >            sta abst
2672 : 28              >            plp
                        
2673 : 6e0302                   ror abst
                                tst_abs rRORc,fRORc,0
2676 : 08              >            php         ;save flags
2677 : ad0302          >            lda abst
267a : dd1d02          >            cmp rRORc,x    ;test result
                       >            trap_ne
267d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
267f : 68              >            pla         ;load status
                       >            eor_flag 0
2680 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2682 : dd2d02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
2685 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2687 : ca                       dex
2688 : 10e0                     bpl trorc4
268a : a203                     ldx #3
268c :                  trorc5
                                set_abs zp1,$ff
                       >            load_flag $ff
268c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
268e : 48              >            pha         ;use stack to load status
268f : b513            >            lda zp1,x    ;load to memory
2691 : 8d0302          >            sta abst
2694 : 28              >            plp
                        
2695 : 6e0302                   ror abst
                                tst_abs rRORc,fRORc,$ff-fnzc
2698 : 08              >            php         ;save flags
2699 : ad0302          >            lda abst
269c : dd1d02          >            cmp rRORc,x    ;test result
                       >            trap_ne
269f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
26a1 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
26a2 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
26a4 : dd2d02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
26a7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
26a9 : ca                       dex
26aa : 10e0                     bpl trorc5
                                next_test
26ac : ad0002          >            lda test_case   ;previous test
26af : c91f            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
26b1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0020 =                 >test_num = test_num + 1
26b3 : a920            >            lda #test_num   ;*** next tests' number
26b5 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - zp indexed
26b8 : a203                     ldx #3
26ba :                  tasl6
                                set_zx zp1,0
                       >            load_flag 0
26ba : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
26bc : 48              >            pha         ;use stack to load status
26bd : b513            >            lda zp1,x    ;load to indexed zeropage
26bf : 950c            >            sta zpt,x
26c1 : 28              >            plp
                        
26c2 : 160c                     asl zpt,x
                                tst_zx rASL,fASL,0
26c4 : 08              >            php         ;save flags
26c5 : b50c            >            lda zpt,x
26c7 : dd1102          >            cmp rASL,x    ;test result
                       >            trap_ne
26ca : d0fe            >        bne *           ;failed not equal (non zero)
                       >
26cc : 68              >            pla         ;load status
                       >            eor_flag 0
26cd : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
26cf : dd2102          >            cmp fASL,x    ;test flags
                       >            trap_ne
26d2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
26d4 : ca                       dex
26d5 : 10e3                     bpl tasl6
26d7 : a203                     ldx #3
26d9 :                  tasl7
                                set_zx zp1,$ff
                       >            load_flag $ff
26d9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
26db : 48              >            pha         ;use stack to load status
26dc : b513            >            lda zp1,x    ;load to indexed zeropage
26de : 950c            >            sta zpt,x
26e0 : 28              >            plp
                        
26e1 : 160c                     asl zpt,x
                                tst_zx rASL,fASL,$ff-fnzc
26e3 : 08              >            php         ;save flags
26e4 : b50c            >            lda zpt,x
26e6 : dd1102          >            cmp rASL,x    ;test result
                       >            trap_ne
26e9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
26eb : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
26ec : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
26ee : dd2102          >            cmp fASL,x    ;test flags
                       >            trap_ne
26f1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
26f3 : ca                       dex
26f4 : 10e3                     bpl tasl7
                        
26f6 : a203                     ldx #3
26f8 :                  tlsr6
                                set_zx zp1,0
                       >            load_flag 0
26f8 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
26fa : 48              >            pha         ;use stack to load status
26fb : b513            >            lda zp1,x    ;load to indexed zeropage
26fd : 950c            >            sta zpt,x
26ff : 28              >            plp
                        
2700 : 560c                     lsr zpt,x
                                tst_zx rLSR,fLSR,0
2702 : 08              >            php         ;save flags
2703 : b50c            >            lda zpt,x
2705 : dd1902          >            cmp rLSR,x    ;test result
                       >            trap_ne
2708 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
270a : 68              >            pla         ;load status
                       >            eor_flag 0
270b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
270d : dd2902          >            cmp fLSR,x    ;test flags
                       >            trap_ne
2710 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2712 : ca                       dex
2713 : 10e3                     bpl tlsr6
2715 : a203                     ldx #3
2717 :                  tlsr7
                                set_zx zp1,$ff
                       >            load_flag $ff
2717 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2719 : 48              >            pha         ;use stack to load status
271a : b513            >            lda zp1,x    ;load to indexed zeropage
271c : 950c            >            sta zpt,x
271e : 28              >            plp
                        
271f : 560c                     lsr zpt,x
                                tst_zx rLSR,fLSR,$ff-fnzc
2721 : 08              >            php         ;save flags
2722 : b50c            >            lda zpt,x
2724 : dd1902          >            cmp rLSR,x    ;test result
                       >            trap_ne
2727 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2729 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
272a : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
272c : dd2902          >            cmp fLSR,x    ;test flags
                       >            trap_ne
272f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2731 : ca                       dex
2732 : 10e3                     bpl tlsr7
                        
2734 : a203                     ldx #3
2736 :                  trol6
                                set_zx zp1,0
                       >            load_flag 0
2736 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2738 : 48              >            pha         ;use stack to load status
2739 : b513            >            lda zp1,x    ;load to indexed zeropage
273b : 950c            >            sta zpt,x
273d : 28              >            plp
                        
273e : 360c                     rol zpt,x
                                tst_zx rROL,fROL,0
2740 : 08              >            php         ;save flags
2741 : b50c            >            lda zpt,x
2743 : dd1102          >            cmp rROL,x    ;test result
                       >            trap_ne
2746 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2748 : 68              >            pla         ;load status
                       >            eor_flag 0
2749 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
274b : dd2102          >            cmp fROL,x    ;test flags
                       >            trap_ne
274e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2750 : ca                       dex
2751 : 10e3                     bpl trol6
2753 : a203                     ldx #3
2755 :                  trol7
                                set_zx zp1,$ff-fc
                       >            load_flag $ff-fc
2755 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
2757 : 48              >            pha         ;use stack to load status
2758 : b513            >            lda zp1,x    ;load to indexed zeropage
275a : 950c            >            sta zpt,x
275c : 28              >            plp
                        
275d : 360c                     rol zpt,x
                                tst_zx rROL,fROL,$ff-fnzc
275f : 08              >            php         ;save flags
2760 : b50c            >            lda zpt,x
2762 : dd1102          >            cmp rROL,x    ;test result
                       >            trap_ne
2765 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2767 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2768 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
276a : dd2102          >            cmp fROL,x    ;test flags
                       >            trap_ne
276d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
276f : ca                       dex
2770 : 10e3                     bpl trol7
                        
2772 : a203                     ldx #3
2774 :                  trolc6
                                set_zx zp1,fc
                       >            load_flag fc
2774 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
2776 : 48              >            pha         ;use stack to load status
2777 : b513            >            lda zp1,x    ;load to indexed zeropage
2779 : 950c            >            sta zpt,x
277b : 28              >            plp
                        
277c : 360c                     rol zpt,x
                                tst_zx rROLc,fROLc,0
277e : 08              >            php         ;save flags
277f : b50c            >            lda zpt,x
2781 : dd1502          >            cmp rROLc,x    ;test result
                       >            trap_ne
2784 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2786 : 68              >            pla         ;load status
                       >            eor_flag 0
2787 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2789 : dd2502          >            cmp fROLc,x    ;test flags
                       >            trap_ne
278c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
278e : ca                       dex
278f : 10e3                     bpl trolc6
2791 : a203                     ldx #3
2793 :                  trolc7
                                set_zx zp1,$ff
                       >            load_flag $ff
2793 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2795 : 48              >            pha         ;use stack to load status
2796 : b513            >            lda zp1,x    ;load to indexed zeropage
2798 : 950c            >            sta zpt,x
279a : 28              >            plp
                        
279b : 360c                     rol zpt,x
                                tst_zx rROLc,fROLc,$ff-fnzc
279d : 08              >            php         ;save flags
279e : b50c            >            lda zpt,x
27a0 : dd1502          >            cmp rROLc,x    ;test result
                       >            trap_ne
27a3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
27a5 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
27a6 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
27a8 : dd2502          >            cmp fROLc,x    ;test flags
                       >            trap_ne
27ab : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
27ad : ca                       dex
27ae : 10e3                     bpl trolc7
                        
27b0 : a203                     ldx #3
27b2 :                  tror6
                                set_zx zp1,0
                       >            load_flag 0
27b2 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
27b4 : 48              >            pha         ;use stack to load status
27b5 : b513            >            lda zp1,x    ;load to indexed zeropage
27b7 : 950c            >            sta zpt,x
27b9 : 28              >            plp
                        
27ba : 760c                     ror zpt,x
                                tst_zx rROR,fROR,0
27bc : 08              >            php         ;save flags
27bd : b50c            >            lda zpt,x
27bf : dd1902          >            cmp rROR,x    ;test result
                       >            trap_ne
27c2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
27c4 : 68              >            pla         ;load status
                       >            eor_flag 0
27c5 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
27c7 : dd2902          >            cmp fROR,x    ;test flags
                       >            trap_ne
27ca : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
27cc : ca                       dex
27cd : 10e3                     bpl tror6
27cf : a203                     ldx #3
27d1 :                  tror7
                                set_zx zp1,$ff-fc
                       >            load_flag $ff-fc
27d1 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
27d3 : 48              >            pha         ;use stack to load status
27d4 : b513            >            lda zp1,x    ;load to indexed zeropage
27d6 : 950c            >            sta zpt,x
27d8 : 28              >            plp
                        
27d9 : 760c                     ror zpt,x
                                tst_zx rROR,fROR,$ff-fnzc
27db : 08              >            php         ;save flags
27dc : b50c            >            lda zpt,x
27de : dd1902          >            cmp rROR,x    ;test result
                       >            trap_ne
27e1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
27e3 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
27e4 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
27e6 : dd2902          >            cmp fROR,x    ;test flags
                       >            trap_ne
27e9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
27eb : ca                       dex
27ec : 10e3                     bpl tror7
                        
27ee : a203                     ldx #3
27f0 :                  trorc6
                                set_zx zp1,fc
                       >            load_flag fc
27f0 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
27f2 : 48              >            pha         ;use stack to load status
27f3 : b513            >            lda zp1,x    ;load to indexed zeropage
27f5 : 950c            >            sta zpt,x
27f7 : 28              >            plp
                        
27f8 : 760c                     ror zpt,x
                                tst_zx rRORc,fRORc,0
27fa : 08              >            php         ;save flags
27fb : b50c            >            lda zpt,x
27fd : dd1d02          >            cmp rRORc,x    ;test result
                       >            trap_ne
2800 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2802 : 68              >            pla         ;load status
                       >            eor_flag 0
2803 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2805 : dd2d02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
2808 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
280a : ca                       dex
280b : 10e3                     bpl trorc6
280d : a203                     ldx #3
280f :                  trorc7
                                set_zx zp1,$ff
                       >            load_flag $ff
280f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2811 : 48              >            pha         ;use stack to load status
2812 : b513            >            lda zp1,x    ;load to indexed zeropage
2814 : 950c            >            sta zpt,x
2816 : 28              >            plp
                        
2817 : 760c                     ror zpt,x
                                tst_zx rRORc,fRORc,$ff-fnzc
2819 : 08              >            php         ;save flags
281a : b50c            >            lda zpt,x
281c : dd1d02          >            cmp rRORc,x    ;test result
                       >            trap_ne
281f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2821 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2822 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2824 : dd2d02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
2827 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2829 : ca                       dex
282a : 10e3                     bpl trorc7
                                next_test
282c : ad0002          >            lda test_case   ;previous test
282f : c920            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2831 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0021 =                 >test_num = test_num + 1
2833 : a921            >            lda #test_num   ;*** next tests' number
2835 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; shifts - abs indexed
2838 : a203                     ldx #3
283a :                  tasl8
                                set_absx zp1,0
                       >            load_flag 0
283a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
283c : 48              >            pha         ;use stack to load status
283d : b513            >            lda zp1,x    ;load to indexed memory
283f : 9d0302          >            sta abst,x
2842 : 28              >            plp
                        
2843 : 1e0302                   asl abst,x
                                tst_absx rASL,fASL,0
2846 : 08              >            php         ;save flags
2847 : bd0302          >            lda abst,x
284a : dd1102          >            cmp rASL,x    ;test result
                       >            trap_ne
284d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
284f : 68              >            pla         ;load status
                       >            eor_flag 0
2850 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2852 : dd2102          >            cmp fASL,x    ;test flags
                       >            trap_ne
2855 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2857 : ca                       dex
2858 : 10e0                     bpl tasl8
285a : a203                     ldx #3
285c :                  tasl9
                                set_absx zp1,$ff
                       >            load_flag $ff
285c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
285e : 48              >            pha         ;use stack to load status
285f : b513            >            lda zp1,x    ;load to indexed memory
2861 : 9d0302          >            sta abst,x
2864 : 28              >            plp
                        
2865 : 1e0302                   asl abst,x
                                tst_absx rASL,fASL,$ff-fnzc
2868 : 08              >            php         ;save flags
2869 : bd0302          >            lda abst,x
286c : dd1102          >            cmp rASL,x    ;test result
                       >            trap_ne
286f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2871 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2872 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2874 : dd2102          >            cmp fASL,x    ;test flags
                       >            trap_ne
2877 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2879 : ca                       dex
287a : 10e0                     bpl tasl9
                        
287c : a203                     ldx #3
287e :                  tlsr8
                                set_absx zp1,0
                       >            load_flag 0
287e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2880 : 48              >            pha         ;use stack to load status
2881 : b513            >            lda zp1,x    ;load to indexed memory
2883 : 9d0302          >            sta abst,x
2886 : 28              >            plp
                        
2887 : 5e0302                   lsr abst,x
                                tst_absx rLSR,fLSR,0
288a : 08              >            php         ;save flags
288b : bd0302          >            lda abst,x
288e : dd1902          >            cmp rLSR,x    ;test result
                       >            trap_ne
2891 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2893 : 68              >            pla         ;load status
                       >            eor_flag 0
2894 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2896 : dd2902          >            cmp fLSR,x    ;test flags
                       >            trap_ne
2899 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
289b : ca                       dex
289c : 10e0                     bpl tlsr8
289e : a203                     ldx #3
28a0 :                  tlsr9
                                set_absx zp1,$ff
                       >            load_flag $ff
28a0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
28a2 : 48              >            pha         ;use stack to load status
28a3 : b513            >            lda zp1,x    ;load to indexed memory
28a5 : 9d0302          >            sta abst,x
28a8 : 28              >            plp
                        
28a9 : 5e0302                   lsr abst,x
                                tst_absx rLSR,fLSR,$ff-fnzc
28ac : 08              >            php         ;save flags
28ad : bd0302          >            lda abst,x
28b0 : dd1902          >            cmp rLSR,x    ;test result
                       >            trap_ne
28b3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
28b5 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
28b6 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
28b8 : dd2902          >            cmp fLSR,x    ;test flags
                       >            trap_ne
28bb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
28bd : ca                       dex
28be : 10e0                     bpl tlsr9
                        
28c0 : a203                     ldx #3
28c2 :                  trol8
                                set_absx zp1,0
                       >            load_flag 0
28c2 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
28c4 : 48              >            pha         ;use stack to load status
28c5 : b513            >            lda zp1,x    ;load to indexed memory
28c7 : 9d0302          >            sta abst,x
28ca : 28              >            plp
                        
28cb : 3e0302                   rol abst,x
                                tst_absx rROL,fROL,0
28ce : 08              >            php         ;save flags
28cf : bd0302          >            lda abst,x
28d2 : dd1102          >            cmp rROL,x    ;test result
                       >            trap_ne
28d5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
28d7 : 68              >            pla         ;load status
                       >            eor_flag 0
28d8 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
28da : dd2102          >            cmp fROL,x    ;test flags
                       >            trap_ne
28dd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
28df : ca                       dex
28e0 : 10e0                     bpl trol8
28e2 : a203                     ldx #3
28e4 :                  trol9
                                set_absx zp1,$ff-fc
                       >            load_flag $ff-fc
28e4 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
28e6 : 48              >            pha         ;use stack to load status
28e7 : b513            >            lda zp1,x    ;load to indexed memory
28e9 : 9d0302          >            sta abst,x
28ec : 28              >            plp
                        
28ed : 3e0302                   rol abst,x
                                tst_absx rROL,fROL,$ff-fnzc
28f0 : 08              >            php         ;save flags
28f1 : bd0302          >            lda abst,x
28f4 : dd1102          >            cmp rROL,x    ;test result
                       >            trap_ne
28f7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
28f9 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
28fa : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
28fc : dd2102          >            cmp fROL,x    ;test flags
                       >            trap_ne
28ff : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2901 : ca                       dex
2902 : 10e0                     bpl trol9
                        
2904 : a203                     ldx #3
2906 :                  trolc8
                                set_absx zp1,fc
                       >            load_flag fc
2906 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
2908 : 48              >            pha         ;use stack to load status
2909 : b513            >            lda zp1,x    ;load to indexed memory
290b : 9d0302          >            sta abst,x
290e : 28              >            plp
                        
290f : 3e0302                   rol abst,x
                                tst_absx rROLc,fROLc,0
2912 : 08              >            php         ;save flags
2913 : bd0302          >            lda abst,x
2916 : dd1502          >            cmp rROLc,x    ;test result
                       >            trap_ne
2919 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
291b : 68              >            pla         ;load status
                       >            eor_flag 0
291c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
291e : dd2502          >            cmp fROLc,x    ;test flags
                       >            trap_ne
2921 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2923 : ca                       dex
2924 : 10e0                     bpl trolc8
2926 : a203                     ldx #3
2928 :                  trolc9
                                set_absx zp1,$ff
                       >            load_flag $ff
2928 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
292a : 48              >            pha         ;use stack to load status
292b : b513            >            lda zp1,x    ;load to indexed memory
292d : 9d0302          >            sta abst,x
2930 : 28              >            plp
                        
2931 : 3e0302                   rol abst,x
                                tst_absx rROLc,fROLc,$ff-fnzc
2934 : 08              >            php         ;save flags
2935 : bd0302          >            lda abst,x
2938 : dd1502          >            cmp rROLc,x    ;test result
                       >            trap_ne
293b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
293d : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
293e : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2940 : dd2502          >            cmp fROLc,x    ;test flags
                       >            trap_ne
2943 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2945 : ca                       dex
2946 : 10e0                     bpl trolc9
                        
2948 : a203                     ldx #3
294a :                  tror8
                                set_absx zp1,0
                       >            load_flag 0
294a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
294c : 48              >            pha         ;use stack to load status
294d : b513            >            lda zp1,x    ;load to indexed memory
294f : 9d0302          >            sta abst,x
2952 : 28              >            plp
                        
2953 : 7e0302                   ror abst,x
                                tst_absx rROR,fROR,0
2956 : 08              >            php         ;save flags
2957 : bd0302          >            lda abst,x
295a : dd1902          >            cmp rROR,x    ;test result
                       >            trap_ne
295d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
295f : 68              >            pla         ;load status
                       >            eor_flag 0
2960 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2962 : dd2902          >            cmp fROR,x    ;test flags
                       >            trap_ne
2965 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2967 : ca                       dex
2968 : 10e0                     bpl tror8
296a : a203                     ldx #3
296c :                  tror9
                                set_absx zp1,$ff-fc
                       >            load_flag $ff-fc
296c : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
296e : 48              >            pha         ;use stack to load status
296f : b513            >            lda zp1,x    ;load to indexed memory
2971 : 9d0302          >            sta abst,x
2974 : 28              >            plp
                        
2975 : 7e0302                   ror abst,x
                                tst_absx rROR,fROR,$ff-fnzc
2978 : 08              >            php         ;save flags
2979 : bd0302          >            lda abst,x
297c : dd1902          >            cmp rROR,x    ;test result
                       >            trap_ne
297f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2981 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2982 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2984 : dd2902          >            cmp fROR,x    ;test flags
                       >            trap_ne
2987 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2989 : ca                       dex
298a : 10e0                     bpl tror9
                        
298c : a203                     ldx #3
298e :                  trorc8
                                set_absx zp1,fc
                       >            load_flag fc
298e : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
2990 : 48              >            pha         ;use stack to load status
2991 : b513            >            lda zp1,x    ;load to indexed memory
2993 : 9d0302          >            sta abst,x
2996 : 28              >            plp
                        
2997 : 7e0302                   ror abst,x
                                tst_absx rRORc,fRORc,0
299a : 08              >            php         ;save flags
299b : bd0302          >            lda abst,x
299e : dd1d02          >            cmp rRORc,x    ;test result
                       >            trap_ne
29a1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
29a3 : 68              >            pla         ;load status
                       >            eor_flag 0
29a4 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
29a6 : dd2d02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
29a9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
29ab : ca                       dex
29ac : 10e0                     bpl trorc8
29ae : a203                     ldx #3
29b0 :                  trorc9
                                set_absx zp1,$ff
                       >            load_flag $ff
29b0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
29b2 : 48              >            pha         ;use stack to load status
29b3 : b513            >            lda zp1,x    ;load to indexed memory
29b5 : 9d0302          >            sta abst,x
29b8 : 28              >            plp
                        
29b9 : 7e0302                   ror abst,x
                                tst_absx rRORc,fRORc,$ff-fnzc
29bc : 08              >            php         ;save flags
29bd : bd0302          >            lda abst,x
29c0 : dd1d02          >            cmp rRORc,x    ;test result
                       >            trap_ne
29c3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
29c5 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
29c6 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
29c8 : dd2d02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
29cb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
29cd : ca                       dex
29ce : 10e0                     bpl trorc9
                                next_test
29d0 : ad0002          >            lda test_case   ;previous test
29d3 : c921            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
29d5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0022 =                 >test_num = test_num + 1
29d7 : a922            >            lda #test_num   ;*** next tests' number
29d9 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing memory increment/decrement - INC DEC all addressing modes
                        ; zeropage
29dc : a200                     ldx #0
29de : a97e                     lda #$7e
29e0 : 850c                     sta zpt
29e2 :                  tinc    
                                set_stat 0
                       >            load_flag 0
29e2 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
29e4 : 48              >            pha         ;use stack to load status
29e5 : 28              >            plp
                        
29e6 : e60c                     inc zpt
                                tst_z rINC,fINC,0
29e8 : 08              >            php         ;save flags
29e9 : a50c            >            lda zpt
29eb : dd3102          >            cmp rINC,x    ;test result
                       >            trap_ne
29ee : d0fe            >        bne *           ;failed not equal (non zero)
                       >
29f0 : 68              >            pla         ;load status
                       >            eor_flag 0
29f1 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
29f3 : dd3602          >            cmp fINC,x    ;test flags
                       >            trap_ne
29f6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
29f8 : e8                       inx
29f9 : e002                     cpx #2
29fb : d004                     bne tinc1
29fd : a9fe                     lda #$fe
29ff : 850c                     sta zpt
2a01 : e005             tinc1   cpx #5
2a03 : d0dd                     bne tinc
2a05 : ca                       dex
2a06 : e60c                     inc zpt
2a08 :                  tdec    
                                set_stat 0
                       >            load_flag 0
2a08 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2a0a : 48              >            pha         ;use stack to load status
2a0b : 28              >            plp
                        
2a0c : c60c                     dec zpt
                                tst_z rINC,fINC,0
2a0e : 08              >            php         ;save flags
2a0f : a50c            >            lda zpt
2a11 : dd3102          >            cmp rINC,x    ;test result
                       >            trap_ne
2a14 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2a16 : 68              >            pla         ;load status
                       >            eor_flag 0
2a17 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2a19 : dd3602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2a1c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2a1e : ca                       dex
2a1f : 300a                     bmi tdec1
2a21 : e001                     cpx #1
2a23 : d0e3                     bne tdec
2a25 : a981                     lda #$81
2a27 : 850c                     sta zpt
2a29 : d0dd                     bne tdec
2a2b :                  tdec1
2a2b : a200                     ldx #0
2a2d : a97e                     lda #$7e
2a2f : 850c                     sta zpt
2a31 :                  tinc10    
                                set_stat $ff
                       >            load_flag $ff
2a31 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2a33 : 48              >            pha         ;use stack to load status
2a34 : 28              >            plp
                        
2a35 : e60c                     inc zpt
                                tst_z rINC,fINC,$ff-fnz
2a37 : 08              >            php         ;save flags
2a38 : a50c            >            lda zpt
2a3a : dd3102          >            cmp rINC,x    ;test result
                       >            trap_ne
2a3d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2a3f : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2a40 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2a42 : dd3602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2a45 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2a47 : e8                       inx
2a48 : e002                     cpx #2
2a4a : d004                     bne tinc11
2a4c : a9fe                     lda #$fe
2a4e : 850c                     sta zpt
2a50 : e005             tinc11  cpx #5
2a52 : d0dd                     bne tinc10
2a54 : ca                       dex
2a55 : e60c                     inc zpt
2a57 :                  tdec10    
                                set_stat $ff
                       >            load_flag $ff
2a57 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2a59 : 48              >            pha         ;use stack to load status
2a5a : 28              >            plp
                        
2a5b : c60c                     dec zpt
                                tst_z rINC,fINC,$ff-fnz
2a5d : 08              >            php         ;save flags
2a5e : a50c            >            lda zpt
2a60 : dd3102          >            cmp rINC,x    ;test result
                       >            trap_ne
2a63 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2a65 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2a66 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2a68 : dd3602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2a6b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2a6d : ca                       dex
2a6e : 300a                     bmi tdec11
2a70 : e001                     cpx #1
2a72 : d0e3                     bne tdec10
2a74 : a981                     lda #$81
2a76 : 850c                     sta zpt
2a78 : d0dd                     bne tdec10
2a7a :                  tdec11
                                next_test
2a7a : ad0002          >            lda test_case   ;previous test
2a7d : c922            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2a7f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0023 =                 >test_num = test_num + 1
2a81 : a923            >            lda #test_num   ;*** next tests' number
2a83 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; absolute memory
2a86 : a200                     ldx #0
2a88 : a97e                     lda #$7e
2a8a : 8d0302                   sta abst
2a8d :                  tinc2    
                                set_stat 0
                       >            load_flag 0
2a8d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2a8f : 48              >            pha         ;use stack to load status
2a90 : 28              >            plp
                        
2a91 : ee0302                   inc abst
                                tst_abs rINC,fINC,0
2a94 : 08              >            php         ;save flags
2a95 : ad0302          >            lda abst
2a98 : dd3102          >            cmp rINC,x    ;test result
                       >            trap_ne
2a9b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2a9d : 68              >            pla         ;load status
                       >            eor_flag 0
2a9e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2aa0 : dd3602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2aa3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2aa5 : e8                       inx
2aa6 : e002                     cpx #2
2aa8 : d005                     bne tinc3
2aaa : a9fe                     lda #$fe
2aac : 8d0302                   sta abst
2aaf : e005             tinc3   cpx #5
2ab1 : d0da                     bne tinc2
2ab3 : ca                       dex
2ab4 : ee0302                   inc abst
2ab7 :                  tdec2    
                                set_stat 0
                       >            load_flag 0
2ab7 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2ab9 : 48              >            pha         ;use stack to load status
2aba : 28              >            plp
                        
2abb : ce0302                   dec abst
                                tst_abs rINC,fINC,0
2abe : 08              >            php         ;save flags
2abf : ad0302          >            lda abst
2ac2 : dd3102          >            cmp rINC,x    ;test result
                       >            trap_ne
2ac5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2ac7 : 68              >            pla         ;load status
                       >            eor_flag 0
2ac8 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2aca : dd3602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2acd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2acf : ca                       dex
2ad0 : 300b                     bmi tdec3
2ad2 : e001                     cpx #1
2ad4 : d0e1                     bne tdec2
2ad6 : a981                     lda #$81
2ad8 : 8d0302                   sta abst
2adb : d0da                     bne tdec2
2add :                  tdec3
2add : a200                     ldx #0
2adf : a97e                     lda #$7e
2ae1 : 8d0302                   sta abst
2ae4 :                  tinc12    
                                set_stat $ff
                       >            load_flag $ff
2ae4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2ae6 : 48              >            pha         ;use stack to load status
2ae7 : 28              >            plp
                        
2ae8 : ee0302                   inc abst
                                tst_abs rINC,fINC,$ff-fnz
2aeb : 08              >            php         ;save flags
2aec : ad0302          >            lda abst
2aef : dd3102          >            cmp rINC,x    ;test result
                       >            trap_ne
2af2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2af4 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2af5 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2af7 : dd3602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2afa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2afc : e8                       inx
2afd : e002                     cpx #2
2aff : d005                     bne tinc13
2b01 : a9fe                     lda #$fe
2b03 : 8d0302                   sta abst
2b06 : e005             tinc13   cpx #5
2b08 : d0da                     bne tinc12
2b0a : ca                       dex
2b0b : ee0302                   inc abst
2b0e :                  tdec12    
                                set_stat $ff
                       >            load_flag $ff
2b0e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2b10 : 48              >            pha         ;use stack to load status
2b11 : 28              >            plp
                        
2b12 : ce0302                   dec abst
                                tst_abs rINC,fINC,$ff-fnz
2b15 : 08              >            php         ;save flags
2b16 : ad0302          >            lda abst
2b19 : dd3102          >            cmp rINC,x    ;test result
                       >            trap_ne
2b1c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2b1e : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2b1f : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2b21 : dd3602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2b24 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2b26 : ca                       dex
2b27 : 300b                     bmi tdec13
2b29 : e001                     cpx #1
2b2b : d0e1                     bne tdec12
2b2d : a981                     lda #$81
2b2f : 8d0302                   sta abst
2b32 : d0da                     bne tdec12
2b34 :                  tdec13
                                next_test
2b34 : ad0002          >            lda test_case   ;previous test
2b37 : c923            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2b39 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0024 =                 >test_num = test_num + 1
2b3b : a924            >            lda #test_num   ;*** next tests' number
2b3d : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; zeropage indexed
2b40 : a200                     ldx #0
2b42 : a97e                     lda #$7e
2b44 : 950c             tinc4   sta zpt,x
                                set_stat 0
                       >            load_flag 0
2b46 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2b48 : 48              >            pha         ;use stack to load status
2b49 : 28              >            plp
                        
2b4a : f60c                     inc zpt,x
                                tst_zx rINC,fINC,0
2b4c : 08              >            php         ;save flags
2b4d : b50c            >            lda zpt,x
2b4f : dd3102          >            cmp rINC,x    ;test result
                       >            trap_ne
2b52 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2b54 : 68              >            pla         ;load status
                       >            eor_flag 0
2b55 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2b57 : dd3602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2b5a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2b5c : b50c                     lda zpt,x
2b5e : e8                       inx
2b5f : e002                     cpx #2
2b61 : d002                     bne tinc5
2b63 : a9fe                     lda #$fe
2b65 : e005             tinc5   cpx #5
2b67 : d0db                     bne tinc4
2b69 : ca                       dex
2b6a : a902                     lda #2
2b6c : 950c             tdec4   sta zpt,x 
                                set_stat 0
                       >            load_flag 0
2b6e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2b70 : 48              >            pha         ;use stack to load status
2b71 : 28              >            plp
                        
2b72 : d60c                     dec zpt,x
                                tst_zx rINC,fINC,0
2b74 : 08              >            php         ;save flags
2b75 : b50c            >            lda zpt,x
2b77 : dd3102          >            cmp rINC,x    ;test result
                       >            trap_ne
2b7a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2b7c : 68              >            pla         ;load status
                       >            eor_flag 0
2b7d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2b7f : dd3602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2b82 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2b84 : b50c                     lda zpt,x
2b86 : ca                       dex
2b87 : 3008                     bmi tdec5
2b89 : e001                     cpx #1
2b8b : d0df                     bne tdec4
2b8d : a981                     lda #$81
2b8f : d0db                     bne tdec4
2b91 :                  tdec5
2b91 : a200                     ldx #0
2b93 : a97e                     lda #$7e
2b95 : 950c             tinc14  sta zpt,x
                                set_stat $ff
                       >            load_flag $ff
2b97 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2b99 : 48              >            pha         ;use stack to load status
2b9a : 28              >            plp
                        
2b9b : f60c                     inc zpt,x
                                tst_zx rINC,fINC,$ff-fnz
2b9d : 08              >            php         ;save flags
2b9e : b50c            >            lda zpt,x
2ba0 : dd3102          >            cmp rINC,x    ;test result
                       >            trap_ne
2ba3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2ba5 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2ba6 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2ba8 : dd3602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2bab : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2bad : b50c                     lda zpt,x
2baf : e8                       inx
2bb0 : e002                     cpx #2
2bb2 : d002                     bne tinc15
2bb4 : a9fe                     lda #$fe
2bb6 : e005             tinc15  cpx #5
2bb8 : d0db                     bne tinc14
2bba : ca                       dex
2bbb : a902                     lda #2
2bbd : 950c             tdec14  sta zpt,x 
                                set_stat $ff
                       >            load_flag $ff
2bbf : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2bc1 : 48              >            pha         ;use stack to load status
2bc2 : 28              >            plp
                        
2bc3 : d60c                     dec zpt,x
                                tst_zx rINC,fINC,$ff-fnz
2bc5 : 08              >            php         ;save flags
2bc6 : b50c            >            lda zpt,x
2bc8 : dd3102          >            cmp rINC,x    ;test result
                       >            trap_ne
2bcb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2bcd : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2bce : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2bd0 : dd3602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2bd3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2bd5 : b50c                     lda zpt,x
2bd7 : ca                       dex
2bd8 : 3008                     bmi tdec15
2bda : e001                     cpx #1
2bdc : d0df                     bne tdec14
2bde : a981                     lda #$81
2be0 : d0db                     bne tdec14
2be2 :                  tdec15
                                next_test
2be2 : ad0002          >            lda test_case   ;previous test
2be5 : c924            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2be7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0025 =                 >test_num = test_num + 1
2be9 : a925            >            lda #test_num   ;*** next tests' number
2beb : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; memory indexed
2bee : a200                     ldx #0
2bf0 : a97e                     lda #$7e
2bf2 : 9d0302           tinc6   sta abst,x
                                set_stat 0
                       >            load_flag 0
2bf5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2bf7 : 48              >            pha         ;use stack to load status
2bf8 : 28              >            plp
                        
2bf9 : fe0302                   inc abst,x
                                tst_absx rINC,fINC,0
2bfc : 08              >            php         ;save flags
2bfd : bd0302          >            lda abst,x
2c00 : dd3102          >            cmp rINC,x    ;test result
                       >            trap_ne
2c03 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2c05 : 68              >            pla         ;load status
                       >            eor_flag 0
2c06 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2c08 : dd3602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2c0b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2c0d : bd0302                   lda abst,x
2c10 : e8                       inx
2c11 : e002                     cpx #2
2c13 : d002                     bne tinc7
2c15 : a9fe                     lda #$fe
2c17 : e005             tinc7   cpx #5
2c19 : d0d7                     bne tinc6
2c1b : ca                       dex
2c1c : a902                     lda #2
2c1e : 9d0302           tdec6   sta abst,x 
                                set_stat 0
                       >            load_flag 0
2c21 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2c23 : 48              >            pha         ;use stack to load status
2c24 : 28              >            plp
                        
2c25 : de0302                   dec abst,x
                                tst_absx rINC,fINC,0
2c28 : 08              >            php         ;save flags
2c29 : bd0302          >            lda abst,x
2c2c : dd3102          >            cmp rINC,x    ;test result
                       >            trap_ne
2c2f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2c31 : 68              >            pla         ;load status
                       >            eor_flag 0
2c32 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2c34 : dd3602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2c37 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2c39 : bd0302                   lda abst,x
2c3c : ca                       dex
2c3d : 3008                     bmi tdec7
2c3f : e001                     cpx #1
2c41 : d0db                     bne tdec6
2c43 : a981                     lda #$81
2c45 : d0d7                     bne tdec6
2c47 :                  tdec7
2c47 : a200                     ldx #0
2c49 : a97e                     lda #$7e
2c4b : 9d0302           tinc16  sta abst,x
                                set_stat $ff
                       >            load_flag $ff
2c4e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2c50 : 48              >            pha         ;use stack to load status
2c51 : 28              >            plp
                        
2c52 : fe0302                   inc abst,x
                                tst_absx rINC,fINC,$ff-fnz
2c55 : 08              >            php         ;save flags
2c56 : bd0302          >            lda abst,x
2c59 : dd3102          >            cmp rINC,x    ;test result
                       >            trap_ne
2c5c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2c5e : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2c5f : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2c61 : dd3602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2c64 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2c66 : bd0302                   lda abst,x
2c69 : e8                       inx
2c6a : e002                     cpx #2
2c6c : d002                     bne tinc17
2c6e : a9fe                     lda #$fe
2c70 : e005             tinc17  cpx #5
2c72 : d0d7                     bne tinc16
2c74 : ca                       dex
2c75 : a902                     lda #2
2c77 : 9d0302           tdec16  sta abst,x 
                                set_stat $ff
                       >            load_flag $ff
2c7a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2c7c : 48              >            pha         ;use stack to load status
2c7d : 28              >            plp
                        
2c7e : de0302                   dec abst,x
                                tst_absx rINC,fINC,$ff-fnz
2c81 : 08              >            php         ;save flags
2c82 : bd0302          >            lda abst,x
2c85 : dd3102          >            cmp rINC,x    ;test result
                       >            trap_ne
2c88 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2c8a : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2c8b : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2c8d : dd3602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2c90 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2c92 : bd0302                   lda abst,x
2c95 : ca                       dex
2c96 : 3008                     bmi tdec17
2c98 : e001                     cpx #1
2c9a : d0db                     bne tdec16
2c9c : a981                     lda #$81
2c9e : d0d7                     bne tdec16
2ca0 :                  tdec17
                                next_test
2ca0 : ad0002          >            lda test_case   ;previous test
2ca3 : c925            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2ca5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0026 =                 >test_num = test_num + 1
2ca7 : a926            >            lda #test_num   ;*** next tests' number
2ca9 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing logical instructions - AND EOR ORA all addressing modes
                        ; AND
2cac : a203                     ldx #3      ;immediate - self modifying code
2cae : b51c             tand    lda zpAN,x
2cb0 : 8dbb2c                   sta tandi1
                                set_ax  absANa,0
                       >            load_flag 0
2cb3 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2cb5 : 48              >            pha         ;use stack to load status
2cb6 : bd4b02          >            lda absANa,x    ;precharge accu
2cb9 : 28              >            plp
                        
2cbb =                  tandi1  equ *+1     ;target for immediate operand
2cba : 2963                     and #99
                                tst_ax  absrlo,absflo,0
2cbc : 08              >            php         ;save flags
2cbd : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2cc0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2cc2 : 68              >            pla         ;load status
                       >            eor_flag 0
2cc3 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2cc5 : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2cc8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2cca : ca                       dex
2ccb : 10e1                     bpl tand
2ccd : a203                     ldx #3
2ccf : b51c             tand1   lda zpAN,x
2cd1 : 8ddc2c                   sta tandi2
                                set_ax  absANa,$ff
                       >            load_flag $ff
2cd4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2cd6 : 48              >            pha         ;use stack to load status
2cd7 : bd4b02          >            lda absANa,x    ;precharge accu
2cda : 28              >            plp
                        
2cdc =                  tandi2  equ *+1     ;target for immediate operand
2cdb : 2963                     and #99
                                tst_ax  absrlo,absflo,$ff-fnz
2cdd : 08              >            php         ;save flags
2cde : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2ce1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2ce3 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2ce4 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2ce6 : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2ce9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2ceb : ca                       dex
2cec : 10e1                     bpl tand1
                        
2cee : a203                     ldx #3      ;zp
2cf0 : b51c             tand2    lda zpAN,x
2cf2 : 850c                     sta zpt
                                set_ax  absANa,0
                       >            load_flag 0
2cf4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2cf6 : 48              >            pha         ;use stack to load status
2cf7 : bd4b02          >            lda absANa,x    ;precharge accu
2cfa : 28              >            plp
                        
2cfb : 250c                     and zpt
                                tst_ax  absrlo,absflo,0
2cfd : 08              >            php         ;save flags
2cfe : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2d01 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d03 : 68              >            pla         ;load status
                       >            eor_flag 0
2d04 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2d06 : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2d09 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2d0b : ca                       dex
2d0c : 10e2                     bpl tand2
2d0e : a203                     ldx #3
2d10 : b51c             tand3   lda zpAN,x
2d12 : 850c                     sta zpt
                                set_ax  absANa,$ff
                       >            load_flag $ff
2d14 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2d16 : 48              >            pha         ;use stack to load status
2d17 : bd4b02          >            lda absANa,x    ;precharge accu
2d1a : 28              >            plp
                        
2d1b : 250c                     and zpt
                                tst_ax  absrlo,absflo,$ff-fnz
2d1d : 08              >            php         ;save flags
2d1e : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2d21 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d23 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2d24 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2d26 : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2d29 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2d2b : ca                       dex
2d2c : 10e2                     bpl tand3
                        
2d2e : a203                     ldx #3      ;abs
2d30 : b51c             tand4   lda zpAN,x
2d32 : 8d0302                   sta abst
                                set_ax  absANa,0
                       >            load_flag 0
2d35 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2d37 : 48              >            pha         ;use stack to load status
2d38 : bd4b02          >            lda absANa,x    ;precharge accu
2d3b : 28              >            plp
                        
2d3c : 2d0302                   and abst
                                tst_ax  absrlo,absflo,0
2d3f : 08              >            php         ;save flags
2d40 : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2d43 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d45 : 68              >            pla         ;load status
                       >            eor_flag 0
2d46 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2d48 : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2d4b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2d4d : ca                       dex
2d4e : 10e0                     bpl tand4
2d50 : a203                     ldx #3
2d52 : b51c             tand5   lda zpAN,x
2d54 : 8d0302                   sta abst
                                set_ax  absANa,$ff
                       >            load_flag $ff
2d57 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2d59 : 48              >            pha         ;use stack to load status
2d5a : bd4b02          >            lda absANa,x    ;precharge accu
2d5d : 28              >            plp
                        
2d5e : 2d0302                   and abst
                                tst_ax  absrlo,absflo,$ff-fnz
2d61 : 08              >            php         ;save flags
2d62 : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2d65 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d67 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2d68 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2d6a : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2d6d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2d6f : ca                       dex
2d70 : 1002                     bpl tand6
                        
2d72 : a203                     ldx #3      ;zp,x
2d74 :                  tand6
                                set_ax  absANa,0
                       >            load_flag 0
2d74 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2d76 : 48              >            pha         ;use stack to load status
2d77 : bd4b02          >            lda absANa,x    ;precharge accu
2d7a : 28              >            plp
                        
2d7b : 351c                     and zpAN,x
                                tst_ax  absrlo,absflo,0
2d7d : 08              >            php         ;save flags
2d7e : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2d81 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d83 : 68              >            pla         ;load status
                       >            eor_flag 0
2d84 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2d86 : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2d89 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2d8b : ca                       dex
2d8c : 10e6                     bpl tand6
2d8e : a203                     ldx #3
2d90 :                  tand7
                                set_ax  absANa,$ff
                       >            load_flag $ff
2d90 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2d92 : 48              >            pha         ;use stack to load status
2d93 : bd4b02          >            lda absANa,x    ;precharge accu
2d96 : 28              >            plp
                        
2d97 : 351c                     and zpAN,x
                                tst_ax  absrlo,absflo,$ff-fnz
2d99 : 08              >            php         ;save flags
2d9a : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2d9d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d9f : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2da0 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2da2 : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2da5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2da7 : ca                       dex
2da8 : 10e6                     bpl tand7
                        
2daa : a203                     ldx #3      ;abs,x
2dac :                  tand8
                                set_ax  absANa,0
                       >            load_flag 0
2dac : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2dae : 48              >            pha         ;use stack to load status
2daf : bd4b02          >            lda absANa,x    ;precharge accu
2db2 : 28              >            plp
                        
2db3 : 3d3f02                   and absAN,x
                                tst_ax  absrlo,absflo,0
2db6 : 08              >            php         ;save flags
2db7 : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2dba : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2dbc : 68              >            pla         ;load status
                       >            eor_flag 0
2dbd : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2dbf : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2dc2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2dc4 : ca                       dex
2dc5 : 10e5                     bpl tand8
2dc7 : a203                     ldx #3
2dc9 :                  tand9
                                set_ax  absANa,$ff
                       >            load_flag $ff
2dc9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2dcb : 48              >            pha         ;use stack to load status
2dcc : bd4b02          >            lda absANa,x    ;precharge accu
2dcf : 28              >            plp
                        
2dd0 : 3d3f02                   and absAN,x
                                tst_ax  absrlo,absflo,$ff-fnz
2dd3 : 08              >            php         ;save flags
2dd4 : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2dd7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2dd9 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2dda : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2ddc : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2ddf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2de1 : ca                       dex
2de2 : 10e5                     bpl tand9
                        
2de4 : a003                     ldy #3      ;abs,y
2de6 :                  tand10
                                set_ay  absANa,0
                       >            load_flag 0
2de6 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2de8 : 48              >            pha         ;use stack to load status
2de9 : b94b02          >            lda absANa,y    ;precharge accu
2dec : 28              >            plp
                        
2ded : 393f02                   and absAN,y
                                tst_ay  absrlo,absflo,0
2df0 : 08              >            php         ;save flags
2df1 : d95302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2df4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2df6 : 68              >            pla         ;load status
                       >            eor_flag 0
2df7 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2df9 : d95702          >            cmp absflo,y    ;test flags
                       >            trap_ne
2dfc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2dfe : 88                       dey
2dff : 10e5                     bpl tand10
2e01 : a003                     ldy #3
2e03 :                  tand11
                                set_ay  absANa,$ff
                       >            load_flag $ff
2e03 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2e05 : 48              >            pha         ;use stack to load status
2e06 : b94b02          >            lda absANa,y    ;precharge accu
2e09 : 28              >            plp
                        
2e0a : 393f02                   and absAN,y
                                tst_ay  absrlo,absflo,$ff-fnz
2e0d : 08              >            php         ;save flags
2e0e : d95302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2e11 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e13 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2e14 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2e16 : d95702          >            cmp absflo,y    ;test flags
                       >            trap_ne
2e19 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e1b : 88                       dey
2e1c : 10e5                     bpl tand11
                        
2e1e : a206                     ldx #6      ;(zp,x)
2e20 : a003                     ldy #3
2e22 :                  tand12
                                set_ay  absANa,0
                       >            load_flag 0
2e22 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2e24 : 48              >            pha         ;use stack to load status
2e25 : b94b02          >            lda absANa,y    ;precharge accu
2e28 : 28              >            plp
                        
2e29 : 213a                     and (indAN,x)
                                tst_ay  absrlo,absflo,0
2e2b : 08              >            php         ;save flags
2e2c : d95302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2e2f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e31 : 68              >            pla         ;load status
                       >            eor_flag 0
2e32 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2e34 : d95702          >            cmp absflo,y    ;test flags
                       >            trap_ne
2e37 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e39 : ca                       dex
2e3a : ca                       dex
2e3b : 88                       dey
2e3c : 10e4                     bpl tand12
2e3e : a206                     ldx #6
2e40 : a003                     ldy #3
2e42 :                  tand13
                                set_ay  absANa,$ff
                       >            load_flag $ff
2e42 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2e44 : 48              >            pha         ;use stack to load status
2e45 : b94b02          >            lda absANa,y    ;precharge accu
2e48 : 28              >            plp
                        
2e49 : 213a                     and (indAN,x)
                                tst_ay  absrlo,absflo,$ff-fnz
2e4b : 08              >            php         ;save flags
2e4c : d95302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2e4f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e51 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2e52 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2e54 : d95702          >            cmp absflo,y    ;test flags
                       >            trap_ne
2e57 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e59 : ca                       dex
2e5a : ca                       dex
2e5b : 88                       dey
2e5c : 10e4                     bpl tand13
                        
2e5e : a003                     ldy #3      ;(zp),y
2e60 :                  tand14
                                set_ay  absANa,0
                       >            load_flag 0
2e60 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2e62 : 48              >            pha         ;use stack to load status
2e63 : b94b02          >            lda absANa,y    ;precharge accu
2e66 : 28              >            plp
                        
2e67 : 313a                     and (indAN),y
                                tst_ay  absrlo,absflo,0
2e69 : 08              >            php         ;save flags
2e6a : d95302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2e6d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e6f : 68              >            pla         ;load status
                       >            eor_flag 0
2e70 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2e72 : d95702          >            cmp absflo,y    ;test flags
                       >            trap_ne
2e75 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e77 : 88                       dey
2e78 : 10e6                     bpl tand14
2e7a : a003                     ldy #3
2e7c :                  tand15
                                set_ay  absANa,$ff
                       >            load_flag $ff
2e7c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2e7e : 48              >            pha         ;use stack to load status
2e7f : b94b02          >            lda absANa,y    ;precharge accu
2e82 : 28              >            plp
                        
2e83 : 313a                     and (indAN),y
                                tst_ay  absrlo,absflo,$ff-fnz
2e85 : 08              >            php         ;save flags
2e86 : d95302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2e89 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e8b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2e8c : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2e8e : d95702          >            cmp absflo,y    ;test flags
                       >            trap_ne
2e91 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e93 : 88                       dey
2e94 : 10e6                     bpl tand15
                                next_test
2e96 : ad0002          >            lda test_case   ;previous test
2e99 : c926            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2e9b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0027 =                 >test_num = test_num + 1
2e9d : a927            >            lda #test_num   ;*** next tests' number
2e9f : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; EOR
2ea2 : a203                     ldx #3      ;immediate - self modifying code
2ea4 : b520             teor    lda zpEO,x
2ea6 : 8db12e                   sta teori1
                                set_ax  absEOa,0
                       >            load_flag 0
2ea9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2eab : 48              >            pha         ;use stack to load status
2eac : bd4f02          >            lda absEOa,x    ;precharge accu
2eaf : 28              >            plp
                        
2eb1 =                  teori1  equ *+1     ;target for immediate operand
2eb0 : 4963                     eor #99
                                tst_ax  absrlo,absflo,0
2eb2 : 08              >            php         ;save flags
2eb3 : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2eb6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2eb8 : 68              >            pla         ;load status
                       >            eor_flag 0
2eb9 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2ebb : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2ebe : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2ec0 : ca                       dex
2ec1 : 10e1                     bpl teor
2ec3 : a203                     ldx #3
2ec5 : b520             teor1   lda zpEO,x
2ec7 : 8dd22e                   sta teori2
                                set_ax  absEOa,$ff
                       >            load_flag $ff
2eca : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2ecc : 48              >            pha         ;use stack to load status
2ecd : bd4f02          >            lda absEOa,x    ;precharge accu
2ed0 : 28              >            plp
                        
2ed2 =                  teori2  equ *+1     ;target for immediate operand
2ed1 : 4963                     eor #99
                                tst_ax  absrlo,absflo,$ff-fnz
2ed3 : 08              >            php         ;save flags
2ed4 : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2ed7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2ed9 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2eda : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2edc : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2edf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2ee1 : ca                       dex
2ee2 : 10e1                     bpl teor1
                        
2ee4 : a203                     ldx #3      ;zp
2ee6 : b520             teor2    lda zpEO,x
2ee8 : 850c                     sta zpt
                                set_ax  absEOa,0
                       >            load_flag 0
2eea : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2eec : 48              >            pha         ;use stack to load status
2eed : bd4f02          >            lda absEOa,x    ;precharge accu
2ef0 : 28              >            plp
                        
2ef1 : 450c                     eor zpt
                                tst_ax  absrlo,absflo,0
2ef3 : 08              >            php         ;save flags
2ef4 : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2ef7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2ef9 : 68              >            pla         ;load status
                       >            eor_flag 0
2efa : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2efc : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2eff : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f01 : ca                       dex
2f02 : 10e2                     bpl teor2
2f04 : a203                     ldx #3
2f06 : b520             teor3   lda zpEO,x
2f08 : 850c                     sta zpt
                                set_ax  absEOa,$ff
                       >            load_flag $ff
2f0a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2f0c : 48              >            pha         ;use stack to load status
2f0d : bd4f02          >            lda absEOa,x    ;precharge accu
2f10 : 28              >            plp
                        
2f11 : 450c                     eor zpt
                                tst_ax  absrlo,absflo,$ff-fnz
2f13 : 08              >            php         ;save flags
2f14 : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2f17 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2f19 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2f1a : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2f1c : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2f1f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f21 : ca                       dex
2f22 : 10e2                     bpl teor3
                        
2f24 : a203                     ldx #3      ;abs
2f26 : b520             teor4   lda zpEO,x
2f28 : 8d0302                   sta abst
                                set_ax  absEOa,0
                       >            load_flag 0
2f2b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2f2d : 48              >            pha         ;use stack to load status
2f2e : bd4f02          >            lda absEOa,x    ;precharge accu
2f31 : 28              >            plp
                        
2f32 : 4d0302                   eor abst
                                tst_ax  absrlo,absflo,0
2f35 : 08              >            php         ;save flags
2f36 : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2f39 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2f3b : 68              >            pla         ;load status
                       >            eor_flag 0
2f3c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2f3e : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2f41 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f43 : ca                       dex
2f44 : 10e0                     bpl teor4
2f46 : a203                     ldx #3
2f48 : b520             teor5   lda zpEO,x
2f4a : 8d0302                   sta abst
                                set_ax  absEOa,$ff
                       >            load_flag $ff
2f4d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2f4f : 48              >            pha         ;use stack to load status
2f50 : bd4f02          >            lda absEOa,x    ;precharge accu
2f53 : 28              >            plp
                        
2f54 : 4d0302                   eor abst
                                tst_ax  absrlo,absflo,$ff-fnz
2f57 : 08              >            php         ;save flags
2f58 : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2f5b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2f5d : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2f5e : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2f60 : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2f63 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f65 : ca                       dex
2f66 : 1002                     bpl teor6
                        
2f68 : a203                     ldx #3      ;zp,x
2f6a :                  teor6
                                set_ax  absEOa,0
                       >            load_flag 0
2f6a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2f6c : 48              >            pha         ;use stack to load status
2f6d : bd4f02          >            lda absEOa,x    ;precharge accu
2f70 : 28              >            plp
                        
2f71 : 5520                     eor zpEO,x
                                tst_ax  absrlo,absflo,0
2f73 : 08              >            php         ;save flags
2f74 : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2f77 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2f79 : 68              >            pla         ;load status
                       >            eor_flag 0
2f7a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2f7c : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2f7f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f81 : ca                       dex
2f82 : 10e6                     bpl teor6
2f84 : a203                     ldx #3
2f86 :                  teor7
                                set_ax  absEOa,$ff
                       >            load_flag $ff
2f86 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2f88 : 48              >            pha         ;use stack to load status
2f89 : bd4f02          >            lda absEOa,x    ;precharge accu
2f8c : 28              >            plp
                        
2f8d : 5520                     eor zpEO,x
                                tst_ax  absrlo,absflo,$ff-fnz
2f8f : 08              >            php         ;save flags
2f90 : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2f93 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2f95 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2f96 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2f98 : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2f9b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f9d : ca                       dex
2f9e : 10e6                     bpl teor7
                        
2fa0 : a203                     ldx #3      ;abs,x
2fa2 :                  teor8
                                set_ax  absEOa,0
                       >            load_flag 0
2fa2 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2fa4 : 48              >            pha         ;use stack to load status
2fa5 : bd4f02          >            lda absEOa,x    ;precharge accu
2fa8 : 28              >            plp
                        
2fa9 : 5d4302                   eor absEO,x
                                tst_ax  absrlo,absflo,0
2fac : 08              >            php         ;save flags
2fad : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2fb0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2fb2 : 68              >            pla         ;load status
                       >            eor_flag 0
2fb3 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2fb5 : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2fb8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2fba : ca                       dex
2fbb : 10e5                     bpl teor8
2fbd : a203                     ldx #3
2fbf :                  teor9
                                set_ax  absEOa,$ff
                       >            load_flag $ff
2fbf : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2fc1 : 48              >            pha         ;use stack to load status
2fc2 : bd4f02          >            lda absEOa,x    ;precharge accu
2fc5 : 28              >            plp
                        
2fc6 : 5d4302                   eor absEO,x
                                tst_ax  absrlo,absflo,$ff-fnz
2fc9 : 08              >            php         ;save flags
2fca : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2fcd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2fcf : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2fd0 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2fd2 : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2fd5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2fd7 : ca                       dex
2fd8 : 10e5                     bpl teor9
                        
2fda : a003                     ldy #3      ;abs,y
2fdc :                  teor10
                                set_ay  absEOa,0
                       >            load_flag 0
2fdc : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2fde : 48              >            pha         ;use stack to load status
2fdf : b94f02          >            lda absEOa,y    ;precharge accu
2fe2 : 28              >            plp
                        
2fe3 : 594302                   eor absEO,y
                                tst_ay  absrlo,absflo,0
2fe6 : 08              >            php         ;save flags
2fe7 : d95302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2fea : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2fec : 68              >            pla         ;load status
                       >            eor_flag 0
2fed : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2fef : d95702          >            cmp absflo,y    ;test flags
                       >            trap_ne
2ff2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2ff4 : 88                       dey
2ff5 : 10e5                     bpl teor10
2ff7 : a003                     ldy #3
2ff9 :                  teor11
                                set_ay  absEOa,$ff
                       >            load_flag $ff
2ff9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2ffb : 48              >            pha         ;use stack to load status
2ffc : b94f02          >            lda absEOa,y    ;precharge accu
2fff : 28              >            plp
                        
3000 : 594302                   eor absEO,y
                                tst_ay  absrlo,absflo,$ff-fnz
3003 : 08              >            php         ;save flags
3004 : d95302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3007 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3009 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
300a : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
300c : d95702          >            cmp absflo,y    ;test flags
                       >            trap_ne
300f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3011 : 88                       dey
3012 : 10e5                     bpl teor11
                        
3014 : a206                     ldx #6      ;(zp,x)
3016 : a003                     ldy #3
3018 :                  teor12
                                set_ay  absEOa,0
                       >            load_flag 0
3018 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
301a : 48              >            pha         ;use stack to load status
301b : b94f02          >            lda absEOa,y    ;precharge accu
301e : 28              >            plp
                        
301f : 4142                     eor (indEO,x)
                                tst_ay  absrlo,absflo,0
3021 : 08              >            php         ;save flags
3022 : d95302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3025 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3027 : 68              >            pla         ;load status
                       >            eor_flag 0
3028 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
302a : d95702          >            cmp absflo,y    ;test flags
                       >            trap_ne
302d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
302f : ca                       dex
3030 : ca                       dex
3031 : 88                       dey
3032 : 10e4                     bpl teor12
3034 : a206                     ldx #6
3036 : a003                     ldy #3
3038 :                  teor13
                                set_ay  absEOa,$ff
                       >            load_flag $ff
3038 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
303a : 48              >            pha         ;use stack to load status
303b : b94f02          >            lda absEOa,y    ;precharge accu
303e : 28              >            plp
                        
303f : 4142                     eor (indEO,x)
                                tst_ay  absrlo,absflo,$ff-fnz
3041 : 08              >            php         ;save flags
3042 : d95302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3045 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3047 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3048 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
304a : d95702          >            cmp absflo,y    ;test flags
                       >            trap_ne
304d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
304f : ca                       dex
3050 : ca                       dex
3051 : 88                       dey
3052 : 10e4                     bpl teor13
                        
3054 : a003                     ldy #3      ;(zp),y
3056 :                  teor14
                                set_ay  absEOa,0
                       >            load_flag 0
3056 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
3058 : 48              >            pha         ;use stack to load status
3059 : b94f02          >            lda absEOa,y    ;precharge accu
305c : 28              >            plp
                        
305d : 5142                     eor (indEO),y
                                tst_ay  absrlo,absflo,0
305f : 08              >            php         ;save flags
3060 : d95302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3063 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3065 : 68              >            pla         ;load status
                       >            eor_flag 0
3066 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
3068 : d95702          >            cmp absflo,y    ;test flags
                       >            trap_ne
306b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
306d : 88                       dey
306e : 10e6                     bpl teor14
3070 : a003                     ldy #3
3072 :                  teor15
                                set_ay  absEOa,$ff
                       >            load_flag $ff
3072 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3074 : 48              >            pha         ;use stack to load status
3075 : b94f02          >            lda absEOa,y    ;precharge accu
3078 : 28              >            plp
                        
3079 : 5142                     eor (indEO),y
                                tst_ay  absrlo,absflo,$ff-fnz
307b : 08              >            php         ;save flags
307c : d95302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
307f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3081 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3082 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
3084 : d95702          >            cmp absflo,y    ;test flags
                       >            trap_ne
3087 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3089 : 88                       dey
308a : 10e6                     bpl teor15
                                next_test
308c : ad0002          >            lda test_case   ;previous test
308f : c927            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
3091 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0028 =                 >test_num = test_num + 1
3093 : a928            >            lda #test_num   ;*** next tests' number
3095 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; OR
3098 : a203                     ldx #3      ;immediate - self modifying code
309a : b518             tora    lda zpOR,x
309c : 8da730                   sta torai1
                                set_ax  absORa,0
                       >            load_flag 0
309f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
30a1 : 48              >            pha         ;use stack to load status
30a2 : bd4702          >            lda absORa,x    ;precharge accu
30a5 : 28              >            plp
                        
30a7 =                  torai1  equ *+1     ;target for immediate operand
30a6 : 0963                     ora #99
                                tst_ax  absrlo,absflo,0
30a8 : 08              >            php         ;save flags
30a9 : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
30ac : d0fe            >        bne *           ;failed not equal (non zero)
                       >
30ae : 68              >            pla         ;load status
                       >            eor_flag 0
30af : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
30b1 : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
30b4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
30b6 : ca                       dex
30b7 : 10e1                     bpl tora
30b9 : a203                     ldx #3
30bb : b518             tora1   lda zpOR,x
30bd : 8dc830                   sta torai2
                                set_ax  absORa,$ff
                       >            load_flag $ff
30c0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
30c2 : 48              >            pha         ;use stack to load status
30c3 : bd4702          >            lda absORa,x    ;precharge accu
30c6 : 28              >            plp
                        
30c8 =                  torai2  equ *+1     ;target for immediate operand
30c7 : 0963                     ora #99
                                tst_ax  absrlo,absflo,$ff-fnz
30c9 : 08              >            php         ;save flags
30ca : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
30cd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
30cf : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
30d0 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
30d2 : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
30d5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
30d7 : ca                       dex
30d8 : 10e1                     bpl tora1
                        
30da : a203                     ldx #3      ;zp
30dc : b518             tora2    lda zpOR,x
30de : 850c                     sta zpt
                                set_ax  absORa,0
                       >            load_flag 0
30e0 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
30e2 : 48              >            pha         ;use stack to load status
30e3 : bd4702          >            lda absORa,x    ;precharge accu
30e6 : 28              >            plp
                        
30e7 : 050c                     ora zpt
                                tst_ax  absrlo,absflo,0
30e9 : 08              >            php         ;save flags
30ea : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
30ed : d0fe            >        bne *           ;failed not equal (non zero)
                       >
30ef : 68              >            pla         ;load status
                       >            eor_flag 0
30f0 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
30f2 : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
30f5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
30f7 : ca                       dex
30f8 : 10e2                     bpl tora2
30fa : a203                     ldx #3
30fc : b518             tora3   lda zpOR,x
30fe : 850c                     sta zpt
                                set_ax  absORa,$ff
                       >            load_flag $ff
3100 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3102 : 48              >            pha         ;use stack to load status
3103 : bd4702          >            lda absORa,x    ;precharge accu
3106 : 28              >            plp
                        
3107 : 050c                     ora zpt
                                tst_ax  absrlo,absflo,$ff-fnz
3109 : 08              >            php         ;save flags
310a : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
310d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
310f : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3110 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
3112 : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3115 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3117 : ca                       dex
3118 : 10e2                     bpl tora3
                        
311a : a203                     ldx #3      ;abs
311c : b518             tora4   lda zpOR,x
311e : 8d0302                   sta abst
                                set_ax  absORa,0
                       >            load_flag 0
3121 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
3123 : 48              >            pha         ;use stack to load status
3124 : bd4702          >            lda absORa,x    ;precharge accu
3127 : 28              >            plp
                        
3128 : 0d0302                   ora abst
                                tst_ax  absrlo,absflo,0
312b : 08              >            php         ;save flags
312c : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
312f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3131 : 68              >            pla         ;load status
                       >            eor_flag 0
3132 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
3134 : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3137 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3139 : ca                       dex
313a : 10e0                     bpl tora4
313c : a203                     ldx #3
313e : b518             tora5   lda zpOR,x
3140 : 8d0302                   sta abst
                                set_ax  absORa,$ff
                       >            load_flag $ff
3143 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3145 : 48              >            pha         ;use stack to load status
3146 : bd4702          >            lda absORa,x    ;precharge accu
3149 : 28              >            plp
                        
314a : 0d0302                   ora abst
                                tst_ax  absrlo,absflo,$ff-fnz
314d : 08              >            php         ;save flags
314e : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
3151 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3153 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3154 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
3156 : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3159 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
315b : ca                       dex
315c : 1002                     bpl tora6
                        
315e : a203                     ldx #3      ;zp,x
3160 :                  tora6
                                set_ax  absORa,0
                       >            load_flag 0
3160 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
3162 : 48              >            pha         ;use stack to load status
3163 : bd4702          >            lda absORa,x    ;precharge accu
3166 : 28              >            plp
                        
3167 : 1518                     ora zpOR,x
                                tst_ax  absrlo,absflo,0
3169 : 08              >            php         ;save flags
316a : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
316d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
316f : 68              >            pla         ;load status
                       >            eor_flag 0
3170 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
3172 : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3175 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3177 : ca                       dex
3178 : 10e6                     bpl tora6
317a : a203                     ldx #3
317c :                  tora7
                                set_ax  absORa,$ff
                       >            load_flag $ff
317c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
317e : 48              >            pha         ;use stack to load status
317f : bd4702          >            lda absORa,x    ;precharge accu
3182 : 28              >            plp
                        
3183 : 1518                     ora zpOR,x
                                tst_ax  absrlo,absflo,$ff-fnz
3185 : 08              >            php         ;save flags
3186 : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
3189 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
318b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
318c : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
318e : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3191 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3193 : ca                       dex
3194 : 10e6                     bpl tora7
                        
3196 : a203                     ldx #3      ;abs,x
3198 :                  tora8
                                set_ax  absORa,0
                       >            load_flag 0
3198 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
319a : 48              >            pha         ;use stack to load status
319b : bd4702          >            lda absORa,x    ;precharge accu
319e : 28              >            plp
                        
319f : 1d3b02                   ora absOR,x
                                tst_ax  absrlo,absflo,0
31a2 : 08              >            php         ;save flags
31a3 : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
31a6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
31a8 : 68              >            pla         ;load status
                       >            eor_flag 0
31a9 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
31ab : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
31ae : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
31b0 : ca                       dex
31b1 : 10e5                     bpl tora8
31b3 : a203                     ldx #3
31b5 :                  tora9
                                set_ax  absORa,$ff
                       >            load_flag $ff
31b5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
31b7 : 48              >            pha         ;use stack to load status
31b8 : bd4702          >            lda absORa,x    ;precharge accu
31bb : 28              >            plp
                        
31bc : 1d3b02                   ora absOR,x
                                tst_ax  absrlo,absflo,$ff-fnz
31bf : 08              >            php         ;save flags
31c0 : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
31c3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
31c5 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
31c6 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
31c8 : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
31cb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
31cd : ca                       dex
31ce : 10e5                     bpl tora9
                        
31d0 : a003                     ldy #3      ;abs,y
31d2 :                  tora10
                                set_ay  absORa,0
                       >            load_flag 0
31d2 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
31d4 : 48              >            pha         ;use stack to load status
31d5 : b94702          >            lda absORa,y    ;precharge accu
31d8 : 28              >            plp
                        
31d9 : 193b02                   ora absOR,y
                                tst_ay  absrlo,absflo,0
31dc : 08              >            php         ;save flags
31dd : d95302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
31e0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
31e2 : 68              >            pla         ;load status
                       >            eor_flag 0
31e3 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
31e5 : d95702          >            cmp absflo,y    ;test flags
                       >            trap_ne
31e8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
31ea : 88                       dey
31eb : 10e5                     bpl tora10
31ed : a003                     ldy #3
31ef :                  tora11
                                set_ay  absORa,$ff
                       >            load_flag $ff
31ef : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
31f1 : 48              >            pha         ;use stack to load status
31f2 : b94702          >            lda absORa,y    ;precharge accu
31f5 : 28              >            plp
                        
31f6 : 193b02                   ora absOR,y
                                tst_ay  absrlo,absflo,$ff-fnz
31f9 : 08              >            php         ;save flags
31fa : d95302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
31fd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
31ff : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3200 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
3202 : d95702          >            cmp absflo,y    ;test flags
                       >            trap_ne
3205 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3207 : 88                       dey
3208 : 10e5                     bpl tora11
                        
320a : a206                     ldx #6      ;(zp,x)
320c : a003                     ldy #3
320e :                  tora12
                                set_ay  absORa,0
                       >            load_flag 0
320e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
3210 : 48              >            pha         ;use stack to load status
3211 : b94702          >            lda absORa,y    ;precharge accu
3214 : 28              >            plp
                        
3215 : 014a                     ora (indOR,x)
                                tst_ay  absrlo,absflo,0
3217 : 08              >            php         ;save flags
3218 : d95302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
321b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
321d : 68              >            pla         ;load status
                       >            eor_flag 0
321e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
3220 : d95702          >            cmp absflo,y    ;test flags
                       >            trap_ne
3223 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3225 : ca                       dex
3226 : ca                       dex
3227 : 88                       dey
3228 : 10e4                     bpl tora12
322a : a206                     ldx #6
322c : a003                     ldy #3
322e :                  tora13
                                set_ay  absORa,$ff
                       >            load_flag $ff
322e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3230 : 48              >            pha         ;use stack to load status
3231 : b94702          >            lda absORa,y    ;precharge accu
3234 : 28              >            plp
                        
3235 : 014a                     ora (indOR,x)
                                tst_ay  absrlo,absflo,$ff-fnz
3237 : 08              >            php         ;save flags
3238 : d95302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
323b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
323d : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
323e : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
3240 : d95702          >            cmp absflo,y    ;test flags
                       >            trap_ne
3243 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3245 : ca                       dex
3246 : ca                       dex
3247 : 88                       dey
3248 : 10e4                     bpl tora13
                        
324a : a003                     ldy #3      ;(zp),y
324c :                  tora14
                                set_ay  absORa,0
                       >            load_flag 0
324c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
324e : 48              >            pha         ;use stack to load status
324f : b94702          >            lda absORa,y    ;precharge accu
3252 : 28              >            plp
                        
3253 : 114a                     ora (indOR),y
                                tst_ay  absrlo,absflo,0
3255 : 08              >            php         ;save flags
3256 : d95302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3259 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
325b : 68              >            pla         ;load status
                       >            eor_flag 0
325c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
325e : d95702          >            cmp absflo,y    ;test flags
                       >            trap_ne
3261 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3263 : 88                       dey
3264 : 10e6                     bpl tora14
3266 : a003                     ldy #3
3268 :                  tora15
                                set_ay  absORa,$ff
                       >            load_flag $ff
3268 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
326a : 48              >            pha         ;use stack to load status
326b : b94702          >            lda absORa,y    ;precharge accu
326e : 28              >            plp
                        
326f : 114a                     ora (indOR),y
                                tst_ay  absrlo,absflo,$ff-fnz
3271 : 08              >            php         ;save flags
3272 : d95302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3275 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3277 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3278 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
327a : d95702          >            cmp absflo,y    ;test flags
                       >            trap_ne
327d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
327f : 88                       dey
3280 : 10e6                     bpl tora15
                            if I_flag = 3
3282 : 58                       cli
                            endif                
                                next_test
3283 : ad0002          >            lda test_case   ;previous test
3286 : c928            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
3288 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0029 =                 >test_num = test_num + 1
328a : a929            >            lda #test_num   ;*** next tests' number
328c : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; full binary add/subtract test
                        ; iterates through all combinations of operands and carry input
                        ; uses increments/decrements to predict result & result flags
328f : d8                       cld
3290 : a20e                     ldx #ad2        ;for indexed test
3292 : a0ff                     ldy #$ff        ;max range
3294 : a900                     lda #0          ;start with adding zeroes & no carry
3296 : 850c                     sta adfc        ;carry in - for diag
3298 : 850d                     sta ad1         ;operand 1 - accumulator
329a : 850e                     sta ad2         ;operand 2 - memory or immediate
329c : 8d0302                   sta ada2        ;non zp
329f : 850f                     sta adrl        ;expected result bits 0-7
32a1 : 8510                     sta adrh        ;expected result bit 8 (carry out)
32a3 : a9ff                     lda #$ff        ;complemented operand 2 for subtract
32a5 : 8512                     sta sb2
32a7 : 8d0402                   sta sba2        ;non zp
32aa : a902                     lda #2          ;expected Z-flag
32ac : 8511                     sta adrf
32ae : 18               tadd    clc             ;test with carry clear
32af : 20d034                   jsr chkadd
32b2 : e60c                     inc adfc        ;now with carry
32b4 : e60f                     inc adrl        ;result +1
32b6 : 08                       php             ;save N & Z from low result
32b7 : 08                       php
32b8 : 68                       pla             ;accu holds expected flags
32b9 : 2982                     and #$82        ;mask N & Z
32bb : 28                       plp
32bc : d002                     bne tadd1
32be : e610                     inc adrh        ;result bit 8 - carry
32c0 : 0510             tadd1   ora adrh        ;merge C to expected flags
32c2 : 8511                     sta adrf        ;save expected flags except overflow
32c4 : 38                       sec             ;test with carry set
32c5 : 20d034                   jsr chkadd
32c8 : c60c                     dec adfc        ;same for operand +1 but no carry
32ca : e60d                     inc ad1
32cc : d0e0                     bne tadd        ;iterate op1
32ce : a900                     lda #0          ;preset result to op2 when op1 = 0
32d0 : 8510                     sta adrh
32d2 : ee0302                   inc ada2
32d5 : e60e                     inc ad2
32d7 : 08                       php             ;save NZ as operand 2 becomes the new result
32d8 : 68                       pla
32d9 : 2982                     and #$82        ;mask N00000Z0
32db : 8511                     sta adrf        ;no need to check carry as we are adding to 0
32dd : c612                     dec sb2         ;complement subtract operand 2
32df : ce0402                   dec sba2
32e2 : a50e                     lda ad2         
32e4 : 850f                     sta adrl
32e6 : d0c6                     bne tadd        ;iterate op2
                                next_test
32e8 : ad0002          >            lda test_case   ;previous test
32eb : c929            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
32ed : d0fe            >        bne *           ;failed not equal (non zero)
                       >
002a =                 >test_num = test_num + 1
32ef : a92a            >            lda #test_num   ;*** next tests' number
32f1 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; decimal add/subtract test
                        ; *** WARNING - tests documented behavior only! ***
                        ;   only valid BCD operands are tested, N V Z flags are ignored
                        ; iterates through all valid combinations of operands and carry input
                        ; uses increments/decrements to predict result & carry flag
32f4 : f8                       sed 
32f5 : a20e                     ldx #ad2        ;for indexed test
32f7 : a0ff                     ldy #$ff        ;max range
32f9 : a999                     lda #$99        ;start with adding 99 to 99 with carry
32fb : 850d                     sta ad1         ;operand 1 - accumulator
32fd : 850e                     sta ad2         ;operand 2 - memory or immediate
32ff : 8d0302                   sta ada2        ;non zp
3302 : 850f                     sta adrl        ;expected result bits 0-7
3304 : a901                     lda #1          ;set carry in & out
3306 : 850c                     sta adfc        ;carry in - for diag
3308 : 8510                     sta adrh        ;expected result bit 8 (carry out)
330a : a900                     lda #0          ;complemented operand 2 for subtract
330c : 8512                     sta sb2
330e : 8d0402                   sta sba2        ;non zp
3311 : 38               tdad    sec             ;test with carry set
3312 : 209f33                   jsr chkdad
3315 : c60c                     dec adfc        ;now with carry clear
3317 : a50f                     lda adrl        ;decimal adjust result
3319 : d008                     bne tdad1       ;skip clear carry & preset result 99 (9A-1)
331b : c610                     dec adrh
331d : a999                     lda #$99
331f : 850f                     sta adrl
3321 : d012                     bne tdad3
3323 : 290f             tdad1   and #$f         ;lower nibble mask
3325 : d00c                     bne tdad2       ;no decimal adjust needed
3327 : c60f                     dec adrl        ;decimal adjust (?0-6)
3329 : c60f                     dec adrl
332b : c60f                     dec adrl
332d : c60f                     dec adrl
332f : c60f                     dec adrl
3331 : c60f                     dec adrl
3333 : c60f             tdad2   dec adrl        ;result -1
3335 : 18               tdad3   clc             ;test with carry clear
3336 : 209f33                   jsr chkdad
3339 : e60c                     inc adfc        ;same for operand -1 but with carry
333b : a50d                     lda ad1         ;decimal adjust operand 1
333d : f015                     beq tdad5       ;iterate operand 2
333f : 290f                     and #$f         ;lower nibble mask
3341 : d00c                     bne tdad4       ;skip decimal adjust
3343 : c60d                     dec ad1         ;decimal adjust (?0-6)
3345 : c60d                     dec ad1
3347 : c60d                     dec ad1
3349 : c60d                     dec ad1
334b : c60d                     dec ad1
334d : c60d                     dec ad1
334f : c60d             tdad4   dec ad1         ;operand 1 -1
3351 : 4c1133                   jmp tdad        ;iterate op1
                        
3354 : a999             tdad5   lda #$99        ;precharge op1 max
3356 : 850d                     sta ad1
3358 : a50e                     lda ad2         ;decimal adjust operand 2
335a : f030                     beq tdad7       ;end of iteration
335c : 290f                     and #$f         ;lower nibble mask
335e : d018                     bne tdad6       ;skip decimal adjust
3360 : c60e                     dec ad2         ;decimal adjust (?0-6)
3362 : c60e                     dec ad2
3364 : c60e                     dec ad2
3366 : c60e                     dec ad2
3368 : c60e                     dec ad2
336a : c60e                     dec ad2
336c : e612                     inc sb2         ;complemented decimal adjust for subtract (?9+6)
336e : e612                     inc sb2
3370 : e612                     inc sb2
3372 : e612                     inc sb2
3374 : e612                     inc sb2
3376 : e612                     inc sb2
3378 : c60e             tdad6   dec ad2         ;operand 2 -1
337a : e612                     inc sb2         ;complemented operand for subtract
337c : a512                     lda sb2
337e : 8d0402                   sta sba2        ;copy as non zp operand
3381 : a50e                     lda ad2
3383 : 8d0302                   sta ada2        ;copy as non zp operand
3386 : 850f                     sta adrl        ;new result since op1+carry=00+carry +op2=op2
3388 : e610                     inc adrh        ;result carry
338a : d085                     bne tdad        ;iterate op2
338c : d8               tdad7   cld
                        
338d : ad0002                   lda test_case
3390 : c92a                     cmp #test_num
                                trap_ne         ;previous test is out of sequence
3392 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3394 : a9f0                     lda #$f0        ;mark opcode testing complete
3396 : 8d0002                   sta test_case
                                
                        ; final RAM integrity test
                        ;   verifies that none of the previous tests has altered RAM outside of the
                        ;   designated write areas.
                                check_ram
                       >            ;RAM check disabled - RAM size not set
                        
                        ; *** DEBUG INFO ***
                        ; to debug checksum errors uncomment check_ram in the next_test macro to 
                        ; narrow down the responsible opcode.
                        ; may give false errors when monitor, OS or other background activity is
                        ; allowed during previous tests.
                        
                        
                        ; S U C C E S S ************************************************       
                        ; -------------       
                                success         ;if you get here everything went well
3399 : 4c9933          >        jmp *           ;test passed, no errors
                        
                        ; -------------       
                        ; S U C C E S S ************************************************ 
339c : 4c0004                   jmp start       ;run again      
                        
                        ; core subroutine of the decimal add/subtract test
                        ; *** WARNING - tests documented behavior only! ***
                        ;   only valid BCD operands are tested, N V Z flags are ignored
                        ; iterates through all valid combinations of operands and carry input
                        ; uses increments/decrements to predict result & carry flag
339f :                  chkdad
                        ; decimal ADC / SBC zp
339f : 08                       php             ;save carry for subtract
33a0 : a50d                     lda ad1
33a2 : 650e                     adc ad2         ;perform add
33a4 : 08                       php          
33a5 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
33a7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
33a9 : 68                       pla             ;check flags
33aa : 2901                     and #1          ;mask carry
33ac : c510                     cmp adrh
                                trap_ne         ;bad carry
33ae : d0fe            >        bne *           ;failed not equal (non zero)
                        
33b0 : 28                       plp
33b1 : 08                       php             ;save carry for next add
33b2 : a50d                     lda ad1
33b4 : e512                     sbc sb2         ;perform subtract
33b6 : 08                       php          
33b7 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
33b9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
33bb : 68                       pla             ;check flags
33bc : 2901                     and #1          ;mask carry
33be : c510                     cmp adrh
                                trap_ne         ;bad flags
33c0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
33c2 : 28                       plp
                        ; decimal ADC / SBC abs
33c3 : 08                       php             ;save carry for subtract
33c4 : a50d                     lda ad1
33c6 : 6d0302                   adc ada2        ;perform add
33c9 : 08                       php          
33ca : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
33cc : d0fe            >        bne *           ;failed not equal (non zero)
                        
33ce : 68                       pla             ;check flags
33cf : 2901                     and #1          ;mask carry
33d1 : c510                     cmp adrh
                                trap_ne         ;bad carry
33d3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
33d5 : 28                       plp
33d6 : 08                       php             ;save carry for next add
33d7 : a50d                     lda ad1
33d9 : ed0402                   sbc sba2        ;perform subtract
33dc : 08                       php          
33dd : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
33df : d0fe            >        bne *           ;failed not equal (non zero)
                        
33e1 : 68                       pla             ;check flags
33e2 : 2901                     and #1          ;mask carry
33e4 : c510                     cmp adrh
                                trap_ne         ;bad carry
33e6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
33e8 : 28                       plp
                        ; decimal ADC / SBC #
33e9 : 08                       php             ;save carry for subtract
33ea : a50e                     lda ad2
33ec : 8df233                   sta chkdadi     ;self modify immediate
33ef : a50d                     lda ad1
33f2 =                  chkdadi = * + 1         ;operand of the immediate ADC
33f1 : 6900                     adc #0          ;perform add
33f3 : 08                       php          
33f4 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
33f6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
33f8 : 68                       pla             ;check flags
33f9 : 2901                     and #1          ;mask carry
33fb : c510                     cmp adrh
                                trap_ne         ;bad carry
33fd : d0fe            >        bne *           ;failed not equal (non zero)
                        
33ff : 28                       plp
3400 : 08                       php             ;save carry for next add
3401 : a512                     lda sb2
3403 : 8d0934                   sta chkdsbi     ;self modify immediate
3406 : a50d                     lda ad1
3409 =                  chkdsbi = * + 1         ;operand of the immediate SBC
3408 : e900                     sbc #0          ;perform subtract
340a : 08                       php          
340b : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
340d : d0fe            >        bne *           ;failed not equal (non zero)
                        
340f : 68                       pla             ;check flags
3410 : 2901                     and #1          ;mask carry
3412 : c510                     cmp adrh
                                trap_ne         ;bad carry
3414 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3416 : 28                       plp
                        ; decimal ADC / SBC zp,x
3417 : 08                       php             ;save carry for subtract
3418 : a50d                     lda ad1
341a : 7500                     adc 0,x         ;perform add
341c : 08                       php          
341d : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
341f : d0fe            >        bne *           ;failed not equal (non zero)
                        
3421 : 68                       pla             ;check flags
3422 : 2901                     and #1          ;mask carry
3424 : c510                     cmp adrh
                                trap_ne         ;bad carry
3426 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3428 : 28                       plp
3429 : 08                       php             ;save carry for next add
342a : a50d                     lda ad1
342c : f504                     sbc sb2-ad2,x   ;perform subtract
342e : 08                       php          
342f : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
3431 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3433 : 68                       pla             ;check flags
3434 : 2901                     and #1          ;mask carry
3436 : c510                     cmp adrh
                                trap_ne         ;bad carry
3438 : d0fe            >        bne *           ;failed not equal (non zero)
                        
343a : 28                       plp
                        ; decimal ADC / SBC abs,x
343b : 08                       php             ;save carry for subtract
343c : a50d                     lda ad1
343e : 7df501                   adc ada2-ad2,x  ;perform add
3441 : 08                       php          
3442 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
3444 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3446 : 68                       pla             ;check flags
3447 : 2901                     and #1          ;mask carry
3449 : c510                     cmp adrh
                                trap_ne         ;bad carry
344b : d0fe            >        bne *           ;failed not equal (non zero)
                        
344d : 28                       plp
344e : 08                       php             ;save carry for next add
344f : a50d                     lda ad1
3451 : fdf601                   sbc sba2-ad2,x  ;perform subtract
3454 : 08                       php          
3455 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
3457 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3459 : 68                       pla             ;check flags
345a : 2901                     and #1          ;mask carry
345c : c510                     cmp adrh
                                trap_ne         ;bad carry
345e : d0fe            >        bne *           ;failed not equal (non zero)
                        
3460 : 28                       plp
                        ; decimal ADC / SBC abs,y
3461 : 08                       php             ;save carry for subtract
3462 : a50d                     lda ad1
3464 : 790401                   adc ada2-$ff,y  ;perform add
3467 : 08                       php          
3468 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
346a : d0fe            >        bne *           ;failed not equal (non zero)
                        
346c : 68                       pla             ;check flags
346d : 2901                     and #1          ;mask carry
346f : c510                     cmp adrh
                                trap_ne         ;bad carry
3471 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3473 : 28                       plp
3474 : 08                       php             ;save carry for next add
3475 : a50d                     lda ad1
3477 : f90501                   sbc sba2-$ff,y  ;perform subtract
347a : 08                       php          
347b : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
347d : d0fe            >        bne *           ;failed not equal (non zero)
                        
347f : 68                       pla             ;check flags
3480 : 2901                     and #1          ;mask carry
3482 : c510                     cmp adrh
                                trap_ne         ;bad carry
3484 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3486 : 28                       plp
                        ; decimal ADC / SBC (zp,x)
3487 : 08                       php             ;save carry for subtract
3488 : a50d                     lda ad1
348a : 6144                     adc (lo adi2-ad2,x) ;perform add
348c : 08                       php          
348d : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
348f : d0fe            >        bne *           ;failed not equal (non zero)
                        
3491 : 68                       pla             ;check flags
3492 : 2901                     and #1          ;mask carry
3494 : c510                     cmp adrh
                                trap_ne         ;bad carry
3496 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3498 : 28                       plp
3499 : 08                       php             ;save carry for next add
349a : a50d                     lda ad1
349c : e146                     sbc (lo sbi2-ad2,x) ;perform subtract
349e : 08                       php          
349f : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
34a1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34a3 : 68                       pla             ;check flags
34a4 : 2901                     and #1          ;mask carry
34a6 : c510                     cmp adrh
                                trap_ne         ;bad carry
34a8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34aa : 28                       plp
                        ; decimal ADC / SBC (abs),y
34ab : 08                       php             ;save carry for subtract
34ac : a50d                     lda ad1
34ae : 7156                     adc (adiy2),y   ;perform add
34b0 : 08                       php          
34b1 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
34b3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34b5 : 68                       pla             ;check flags
34b6 : 2901                     and #1          ;mask carry
34b8 : c510                     cmp adrh
                                trap_ne         ;bad carry
34ba : d0fe            >        bne *           ;failed not equal (non zero)
                        
34bc : 28                       plp
34bd : 08                       php             ;save carry for next add
34be : a50d                     lda ad1
34c0 : f158                     sbc (sbiy2),y   ;perform subtract
34c2 : 08                       php          
34c3 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
34c5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34c7 : 68                       pla             ;check flags
34c8 : 2901                     and #1          ;mask carry
34ca : c510                     cmp adrh
                                trap_ne         ;bad carry
34cc : d0fe            >        bne *           ;failed not equal (non zero)
                        
34ce : 28                       plp
34cf : 60                       rts
                        
                        ; core subroutine of the full binary add/subtract test
                        ; iterates through all combinations of operands and carry input
                        ; uses increments/decrements to predict result & result flags
34d0 : a511             chkadd  lda adrf        ;add V-flag if overflow
34d2 : 2983                     and #$83        ;keep N-----ZC / clear V
34d4 : 48                       pha
34d5 : a50d                     lda ad1         ;test sign unequal between operands
34d7 : 450e                     eor ad2
34d9 : 300a                     bmi ckad1       ;no overflow possible - operands have different sign
34db : a50d                     lda ad1         ;test sign equal between operands and result
34dd : 450f                     eor adrl
34df : 1004                     bpl ckad1       ;no overflow occured - operand and result have same sign
34e1 : 68                       pla
34e2 : 0940                     ora #$40        ;set V
34e4 : 48                       pha
34e5 : 68               ckad1   pla
34e6 : 8511                     sta adrf        ;save expected flags
                        ; binary ADC / SBC zp
34e8 : 08                       php             ;save carry for subtract
34e9 : a50d                     lda ad1
34eb : 650e                     adc ad2         ;perform add
34ed : 08                       php          
34ee : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
34f0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34f2 : 68                       pla             ;check flags
34f3 : 29c3                     and #$c3        ;mask NV----ZC
34f5 : c511                     cmp adrf
                                trap_ne         ;bad flags
34f7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34f9 : 28                       plp
34fa : 08                       php             ;save carry for next add
34fb : a50d                     lda ad1
34fd : e512                     sbc sb2         ;perform subtract
34ff : 08                       php          
3500 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
3502 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3504 : 68                       pla             ;check flags
3505 : 29c3                     and #$c3        ;mask NV----ZC
3507 : c511                     cmp adrf
                                trap_ne         ;bad flags
3509 : d0fe            >        bne *           ;failed not equal (non zero)
                        
350b : 28                       plp
                        ; binary ADC / SBC abs
350c : 08                       php             ;save carry for subtract
350d : a50d                     lda ad1
350f : 6d0302                   adc ada2        ;perform add
3512 : 08                       php          
3513 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
3515 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3517 : 68                       pla             ;check flags
3518 : 29c3                     and #$c3        ;mask NV----ZC
351a : c511                     cmp adrf
                                trap_ne         ;bad flags
351c : d0fe            >        bne *           ;failed not equal (non zero)
                        
351e : 28                       plp
351f : 08                       php             ;save carry for next add
3520 : a50d                     lda ad1
3522 : ed0402                   sbc sba2        ;perform subtract
3525 : 08                       php          
3526 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
3528 : d0fe            >        bne *           ;failed not equal (non zero)
                        
352a : 68                       pla             ;check flags
352b : 29c3                     and #$c3        ;mask NV----ZC
352d : c511                     cmp adrf
                                trap_ne         ;bad flags
352f : d0fe            >        bne *           ;failed not equal (non zero)
                        
3531 : 28                       plp
                        ; binary ADC / SBC #
3532 : 08                       php             ;save carry for subtract
3533 : a50e                     lda ad2
3535 : 8d3b35                   sta chkadi      ;self modify immediate
3538 : a50d                     lda ad1
353b =                  chkadi  = * + 1         ;operand of the immediate ADC
353a : 6900                     adc #0          ;perform add
353c : 08                       php          
353d : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
353f : d0fe            >        bne *           ;failed not equal (non zero)
                        
3541 : 68                       pla             ;check flags
3542 : 29c3                     and #$c3        ;mask NV----ZC
3544 : c511                     cmp adrf
                                trap_ne         ;bad flags
3546 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3548 : 28                       plp
3549 : 08                       php             ;save carry for next add
354a : a512                     lda sb2
354c : 8d5235                   sta chksbi      ;self modify immediate
354f : a50d                     lda ad1
3552 =                  chksbi  = * + 1         ;operand of the immediate SBC
3551 : e900                     sbc #0          ;perform subtract
3553 : 08                       php          
3554 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
3556 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3558 : 68                       pla             ;check flags
3559 : 29c3                     and #$c3        ;mask NV----ZC
355b : c511                     cmp adrf
                                trap_ne         ;bad flags
355d : d0fe            >        bne *           ;failed not equal (non zero)
                        
355f : 28                       plp
                        ; binary ADC / SBC zp,x
3560 : 08                       php             ;save carry for subtract
3561 : a50d                     lda ad1
3563 : 7500                     adc 0,x         ;perform add
3565 : 08                       php          
3566 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
3568 : d0fe            >        bne *           ;failed not equal (non zero)
                        
356a : 68                       pla             ;check flags
356b : 29c3                     and #$c3        ;mask NV----ZC
356d : c511                     cmp adrf
                                trap_ne         ;bad flags
356f : d0fe            >        bne *           ;failed not equal (non zero)
                        
3571 : 28                       plp
3572 : 08                       php             ;save carry for next add
3573 : a50d                     lda ad1
3575 : f504                     sbc sb2-ad2,x   ;perform subtract
3577 : 08                       php          
3578 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
357a : d0fe            >        bne *           ;failed not equal (non zero)
                        
357c : 68                       pla             ;check flags
357d : 29c3                     and #$c3        ;mask NV----ZC
357f : c511                     cmp adrf
                                trap_ne         ;bad flags
3581 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3583 : 28                       plp
                        ; binary ADC / SBC abs,x
3584 : 08                       php             ;save carry for subtract
3585 : a50d                     lda ad1
3587 : 7df501                   adc ada2-ad2,x  ;perform add
358a : 08                       php          
358b : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
358d : d0fe            >        bne *           ;failed not equal (non zero)
                        
358f : 68                       pla             ;check flags
3590 : 29c3                     and #$c3        ;mask NV----ZC
3592 : c511                     cmp adrf
                                trap_ne         ;bad flags
3594 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3596 : 28                       plp
3597 : 08                       php             ;save carry for next add
3598 : a50d                     lda ad1
359a : fdf601                   sbc sba2-ad2,x  ;perform subtract
359d : 08                       php          
359e : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
35a0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
35a2 : 68                       pla             ;check flags
35a3 : 29c3                     and #$c3        ;mask NV----ZC
35a5 : c511                     cmp adrf
                                trap_ne         ;bad flags
35a7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
35a9 : 28                       plp
                        ; binary ADC / SBC abs,y
35aa : 08                       php             ;save carry for subtract
35ab : a50d                     lda ad1
35ad : 790401                   adc ada2-$ff,y  ;perform add
35b0 : 08                       php          
35b1 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
35b3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
35b5 : 68                       pla             ;check flags
35b6 : 29c3                     and #$c3        ;mask NV----ZC
35b8 : c511                     cmp adrf
                                trap_ne         ;bad flags
35ba : d0fe            >        bne *           ;failed not equal (non zero)
                        
35bc : 28                       plp
35bd : 08                       php             ;save carry for next add
35be : a50d                     lda ad1
35c0 : f90501                   sbc sba2-$ff,y  ;perform subtract
35c3 : 08                       php          
35c4 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
35c6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
35c8 : 68                       pla             ;check flags
35c9 : 29c3                     and #$c3        ;mask NV----ZC
35cb : c511                     cmp adrf
                                trap_ne         ;bad flags
35cd : d0fe            >        bne *           ;failed not equal (non zero)
                        
35cf : 28                       plp
                        ; binary ADC / SBC (zp,x)
35d0 : 08                       php             ;save carry for subtract
35d1 : a50d                     lda ad1
35d3 : 6144                     adc (lo adi2-ad2,x) ;perform add
35d5 : 08                       php          
35d6 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
35d8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
35da : 68                       pla             ;check flags
35db : 29c3                     and #$c3        ;mask NV----ZC
35dd : c511                     cmp adrf
                                trap_ne         ;bad flags
35df : d0fe            >        bne *           ;failed not equal (non zero)
                        
35e1 : 28                       plp
35e2 : 08                       php             ;save carry for next add
35e3 : a50d                     lda ad1
35e5 : e146                     sbc (lo sbi2-ad2,x) ;perform subtract
35e7 : 08                       php          
35e8 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
35ea : d0fe            >        bne *           ;failed not equal (non zero)
                        
35ec : 68                       pla             ;check flags
35ed : 29c3                     and #$c3        ;mask NV----ZC
35ef : c511                     cmp adrf
                                trap_ne         ;bad flags
35f1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
35f3 : 28                       plp
                        ; binary ADC / SBC (abs),y
35f4 : 08                       php             ;save carry for subtract
35f5 : a50d                     lda ad1
35f7 : 7156                     adc (adiy2),y   ;perform add
35f9 : 08                       php          
35fa : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
35fc : d0fe            >        bne *           ;failed not equal (non zero)
                        
35fe : 68                       pla             ;check flags
35ff : 29c3                     and #$c3        ;mask NV----ZC
3601 : c511                     cmp adrf
                                trap_ne         ;bad flags
3603 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3605 : 28                       plp
3606 : 08                       php             ;save carry for next add
3607 : a50d                     lda ad1
3609 : f158                     sbc (sbiy2),y   ;perform subtract
360b : 08                       php          
360c : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
360e : d0fe            >        bne *           ;failed not equal (non zero)
                        
3610 : 68                       pla             ;check flags
3611 : 29c3                     and #$c3        ;mask NV----ZC
3613 : c511                     cmp adrf
                                trap_ne         ;bad flags
3615 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3617 : 28                       plp
3618 : 60                       rts
                        
                        ; target for the jump absolute test
3619 : 88                       dey
361a : 88                       dey
361b :                  test_far
361b : 08                       php             ;either SP or Y count will fail, if we do not hit
361c : 88                       dey
361d : 88                       dey
361e : 88                       dey
361f : 28                       plp
                                trap_cs         ;flags loaded?
3620 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
3622 : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
3624 : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_eq 
3626 : f0fe            >        beq *           ;failed equal (zero)
                        
3628 : c946                     cmp #'F'        ;registers loaded?
                                trap_ne
362a : d0fe            >        bne *           ;failed not equal (non zero)
                        
362c : e041                     cpx #'A'
                                trap_ne        
362e : d0fe            >        bne *           ;failed not equal (non zero)
                        
3630 : c04f                     cpy #('R'-3)
                                trap_ne
3632 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3634 : 48                       pha             ;save a,x
3635 : 8a                       txa
3636 : 48                       pha
3637 : ba                       tsx
3638 : e0fd                     cpx #$fd        ;check SP
                                trap_ne
363a : d0fe            >        bne *           ;failed not equal (non zero)
                        
363c : 68                       pla             ;restore x
363d : aa                       tax
                                set_stat $ff
                       >            load_flag $ff
363e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3640 : 48              >            pha         ;use stack to load status
3641 : 28              >            plp
                        
3642 : 68                       pla             ;restore a
3643 : e8                       inx             ;return registers with modifications
3644 : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
3646 : 4cc208                   jmp far_ret
                                
                        ; target for the jump indirect test
3649 : 00                       align
364a : 5336             ptr_tst_ind dw test_ind
364c : 1709             ptr_ind_ret dw ind_ret
                                trap            ;runover protection
364e : 4c4e36          >        jmp *           ;failed anyway
                        
3651 : 88                       dey
3652 : 88                       dey
3653 :                  test_ind
3653 : 08                       php             ;either SP or Y count will fail, if we do not hit
3654 : 88                       dey
3655 : 88                       dey
3656 : 88                       dey
3657 : 28                       plp
                                trap_cs         ;flags loaded?
3658 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
365a : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
365c : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_eq 
365e : f0fe            >        beq *           ;failed equal (zero)
                        
3660 : c949                     cmp #'I'        ;registers loaded?
                                trap_ne
3662 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3664 : e04e                     cpx #'N'
                                trap_ne        
3666 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3668 : c041                     cpy #('D'-3)
                                trap_ne
366a : d0fe            >        bne *           ;failed not equal (non zero)
                        
366c : 48                       pha             ;save a,x
366d : 8a                       txa
366e : 48                       pha
366f : ba                       tsx
3670 : e0fd                     cpx #$fd        ;check SP
                                trap_ne
3672 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3674 : 68                       pla             ;restore x
3675 : aa                       tax
                                set_stat $ff
                       >            load_flag $ff
3676 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3678 : 48              >            pha         ;use stack to load status
3679 : 28              >            plp
                        
367a : 68                       pla             ;restore a
367b : e8                       inx             ;return registers with modifications
367c : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
367e : 6c4c36                   jmp (ptr_ind_ret)
                                trap            ;runover protection
3681 : 4c8136          >        jmp *           ;failed anyway
                        
                        
                        ; target for the jump subroutine test
3684 : 88                       dey
3685 : 88                       dey
3686 :                  test_jsr
3686 : 08                       php             ;either SP or Y count will fail, if we do not hit
3687 : 88                       dey
3688 : 88                       dey
3689 : 88                       dey
368a : 28                       plp
                                trap_cs         ;flags loaded?
368b : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
368d : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
368f : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_eq 
3691 : f0fe            >        beq *           ;failed equal (zero)
                        
3693 : c94a                     cmp #'J'        ;registers loaded?
                                trap_ne
3695 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3697 : e053                     cpx #'S'
                                trap_ne        
3699 : d0fe            >        bne *           ;failed not equal (non zero)
                        
369b : c04f                     cpy #('R'-3)
                                trap_ne
369d : d0fe            >        bne *           ;failed not equal (non zero)
                        
369f : 48                       pha             ;save a,x
36a0 : 8a                       txa
36a1 : 48                       pha       
36a2 : ba                       tsx             ;sp -4? (return addr,a,x)
36a3 : e0fb                     cpx #$fb
                                trap_ne
36a5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
36a7 : adff01                   lda $1ff        ;propper return on stack
36aa : c909                     cmp #hi(jsr_ret)
                                trap_ne
36ac : d0fe            >        bne *           ;failed not equal (non zero)
                        
36ae : adfe01                   lda $1fe
36b1 : c94d                     cmp #lo(jsr_ret)
                                trap_ne
36b3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
36b5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
36b7 : 48              >            pha         ;use stack to load status
36b8 : 28              >            plp
                        
36b9 : 68                       pla             ;pull x,a
36ba : aa                       tax
36bb : 68                       pla
36bc : e8                       inx             ;return registers with modifications
36bd : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
36bf : 60                       rts
                                trap            ;runover protection
36c0 : 4cc036          >        jmp *           ;failed anyway
                        
                                
                        ;trap in case of unexpected IRQ, NMI, BRK, RESET - BRK test target
36c3 :                  nmi_trap
                                trap            ;check stack for conditions at NMI
36c3 : 4cc336          >        jmp *           ;failed anyway
                        
36c6 :                  res_trap
                                trap            ;unexpected RESET
36c6 : 4cc636          >        jmp *           ;failed anyway
                        
                                
36c9 : 88                       dey
36ca : 88                       dey
36cb :                  irq_trap                ;BRK test or unextpected BRK or IRQ
36cb : 08                       php             ;either SP or Y count will fail, if we do not hit
36cc : 88                       dey
36cd : 88                       dey
36ce : 88                       dey
                                ;next 4 traps could be caused by unexpected BRK or IRQ
                                ;check stack for BREAK and originating location
                                ;possible jump/branch into weeds (uninitialized space)
36cf : c942                     cmp #'B'        ;registers loaded?
                                trap_ne
36d1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
36d3 : e052                     cpx #'R'
                                trap_ne        
36d5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
36d7 : c048                     cpy #('K'-3)
                                trap_ne
36d9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
36db : 850a                     sta irq_a       ;save registers during break test
36dd : 860b                     stx irq_x
36df : ba                       tsx             ;test break on stack
36e0 : bd0201                   lda $102,x
                                cmp_flag 0      ;break test should have B=1
36e3 : c930            >            cmp #(0      |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne         ; - no break flag on stack
36e5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
36e7 : 68                       pla
36e8 : c934                     cmp #fai        ;should have added interrupt disable
                                trap_ne
36ea : d0fe            >        bne *           ;failed not equal (non zero)
                        
36ec : ba                       tsx
36ed : e0fc                     cpx #$fc        ;sp -3? (return addr, flags)
                                trap_ne
36ef : d0fe            >        bne *           ;failed not equal (non zero)
                        
36f1 : adff01                   lda $1ff        ;propper return on stack
36f4 : c909                     cmp #hi(brk_ret)
                                trap_ne
36f6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
36f8 : adfe01                   lda $1fe
36fb : c984                     cmp #lo(brk_ret)
                                trap_ne
36fd : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
36ff : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3701 : 48              >            pha         ;use stack to load status
3702 : 28              >            plp
                        
3703 : a60b                     ldx irq_x
3705 : e8                       inx             ;return registers with modifications
3706 : a50a                     lda irq_a
3708 : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1 but original flags should be restored
370a : 40                       rti
                                trap            ;runover protection
370b : 4c0b37          >        jmp *           ;failed anyway
                        
                                
                            if report = 1
                                include "report.i65"
                            endif
                                
                        ;copy of data to initialize BSS segment
                            if load_data_direct != 1
                        zp_init
                        zp1_    db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
                        zp7f_   db  $7f             ;test pattern for compare  
                        ;logical zeropage operands
                        zpOR_   db  0,$1f,$71,$80   ;test pattern for OR
                        zpAN_   db  $0f,$ff,$7f,$80 ;test pattern for AND
                        zpEO_   db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;indirect addressing pointers
                        ind1_   dw  abs1            ;indirect pointer to pattern in absolute memory
                                dw  abs1+1
                                dw  abs1+2
                                dw  abs1+3
                                dw  abs7f
                        inw1_   dw  abs1-$f8        ;indirect pointer for wrap-test pattern
                        indt_   dw  abst            ;indirect pointer to store area in absolute memory
                                dw  abst+1
                                dw  abst+2
                                dw  abst+3
                        inwt_   dw  abst-$f8        ;indirect pointer for wrap-test store
                        indAN_  dw  absAN           ;indirect pointer to AND pattern in absolute memory
                                dw  absAN+1
                                dw  absAN+2
                                dw  absAN+3
                        indEO_  dw  absEO           ;indirect pointer to EOR pattern in absolute memory
                                dw  absEO+1
                                dw  absEO+2
                                dw  absEO+3
                        indOR_  dw  absOR           ;indirect pointer to OR pattern in absolute memory
                                dw  absOR+1
                                dw  absOR+2
                                dw  absOR+3
                        ;add/subtract indirect pointers
                        adi2_   dw  ada2            ;indirect pointer to operand 2 in absolute memory
                        sbi2_   dw  sba2            ;indirect pointer to complemented operand 2 (SBC)
                        adiy2_  dw  ada2-$ff        ;with offset for indirect indexed
                        sbiy2_  dw  sba2-$ff
                        zp_end
                            if (zp_end - zp_init) != (zp_bss_end - zp_bss)   
                                ;force assembler error if size is different   
                                ERROR ERROR ERROR   ;mismatch between bss and zeropage data
                            endif 
                        data_init
                        abs1_   db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
                        abs7f_  db  $7f             ;test pattern for compare
                        ;loads
                        fLDx_   db  fn,fn,0,fz      ;expected flags for load
                        ;shifts
                        rASL_                       ;expected result ASL & ROL -carry  
                        rROL_   db  $86,$04,$82,0   ; "
                        rROLc_  db  $87,$05,$83,1   ;expected result ROL +carry
                        rLSR_                       ;expected result LSR & ROR -carry
                        rROR_   db  $61,$41,$20,0   ; "
                        rRORc_  db  $e1,$c1,$a0,$80 ;expected result ROR +carry
                        fASL_                       ;expected flags for shifts
                        fROL_   db  fnc,fc,fn,fz    ;no carry in
                        fROLc_  db  fnc,fc,fn,0     ;carry in
                        fLSR_
                        fROR_   db  fc,0,fc,fz      ;no carry in
                        fRORc_  db  fnc,fn,fnc,fn   ;carry in
                        ;increments (decrements)
                        rINC_   db  $7f,$80,$ff,0,1 ;expected result for INC/DEC
                        fINC_   db  0,fn,fn,fz,0    ;expected flags for INC/DEC
                        ;logical memory operand
                        absOR_  db  0,$1f,$71,$80   ;test pattern for OR
                        absAN_  db  $0f,$ff,$7f,$80 ;test pattern for AND
                        absEO_  db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;logical accu operand
                        absORa_ db  0,$f1,$1f,0     ;test pattern for OR
                        absANa_ db  $f0,$ff,$ff,$ff ;test pattern for AND
                        absEOa_ db  $ff,$f0,$f0,$0f ;test pattern for EOR
                        ;logical results
                        absrlo_ db  0,$ff,$7f,$80
                        absflo_ db  fz,fn,0,fn
                        data_end
                            if (data_end - data_init) != (data_bss_end - data_bss)
                                ;force assembler error if size is different   
                                ERROR ERROR ERROR   ;mismatch between bss and data
                            endif 
                        
                        vec_init
                                dw  nmi_trap
                                dw  res_trap
                                dw  irq_trap
                        vec_bss equ $fffa
                            endif                   ;end of RAM init data
                            
                            if (load_data_direct = 1) & (ROM_vectors = 1)  
fffa =                          org $fffa       ;vectors
fffa : c336                     dw  nmi_trap
fffc : c636                     dw  res_trap
fffe : cb36                     dw  irq_trap
                            endif
                        
fffa =                          end start
                                    
No errors in pass 2.
Wrote binary from address $0000 through $ffff.
Total size 65536 bytes.
Program start address is at $0400 (1024).

